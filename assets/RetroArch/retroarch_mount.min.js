(function(){let t=this;this.FsMount=class{constructor(e){Object.entries(e).forEach((t=>{Object.defineProperty(this,t[0],{get:()=>t[1]})})),this.speed=t.speed?t.speed:1e3/60,this.MEMFS.stream_ops.write=this.ops_write,this.MEMFS.ops_table&&(this.MEMFS.ops_table.file.stream.write=this.ops_write)}mount(t){this.FS.analyzePath(t.mountpoint).exists||this.FS.createPath("/",t.mountpoint,!0,!0);let e=t.mountpoint.split("/").length,s=this.MEMFS.createNode(e<3?this.FS.root:null,e<3?t.mountpoint.split("/").pop():t.mountpoint.replace(/^\//,""),16895,0);return this.getStoreName(t)&&(this.__mount||(this.__mount=[]),this.__mount.push(this.syncfs(t,(t=>{})))),s}mountReady=()=>Promise.all(this.__mount||[]);getStoreName=e=>t.DB_STORE_MAP[e.mountpoint];async syncfs(t,e,s){e=s instanceof Function?s:e;let i,n=this.getStoreName(t);if(n)return i=t.isReady?await this.syncWrite(n,t):await this.writeToFS(n),t.isReady=!0,e instanceof Function&&e(i),i}async writeToFS(e){return Object.entries(await t.getAllData(e,!0)).map((t=>this.storeLocalEntry(t[0],t[1]))).join("")}async syncWrite(e,s){let i=s.isReady,n=this.getLocalSet(s),a=await this.getRemoteSet(e),r=(i?n:a).entries||{},o=(i?a:n).entries||{};return(await Promise.all(Object.entries(r).filter((t=>{if(!t[1])return"";let e=t[0],s=o[e];return!s||t[1].timestamp>s.timestamp})).map((t=>t[0])).sort().map((async s=>{if(i){let i=this.loadLocalEntry(s);if(i)return await t.setItem(e,s,i),"DB saved:"+s+"\n"}else{let i=await t.getItem(e,s);if(i)return this.storeLocalEntry(s,i)}})))).join("")+(await Promise.all(Object.entries(o).filter((t=>{if(!t[1])return"";let e=r[t[0]];t[0];return!e||t[1].timestamp>e.timestamp})).map((t=>t[0])).sort().map((async s=>{let n="";return i?(await t.removeItem(e,s,!0),n="DB remove:"):(this.removeLocalEntry(s),n="FS remove:"),n+entry[0]+"\n"})))).join("")}loadLocalEntry(t){let e,s,i=this.FS;return i.analyzePath(t).exists?(s=i.lookupPath(t).node,e=i.stat(t),i.isDir(e.mode)?{timestamp:e.mtime,mode:e.mode}:i.isFile(e.mode)?(s.contents=this.getFileDataAsTypedArray(s),{timestamp:e.mtime,mode:e.mode,contents:s.contents}):"node type not supported"):t+" is exists"}storeLocalEntry(e,s){let i=this.FS;if(i.isDir(s.mode))!i.analyzePath(e).exists&&i.createPath("/",e,!0,!0);else if(i.isFile(s.mode)){let t=e&&e.split("/").slice(0,-1).join("/");t&&!i.analyzePath(t).exists&&i.createPath("/",t,!0,!0),i.writeFile(e,s.contents,{canOwn:!0,encoding:"binary"})}else t.Err("node type not supported");return i.chmod(e,s.mode),i.utime(e,s.timestamp,s.timestamp),"FS saved:"+e+"\n"}removeLocalEntry(t){if(FS.analyzePath(t).exists){var e=FS.stat(t);return FS.isDir(e.mode)?FS.rmdir(t):FS.isFile(e.mode)&&FS.unlink(t),"FS unlink:"+t+"\n"}return t+"is not exists\n"}async getRemoteSet(e,s){let i={type:"remote",store:e,entries:await t.getAllCursor(e,"timestamp",!0)};return s&&s(i),i}getLocalSet(e,s){e||t.Err("mount:PATH ERROR");let i={type:"local",entries:this.getLocalList(e.mountpoint)};return s&&s(i),i}getLocalList(e){e=e||"/";let s=this.FS,i={},n=[".",".."].concat("/"==e?["dev","tmp","proc"]:[]),a=t=>!n.includes(t),r=t=>e=>this.join2(t,e),o=this.stat(e)&&s.readdir(e).filter(a).map(r(e));for(o||t.Err("mount:PATH ERROR");o.length;){let t=o.pop();0;let e=this.stat(t);e&&(s.isDir(e.mode)&&o.push.apply(o,s.readdir(t).filter(a).map(r(t))),i[t]={timestamp:e.mtime})}return i}stat(t){let e=FS.analyzePath(t);if(e.exists&&e.object.node_ops&&e.object.node_ops.getattr)return this.FS.stat(t)}getFileDataAsTypedArray(t){return t.contents?t.contents.subarray?t.contents.subarray(0,t.usedBytes):new Uint8Array(t.contents):new Uint8Array}join(){var t=Array.prototype.slice.call(arguments,0);return this.normalize(t.join("/"))}join2(t,e){return this.normalize(t+"/"+e)}normalize(t){var e="/"===t.charAt(0),s="/"===t.substring(-1);return(t=this.normalizeArray(t.split("/").filter((t=>!!t)),!e).join("/"))||e||(t="."),t&&s&&(t+="/"),(e?"/":"")+t}normalizeArray(t,e){for(var s=0,i=t.length-1;i>=0;i--){var n=t[i];"."===n?t.splice(i,1):".."===n?(t.splice(i,1),s++):s&&(t.splice(i,1),s--)}if(e)for(;s;s--)t.unshift("..");return t}ops_write=(t,e,s,i,n,a)=>{if(this.HEAP8&&e.buffer===this.HEAP8.buffer&&(a=!1),!i)return 0;var r=t.node;if(r.timestamp=Date.now(),e.subarray&&(!r.contents||r.contents.subarray)){if(a)return r.contents=e.subarray(s,s+i),r.usedBytes=i,i;if(0===r.usedBytes&&0===n)return this.update(t),r.contents=new Uint8Array(e.subarray(s,s+i)),r.usedBytes=i,i;if(n+i<=r.usedBytes)return r.contents.set(e.subarray(s,s+i),n),i}if(this.MEMFS.expandFileStorage(r,n+i),r.contents.subarray&&e.subarray)r.contents.set(e.subarray(s,s+i),n);else for(var o=0;o<i;o++)r.contents[n+o]=e[s+o];return r.usedBytes=Math.max(r.usedBytes,n+i),i};update_promise(t){return new Promise(((e,s)=>{this.update_mount_list.includes(t.node.mount)||this.update_mount_list.push(t.node.mount);let i=setInterval((()=>{this.update_time&&i!=this.update_time&&(clearInterval(i),s("other update")),null==t.fd&&(clearInterval(i),e("ok"))}),this.speed);this.update_time=i}))}update_path=[];update_mount_list=[];async update_mount(){if(this.update_mount_list.length){let t=this.update_mount_list.map((async t=>this.syncfs(t,(t=>{}))));this.update_mount_list=[],this.update_path=[],await Promise.all(t)}}update(t){this.getStoreName(t.node.mount)&&t.path&&null!=t.fd&&!this.update_path.includes(t.path)&&(this.update_path.push(t.path),this.update_promise(t).then((t=>this.update_mount())))}MKFILE(t,e,s){let i=this.FS,n=t.split("/");if(n=n.length?n.slice(0,-1).join("/"):"/",!i.analyzePath(n).exists){let t=n.split("/").slice(0,-1).join("/");i.analyzePath(t).exists||i.createPath("/",t,!0,!0),i.createPath("/",n,!0,!0)}"string"==typeof e&&(e=(new TextEncoder).encode(e)),s?(i.analyzePath(t).exists&&i.unlink(t),i.writeFile(t,e,{canOwn:!0,encoding:"binary"})):i.analyzePath(t).exists||i.writeFile(t,e,{canOwn:!0,encoding:"binary"})}}}).call(Nenge);