<?php
 namespace ScssPhp\ScssPhp{ use Exception; use ScssPhp\ScssPhp\Version; use ScssPhp\ScssPhp\Base\Range; use ScssPhp\ScssPhp\Block\AtRootBlock; use ScssPhp\ScssPhp\Block\CallableBlock; use ScssPhp\ScssPhp\Block\DirectiveBlock; use ScssPhp\ScssPhp\Block\EachBlock; use ScssPhp\ScssPhp\Block\ElseBlock; use ScssPhp\ScssPhp\Block\ElseifBlock; use ScssPhp\ScssPhp\Block\ForBlock; use ScssPhp\ScssPhp\Block\IfBlock; use ScssPhp\ScssPhp\Block\MediaBlock; use ScssPhp\ScssPhp\Block\NestedPropertyBlock; use ScssPhp\ScssPhp\Block\WhileBlock; use ScssPhp\ScssPhp\Compiler\CachedResult; use ScssPhp\ScssPhp\Compiler\Environment; use ScssPhp\ScssPhp\Exception\CompilerException; use ScssPhp\ScssPhp\Exception\ParserException; use ScssPhp\ScssPhp\Exception\SassException; use ScssPhp\ScssPhp\Exception\SassScriptException; use ScssPhp\ScssPhp\Formatter\Compressed; use ScssPhp\ScssPhp\Formatter\Expanded; use ScssPhp\ScssPhp\Formatter\OutputBlock; use ScssPhp\ScssPhp\Logger\LoggerInterface; use ScssPhp\ScssPhp\Logger\StreamLogger; use ScssPhp\ScssPhp\Node\Number; use ScssPhp\ScssPhp\SourceMap\SourceMapGenerator; use ScssPhp\ScssPhp\Util\Path; use ScssPhp\ScssPhp\Block\ContentBlock; use ScssPhp\ScssPhp\Logger\QuietLogger; use ScssPhp\ScssPhp\Exception\RangeException; class Block { public $type; public $parent; public $sourceName; public $sourceIndex; public $sourceLine; public $sourceColumn; public $selectors; public $comments; public $children; public $selfParent; } class Cache { const CACHE_VERSION = 1; public static $cacheDir = false; public static $prefix = 'scssphp_'; public static $forceRefresh = false; public static $gcLifetime = 604800; protected static $refreshed = []; public function __construct($options) { if (isset($options['cacheDir'])) { self::$cacheDir = $options['cacheDir']; } if (empty(self::$cacheDir)) { throw new Exception('cacheDir not set'); } if (isset($options['prefix'])) { self::$prefix = $options['prefix']; } if (empty(self::$prefix)) { throw new Exception('prefix not set'); } if (isset($options['forceRefresh'])) { self::$forceRefresh = $options['forceRefresh']; } self::checkCacheDir(); } public function getCache($operation, $what, $options = [], $lastModified = null) { $fileCache = self::$cacheDir . self::cacheName($operation, $what, $options); if ( ((self::$forceRefresh === false) || (self::$forceRefresh === 'once' && isset(self::$refreshed[$fileCache]))) && file_exists($fileCache) ) { $cacheTime = filemtime($fileCache); if ( (\is_null($lastModified) || $cacheTime > $lastModified) && $cacheTime + self::$gcLifetime > time() ) { $c = file_get_contents($fileCache); $c = unserialize($c); if (\is_array($c) && isset($c['value'])) { return $c['value']; } } } return null; } public function setCache($operation, $what, $value, $options = []) { $fileCache = self::$cacheDir . self::cacheName($operation, $what, $options); $c = ['value' => $value]; $c = serialize($c); file_put_contents($fileCache, $c); if (self::$forceRefresh === 'once') { self::$refreshed[$fileCache] = true; } } private static function cacheName($operation, $what, $options = []) { $t = [ 'version' => self::CACHE_VERSION, 'scssphpVersion' => Version::VERSION, 'operation' => $operation, 'what' => $what, 'options' => $options ]; $t = self::$prefix . sha1(json_encode($t)) . ".$operation" . ".scsscache"; return $t; } public static function checkCacheDir() { self::$cacheDir = str_replace('\\', '/', self::$cacheDir); self::$cacheDir = rtrim(self::$cacheDir, '/') . '/'; if (! is_dir(self::$cacheDir)) { throw new Exception('Cache directory doesn\'t exist: ' . self::$cacheDir); } if (! is_writable(self::$cacheDir)) { throw new Exception('Cache directory isn\'t writable: ' . self::$cacheDir); } } public static function cleanCache() { static $clean = false; if ($clean || empty(self::$cacheDir)) { return; } $clean = true; $removeTypes = ['scsscache' => 1]; $files = scandir(self::$cacheDir); if (! $files) { return; } $checkTime = time() - self::$gcLifetime; foreach ($files as $file) { if (strpos($file, self::$prefix) !== 0) { continue; } $parts = explode('.', $file); $type = array_pop($parts); if (! isset($removeTypes[$type])) { continue; } $fullPath = self::$cacheDir . $file; $mtime = filemtime($fullPath); if ($mtime > $checkTime) { continue; } unlink($fullPath); } } } class Colors { protected static $cssColors = [ 'aliceblue' => '240,248,255', 'antiquewhite' => '250,235,215', 'aqua' => '0,255,255', 'cyan' => '0,255,255', 'aquamarine' => '127,255,212', 'azure' => '240,255,255', 'beige' => '245,245,220', 'bisque' => '255,228,196', 'black' => '0,0,0', 'blanchedalmond' => '255,235,205', 'blue' => '0,0,255', 'blueviolet' => '138,43,226', 'brown' => '165,42,42', 'burlywood' => '222,184,135', 'cadetblue' => '95,158,160', 'chartreuse' => '127,255,0', 'chocolate' => '210,105,30', 'coral' => '255,127,80', 'cornflowerblue' => '100,149,237', 'cornsilk' => '255,248,220', 'crimson' => '220,20,60', 'darkblue' => '0,0,139', 'darkcyan' => '0,139,139', 'darkgoldenrod' => '184,134,11', 'darkgray' => '169,169,169', 'darkgrey' => '169,169,169', 'darkgreen' => '0,100,0', 'darkkhaki' => '189,183,107', 'darkmagenta' => '139,0,139', 'darkolivegreen' => '85,107,47', 'darkorange' => '255,140,0', 'darkorchid' => '153,50,204', 'darkred' => '139,0,0', 'darksalmon' => '233,150,122', 'darkseagreen' => '143,188,143', 'darkslateblue' => '72,61,139', 'darkslategray' => '47,79,79', 'darkslategrey' => '47,79,79', 'darkturquoise' => '0,206,209', 'darkviolet' => '148,0,211', 'deeppink' => '255,20,147', 'deepskyblue' => '0,191,255', 'dimgray' => '105,105,105', 'dimgrey' => '105,105,105', 'dodgerblue' => '30,144,255', 'firebrick' => '178,34,34', 'floralwhite' => '255,250,240', 'forestgreen' => '34,139,34', 'fuchsia' => '255,0,255', 'magenta' => '255,0,255', 'gainsboro' => '220,220,220', 'ghostwhite' => '248,248,255', 'gold' => '255,215,0', 'goldenrod' => '218,165,32', 'gray' => '128,128,128', 'grey' => '128,128,128', 'green' => '0,128,0', 'greenyellow' => '173,255,47', 'honeydew' => '240,255,240', 'hotpink' => '255,105,180', 'indianred' => '205,92,92', 'indigo' => '75,0,130', 'ivory' => '255,255,240', 'khaki' => '240,230,140', 'lavender' => '230,230,250', 'lavenderblush' => '255,240,245', 'lawngreen' => '124,252,0', 'lemonchiffon' => '255,250,205', 'lightblue' => '173,216,230', 'lightcoral' => '240,128,128', 'lightcyan' => '224,255,255', 'lightgoldenrodyellow' => '250,250,210', 'lightgray' => '211,211,211', 'lightgrey' => '211,211,211', 'lightgreen' => '144,238,144', 'lightpink' => '255,182,193', 'lightsalmon' => '255,160,122', 'lightseagreen' => '32,178,170', 'lightskyblue' => '135,206,250', 'lightslategray' => '119,136,153', 'lightslategrey' => '119,136,153', 'lightsteelblue' => '176,196,222', 'lightyellow' => '255,255,224', 'lime' => '0,255,0', 'limegreen' => '50,205,50', 'linen' => '250,240,230', 'maroon' => '128,0,0', 'mediumaquamarine' => '102,205,170', 'mediumblue' => '0,0,205', 'mediumorchid' => '186,85,211', 'mediumpurple' => '147,112,219', 'mediumseagreen' => '60,179,113', 'mediumslateblue' => '123,104,238', 'mediumspringgreen' => '0,250,154', 'mediumturquoise' => '72,209,204', 'mediumvioletred' => '199,21,133', 'midnightblue' => '25,25,112', 'mintcream' => '245,255,250', 'mistyrose' => '255,228,225', 'moccasin' => '255,228,181', 'navajowhite' => '255,222,173', 'navy' => '0,0,128', 'oldlace' => '253,245,230', 'olive' => '128,128,0', 'olivedrab' => '107,142,35', 'orange' => '255,165,0', 'orangered' => '255,69,0', 'orchid' => '218,112,214', 'palegoldenrod' => '238,232,170', 'palegreen' => '152,251,152', 'paleturquoise' => '175,238,238', 'palevioletred' => '219,112,147', 'papayawhip' => '255,239,213', 'peachpuff' => '255,218,185', 'peru' => '205,133,63', 'pink' => '255,192,203', 'plum' => '221,160,221', 'powderblue' => '176,224,230', 'purple' => '128,0,128', 'red' => '255,0,0', 'rosybrown' => '188,143,143', 'royalblue' => '65,105,225', 'saddlebrown' => '139,69,19', 'salmon' => '250,128,114', 'sandybrown' => '244,164,96', 'seagreen' => '46,139,87', 'seashell' => '255,245,238', 'sienna' => '160,82,45', 'silver' => '192,192,192', 'skyblue' => '135,206,235', 'slateblue' => '106,90,205', 'slategray' => '112,128,144', 'slategrey' => '112,128,144', 'snow' => '255,250,250', 'springgreen' => '0,255,127', 'steelblue' => '70,130,180', 'tan' => '210,180,140', 'teal' => '0,128,128', 'thistle' => '216,191,216', 'tomato' => '255,99,71', 'turquoise' => '64,224,208', 'violet' => '238,130,238', 'wheat' => '245,222,179', 'white' => '255,255,255', 'whitesmoke' => '245,245,245', 'yellow' => '255,255,0', 'yellowgreen' => '154,205,50', 'rebeccapurple' => '102,51,153', 'transparent' => '0,0,0,0', ]; public static function colorNameToRGBa($colorName) { if (\is_string($colorName) && isset(static::$cssColors[$colorName])) { $rgba = explode(',', static::$cssColors[$colorName]); $rgba = array_map('intval', $rgba); return $rgba; } return null; } public static function RGBaToColorName($r, $g, $b, $a = 1) { static $reverseColorTable = null; if (! is_numeric($r) || ! is_numeric($g) || ! is_numeric($b) || ! is_numeric($a)) { return null; } if ($a < 1) { return null; } if (\is_null($reverseColorTable)) { $reverseColorTable = []; foreach (static::$cssColors as $name => $rgb_str) { $rgb_str = explode(',', $rgb_str); if ( \count($rgb_str) == 3 && ! isset($reverseColorTable[\intval($rgb_str[0])][\intval($rgb_str[1])][\intval($rgb_str[2])]) ) { $reverseColorTable[\intval($rgb_str[0])][\intval($rgb_str[1])][\intval($rgb_str[2])] = $name; } } } if (isset($reverseColorTable[\intval($r)][\intval($g)][\intval($b)])) { return $reverseColorTable[\intval($r)][\intval($g)][\intval($b)]; } return null; } } class CompilationResult { private $css; private $sourceMap; private $includedFiles; public function __construct($css, $sourceMap, array $includedFiles) { $this->css = $css; $this->sourceMap = $sourceMap; $this->includedFiles = $includedFiles; } public function getCss() { return $this->css; } public function getIncludedFiles() { return $this->includedFiles; } public function getSourceMap() { return $this->sourceMap; } } class Compiler { const LINE_COMMENTS = 1; const DEBUG_INFO = 2; const WITH_RULE = 1; const WITH_MEDIA = 2; const WITH_SUPPORTS = 4; const WITH_ALL = 7; const SOURCE_MAP_NONE = 0; const SOURCE_MAP_INLINE = 1; const SOURCE_MAP_FILE = 2; protected static $operatorNames = [ '+' => 'add', '-' => 'sub', '*' => 'mul', '/' => 'div', '%' => 'mod', '==' => 'eq', '!=' => 'neq', '<' => 'lt', '>' => 'gt', '<=' => 'lte', '>=' => 'gte', ]; protected static $namespaces = [ 'special' => '%', 'mixin' => '@', 'function' => '^', ]; public static $true = [Type::T_KEYWORD, 'true']; public static $false = [Type::T_KEYWORD, 'false']; public static $NaN = [Type::T_KEYWORD, 'NaN']; public static $Infinity = [Type::T_KEYWORD, 'Infinity']; public static $null = [Type::T_NULL]; public static $nullString = [Type::T_STRING, '', []]; public static $defaultValue = [Type::T_KEYWORD, '']; public static $selfSelector = [Type::T_SELF]; public static $emptyList = [Type::T_LIST, '', []]; public static $emptyMap = [Type::T_MAP, [], []]; public static $emptyString = [Type::T_STRING, '"', []]; public static $with = [Type::T_KEYWORD, 'with']; public static $without = [Type::T_KEYWORD, 'without']; private static $emptyArgumentList = [Type::T_LIST, '', [], []]; protected $importPaths = []; protected $importCache = []; protected $importedFiles = []; protected $userFunctions = []; protected $registeredVars = []; protected $registeredFeatures = [ 'extend-selector-pseudoclass' => false, 'at-error' => true, 'units-level-3' => true, 'global-variable-shadowing' => false, ]; protected $encoding = null; protected $lineNumberStyle = null; protected $sourceMap = self::SOURCE_MAP_NONE; protected $sourceMapOptions = []; private $charset = true; protected $formatter; private $configuredFormatter = Expanded::class; protected $rootEnv; protected $rootBlock; protected $env; protected $scope; protected $storeEnv; protected $charsetSeen; protected $sourceNames; protected $cache; protected $cacheCheckImportResolutions = false; protected $indentLevel; protected $extends; protected $extendsMap; protected $parsedFiles = []; protected $parser; protected $sourceIndex; protected $sourceLine; protected $sourceColumn; protected $shouldEvaluate; protected $ignoreErrors; protected $ignoreCallStackMessage = false; protected $callStack = []; private $resolvedImports = []; private $currentDirectory; private $rootDirectory; private $legacyCwdImportPath = true; private $logger; private $warnedChildFunctions = []; public function __construct($cacheOptions = null) { $this->sourceNames = []; if ($cacheOptions) { $this->cache = new Cache($cacheOptions); if (!empty($cacheOptions['checkImportResolutions'])) { $this->cacheCheckImportResolutions = true; } } $this->logger = new StreamLogger(fopen('php://stderr', 'w'), true); } public function getCompileOptions() { $options = [ 'importPaths' => $this->importPaths, 'registeredVars' => $this->registeredVars, 'registeredFeatures' => $this->registeredFeatures, 'encoding' => $this->encoding, 'sourceMap' => serialize($this->sourceMap), 'sourceMapOptions' => $this->sourceMapOptions, 'formatter' => $this->configuredFormatter, 'legacyImportPath' => $this->legacyCwdImportPath, ]; return $options; } public function setLogger(LoggerInterface $logger) { $this->logger = $logger; } public function setErrorOuput($handle) { @trigger_error('The method "setErrorOuput" is deprecated. Use "setLogger" instead.', E_USER_DEPRECATED); $this->logger = new StreamLogger($handle); } public function compile($code, $path = null) { @trigger_error(sprintf('The "%s" method is deprecated. Use "compileString" instead.', __METHOD__), E_USER_DEPRECATED); $result = $this->compileString($code, $path); $sourceMap = $result->getSourceMap(); if ($sourceMap !== null) { if ($this->sourceMap instanceof SourceMapGenerator) { $this->sourceMap->saveMap($sourceMap); } elseif ($this->sourceMap === self::SOURCE_MAP_FILE) { $sourceMapGenerator = new SourceMapGenerator($this->sourceMapOptions); $sourceMapGenerator->saveMap($sourceMap); } } return $result->getCss(); } public function compileString($source, $path = null) { if ($this->cache) { $cacheKey = ($path ? $path : '(stdin)') . ':' . md5($source); $compileOptions = $this->getCompileOptions(); $cachedResult = $this->cache->getCache('compile', $cacheKey, $compileOptions); if ($cachedResult instanceof CachedResult && $this->isFreshCachedResult($cachedResult)) { return $cachedResult->getResult(); } } $this->indentLevel = -1; $this->extends = []; $this->extendsMap = []; $this->sourceIndex = null; $this->sourceLine = null; $this->sourceColumn = null; $this->env = null; $this->scope = null; $this->storeEnv = null; $this->shouldEvaluate = null; $this->ignoreCallStackMessage = false; $this->parsedFiles = []; $this->importedFiles = []; $this->resolvedImports = []; if (!\is_null($path) && is_file($path)) { $path = realpath($path) ?: $path; $this->currentDirectory = dirname($path); $this->rootDirectory = $this->currentDirectory; } else { $this->currentDirectory = null; $this->rootDirectory = getcwd(); } try { $this->parser = $this->parserFactory($path); $tree = $this->parser->parse($source); $this->parser = null; $this->formatter = new $this->configuredFormatter(); $this->rootBlock = null; $this->rootEnv = $this->pushEnv($tree); $warnCallback = function ($message, $deprecation) { $this->logger->warn($message, $deprecation); }; $previousWarnCallback = Warn::setCallback($warnCallback); try { $this->injectVariables($this->registeredVars); $this->compileRoot($tree); $this->popEnv(); } finally { Warn::setCallback($previousWarnCallback); } $sourceMapGenerator = null; if ($this->sourceMap) { if (\is_object($this->sourceMap) && $this->sourceMap instanceof SourceMapGenerator) { $sourceMapGenerator = $this->sourceMap; $this->sourceMap = self::SOURCE_MAP_FILE; } elseif ($this->sourceMap !== self::SOURCE_MAP_NONE) { $sourceMapGenerator = new SourceMapGenerator($this->sourceMapOptions); } } assert($this->scope !== null); $out = $this->formatter->format($this->scope, $sourceMapGenerator); $prefix = ''; if ($this->charset && strlen($out) !== Util::mbStrlen($out)) { $prefix = '@charset "UTF-8";' . "\n"; $out = $prefix . $out; } $sourceMap = null; if (! empty($out) && $this->sourceMap && $this->sourceMap !== self::SOURCE_MAP_NONE) { assert($sourceMapGenerator !== null); $sourceMap = $sourceMapGenerator->generateJson($prefix); $sourceMapUrl = null; switch ($this->sourceMap) { case self::SOURCE_MAP_INLINE: $sourceMapUrl = sprintf('data:application/json,%s', Util::encodeURIComponent($sourceMap)); break; case self::SOURCE_MAP_FILE: if (isset($this->sourceMapOptions['sourceMapURL'])) { $sourceMapUrl = $this->sourceMapOptions['sourceMapURL']; } break; } if ($sourceMapUrl !== null) { $out .= sprintf('/*# sourceMappingURL=%s */', $sourceMapUrl); } } } catch (SassScriptException $e) { throw new CompilerException($this->addLocationToMessage($e->getMessage()), 0, $e); } $includedFiles = []; foreach ($this->resolvedImports as $resolvedImport) { $includedFiles[$resolvedImport['filePath']] = $resolvedImport['filePath']; } $result = new CompilationResult($out, $sourceMap, array_values($includedFiles)); if ($this->cache && isset($cacheKey) && isset($compileOptions)) { $this->cache->setCache('compile', $cacheKey, new CachedResult($result, $this->parsedFiles, $this->resolvedImports), $compileOptions); } $this->resolvedImports = []; $this->importedFiles = []; return $result; } private function isFreshCachedResult(CachedResult $result) { foreach ($result->getParsedFiles() as $file => $mtime) { if (! is_file($file) || filemtime($file) !== $mtime) { return false; } } if ($this->cacheCheckImportResolutions) { $resolvedImports = []; foreach ($result->getResolvedImports() as $import) { $currentDir = $import['currentDir']; $path = $import['path']; if (empty($resolvedImports[$currentDir][$path])) { $resolvedImports[$currentDir][$path] = $this->findImport($path, $currentDir); } if ($resolvedImports[$currentDir][$path] !== $import['filePath']) { return false; } } } return true; } protected function parserFactory($path) { $cssOnly = false; if ($path !== null && substr($path, -4) === '.css') { $cssOnly = true; } $parser = new Parser($path, \count($this->sourceNames), $this->encoding, $this->cache, $cssOnly, $this->logger); $this->sourceNames[] = $path; $this->addParsedFile($path); return $parser; } protected function isSelfExtend($target, $origin) { foreach ($origin as $sel) { if (\in_array($target, $sel)) { return true; } } return false; } protected function pushExtends($target, $origin, $block) { $i = \count($this->extends); $this->extends[] = [$target, $origin, $block]; foreach ($target as $part) { if (isset($this->extendsMap[$part])) { $this->extendsMap[$part][] = $i; } else { $this->extendsMap[$part] = [$i]; } } } protected function makeOutputBlock($type, $selectors = null) { $out = new OutputBlock(); $out->type = $type; $out->lines = []; $out->children = []; $out->parent = $this->scope; $out->selectors = $selectors; $out->depth = $this->env->depth; if ($this->env->block instanceof Block) { $out->sourceName = $this->env->block->sourceName; $out->sourceLine = $this->env->block->sourceLine; $out->sourceColumn = $this->env->block->sourceColumn; } else { $out->sourceName = isset($this->sourceNames[$this->sourceIndex]) ? $this->sourceNames[$this->sourceIndex] : '(stdin)'; $out->sourceLine = $this->sourceLine; $out->sourceColumn = $this->sourceColumn; } return $out; } protected function compileRoot(Block $rootBlock) { $this->rootBlock = $this->scope = $this->makeOutputBlock(Type::T_ROOT); $this->compileChildrenNoReturn($rootBlock->children, $this->scope); assert($this->scope !== null); $this->flattenSelectors($this->scope); $this->missingSelectors(); } protected function missingSelectors() { foreach ($this->extends as $extend) { if (isset($extend[3])) { continue; } list($target, $origin, $block) = $extend; if ($block[2]) { continue; } $target = implode(' ', $target); $origin = $this->collapseSelectors($origin); $this->sourceLine = $block[Parser::SOURCE_LINE]; throw $this->error("\"$origin\" failed to @extend \"$target\". The selector \"$target\" was not found."); } } protected function flattenSelectors(OutputBlock $block, $parentKey = null) { if ($block->selectors) { $selectors = []; foreach ($block->selectors as $s) { $selectors[] = $s; if (! \is_array($s)) { continue; } if (! empty($this->extendsMap)) { $this->matchExtends($s, $selectors); array_walk($selectors, function (&$value) { $value = serialize($value); }); $selectors = array_unique($selectors); array_walk($selectors, function (&$value) { $value = unserialize($value); }); } } $block->selectors = []; $placeholderSelector = false; foreach ($selectors as $selector) { if ($this->hasSelectorPlaceholder($selector)) { $placeholderSelector = true; continue; } $block->selectors[] = $this->compileSelector($selector); } if ($placeholderSelector && 0 === \count($block->selectors) && null !== $parentKey) { assert($block->parent !== null); unset($block->parent->children[$parentKey]); return; } } foreach ($block->children as $key => $child) { $this->flattenSelectors($child, $key); } } protected function glueFunctionSelectors($parts) { $new = []; foreach ($parts as $part) { if (\is_array($part)) { $part = $this->glueFunctionSelectors($part); $new[] = $part; } else { if ( \count($new) && \is_string($new[\count($new) - 1]) && \strlen($part) && substr($part, -1) === ')' && strpos($part, '(') === false ) { while (\count($new) > 1 && substr($new[\count($new) - 1], -1) !== '(') { $part = array_pop($new) . $part; } $new[\count($new) - 1] .= $part; } else { $new[] = $part; } } } return $new; } protected function matchExtends($selector, &$out, $from = 0, $initial = true) { static $partsPile = []; $selector = $this->glueFunctionSelectors($selector); if (\count($selector) == 1 && \in_array(reset($selector), $partsPile)) { return; } $outRecurs = []; foreach ($selector as $i => $part) { if ($i < $from) { continue; } if (\count($part) > 1) { foreach ($partsPile as $previousPart) { if (! \count(array_diff($previousPart, $part))) { continue 2; } } } $partsPile[] = $part; if ($this->matchExtendsSingle($part, $origin, $initial)) { $after = \array_slice($selector, $i + 1); $before = \array_slice($selector, 0, $i); list($before, $nonBreakableBefore) = $this->extractRelationshipFromFragment($before); foreach ($origin as $new) { $k = 0; if (\count($new) > 1) { while ($k < $i && isset($new[$k]) && $selector[$k] === $new[$k]) { $k++; } } if (\count($nonBreakableBefore) && $k === \count($new)) { $k--; } $replacement = []; $tempReplacement = $k > 0 ? \array_slice($new, $k) : $new; for ($l = \count($tempReplacement) - 1; $l >= 0; $l--) { $slice = []; foreach ($tempReplacement[$l] as $chunk) { if (! \in_array($chunk, $slice)) { $slice[] = $chunk; } } array_unshift($replacement, $slice); if (! $this->isImmediateRelationshipCombinator(end($slice))) { break; } } $afterBefore = $l != 0 ? \array_slice($tempReplacement, 0, $l) : []; $mergedBefore = $this->mergeDirectRelationships($afterBefore, $nonBreakableBefore); $result = array_merge( $before, $mergedBefore, $replacement, $after ); if ($result === $selector) { continue; } $this->pushOrMergeExtentedSelector($out, $result); $startRecurseFrom = \count($before) + min(\count($nonBreakableBefore), \count($mergedBefore)); if (\count($origin) > 1) { $this->matchExtends($result, $out, $startRecurseFrom, false); } else { $this->matchExtends($result, $outRecurs, $startRecurseFrom, false); } if (! empty($before) && \count($new) > 1) { $preSharedParts = $k > 0 ? \array_slice($before, 0, $k) : []; $postSharedParts = $k > 0 ? \array_slice($before, $k) : $before; list($betweenSharedParts, $nonBreakabl2) = $this->extractRelationshipFromFragment($afterBefore); $result2 = array_merge( $preSharedParts, $betweenSharedParts, $postSharedParts, $nonBreakabl2, $nonBreakableBefore, $replacement, $after ); $this->pushOrMergeExtentedSelector($out, $result2); } } } array_pop($partsPile); } while (\count($outRecurs)) { $result = array_shift($outRecurs); $this->pushOrMergeExtentedSelector($out, $result); } } protected function isPseudoSelector($part, &$matches) { if ( strpos($part, ':') === 0 && preg_match(",^::?([\w-]+)\((.+)\)$,", $part, $matches) ) { return true; } return false; } protected function pushOrMergeExtentedSelector(&$out, $extended) { if (\count($out) && \count($extended) === 1 && \count(reset($extended)) === 1) { $single = reset($extended); $part = reset($single); if ( $this->isPseudoSelector($part, $matchesExtended) && \in_array($matchesExtended[1], [ 'slotted' ]) ) { $prev = end($out); $prev = $this->glueFunctionSelectors($prev); if (\count($prev) === 1 && \count(reset($prev)) === 1) { $single = reset($prev); $part = reset($single); if ( $this->isPseudoSelector($part, $matchesPrev) && $matchesPrev[1] === $matchesExtended[1] ) { $extended = explode($matchesExtended[1] . '(', $matchesExtended[0], 2); $extended[1] = $matchesPrev[2] . ', ' . $extended[1]; $extended = implode($matchesExtended[1] . '(', $extended); $extended = [ [ $extended ]]; array_pop($out); } } } } $out[] = $extended; } protected function matchExtendsSingle($rawSingle, &$outOrigin, $initial = true) { $counts = []; $single = []; if (\in_array($rawSingle, [['>'],['+'],['~']])) { return false; } foreach ($rawSingle as $part) { if (! \is_string($part)) { return false; } if (! preg_match('/^[\[.:#%]/', $part) && \count($single)) { $single[\count($single) - 1] .= $part; } else { $single[] = $part; } } $extendingDecoratedTag = false; if (\count($single) > 1) { $matches = null; $extendingDecoratedTag = preg_match('/^[a-z0-9]+$/i', $single[0], $matches) ? $matches[0] : false; } $outOrigin = []; $found = false; foreach ($single as $k => $part) { if (isset($this->extendsMap[$part])) { foreach ($this->extendsMap[$part] as $idx) { $counts[$idx] = isset($counts[$idx]) ? $counts[$idx] + 1 : 1; } } if ( $initial && $this->isPseudoSelector($part, $matches) && ! \in_array($matches[1], [ 'not' ]) ) { $buffer = $matches[2]; $parser = $this->parserFactory(__METHOD__); if ($parser->parseSelector($buffer, $subSelectors, false)) { foreach ($subSelectors as $ksub => $subSelector) { $subExtended = []; $this->matchExtends($subSelector, $subExtended, 0, false); if ($subExtended) { $subSelectorsExtended = $subSelectors; $subSelectorsExtended[$ksub] = $subExtended; foreach ($subSelectorsExtended as $ksse => $sse) { $subSelectorsExtended[$ksse] = $this->collapseSelectors($sse); } $subSelectorsExtended = implode(', ', $subSelectorsExtended); $singleExtended = $single; $singleExtended[$k] = str_replace('(' . $buffer . ')', "($subSelectorsExtended)", $part); $outOrigin[] = [ $singleExtended ]; $found = true; } } } } } foreach ($counts as $idx => $count) { list($target, $origin, ) = $this->extends[$idx]; $origin = $this->glueFunctionSelectors($origin); if ($count !== \count($target)) { continue; } $this->extends[$idx][3] = true; $rem = array_diff($single, $target); foreach ($origin as $j => $new) { if ($this->isSelfExtend($single, $origin) && ! $initial) { return false; } $replacement = end($new); if ( $extendingDecoratedTag && $replacement[0] != $extendingDecoratedTag && preg_match('/^[a-z0-9]+$/i', $replacement[0]) ) { unset($origin[$j]); continue; } $combined = $this->combineSelectorSingle($replacement, $rem); if (\count(array_diff($combined, $origin[$j][\count($origin[$j]) - 1]))) { $origin[$j][\count($origin[$j]) - 1] = $combined; } } $outOrigin = array_merge($outOrigin, $origin); $found = true; } return $found; } protected function extractRelationshipFromFragment(array $fragment) { $parents = []; $children = []; $j = $i = \count($fragment); for (;;) { $children = $j != $i ? \array_slice($fragment, $j, $i - $j) : []; $parents = \array_slice($fragment, 0, $j); $slice = end($parents); if (empty($slice) || ! $this->isImmediateRelationshipCombinator($slice[0])) { break; } $j -= 2; } return [$parents, $children]; } protected function combineSelectorSingle($base, $other) { $tag = []; $out = []; $wasTag = false; $pseudo = []; while (\count($other) && strpos(end($other), ':') === 0) { array_unshift($pseudo, array_pop($other)); } foreach ([array_reverse($base), array_reverse($other)] as $single) { $rang = count($single); foreach ($single as $part) { if (preg_match('/^[\[:]/', $part)) { $out[] = $part; $wasTag = false; } elseif (preg_match('/^[\.#]/', $part)) { array_unshift($out, $part); $wasTag = false; } elseif (preg_match('/^[^_-]/', $part) && $rang === 1) { $tag[] = $part; $wasTag = true; } elseif ($wasTag) { $tag[\count($tag) - 1] .= $part; } else { array_unshift($out, $part); } $rang--; } } if (\count($tag)) { array_unshift($out, $tag[0]); } while (\count($pseudo)) { $out[] = array_shift($pseudo); } return $out; } protected function compileMedia(Block $media) { assert($media instanceof MediaBlock); $this->pushEnv($media); $mediaQueries = $this->compileMediaQuery($this->multiplyMedia($this->env)); if (! empty($mediaQueries)) { assert($this->scope !== null); $previousScope = $this->scope; $parentScope = $this->mediaParent($this->scope); foreach ($mediaQueries as $mediaQuery) { $this->scope = $this->makeOutputBlock(Type::T_MEDIA, [$mediaQuery]); $parentScope->children[] = $this->scope; $parentScope = $this->scope; } $needsWrap = false; foreach ($media->children as $child) { $type = $child[0]; if ( $type !== Type::T_BLOCK && $type !== Type::T_MEDIA && $type !== Type::T_DIRECTIVE && $type !== Type::T_IMPORT ) { $needsWrap = true; break; } } if ($needsWrap) { $wrapped = new Block(); $wrapped->sourceName = $media->sourceName; $wrapped->sourceIndex = $media->sourceIndex; $wrapped->sourceLine = $media->sourceLine; $wrapped->sourceColumn = $media->sourceColumn; $wrapped->selectors = []; $wrapped->comments = []; $wrapped->parent = $media; $wrapped->children = $media->children; $media->children = [[Type::T_BLOCK, $wrapped]]; } $this->compileChildrenNoReturn($media->children, $this->scope); $this->scope = $previousScope; } $this->popEnv(); } protected function mediaParent(OutputBlock $scope) { while (! empty($scope->parent)) { if (! empty($scope->type) && $scope->type !== Type::T_MEDIA) { break; } $scope = $scope->parent; } return $scope; } protected function compileDirective($directive, OutputBlock $out) { if (\is_array($directive)) { $directiveName = $this->compileDirectiveName($directive[0]); $s = '@' . $directiveName; if (! empty($directive[1])) { $s .= ' ' . $this->compileValue($directive[1]); } $appendNewLine = (! empty($directive[2]) || strpos($s, "\n")) ? "\n" : ""; if (\is_array($directive[0]) && empty($directive[1])) { $appendNewLine = "\n"; } if (empty($directive[3])) { $this->appendRootDirective($s . ';' . $appendNewLine, $out, [Type::T_COMMENT, Type::T_DIRECTIVE]); } else { $this->appendOutputLine($out, Type::T_DIRECTIVE, $s . ';'); } } else { $directive->name = $this->compileDirectiveName($directive->name); $s = '@' . $directive->name; if (! empty($directive->value)) { $s .= ' ' . $this->compileValue($directive->value); } if ($directive->name === 'keyframes' || substr($directive->name, -10) === '-keyframes') { $this->compileKeyframeBlock($directive, [$s]); } else { $this->compileNestedBlock($directive, [$s]); } } } protected function compileDirectiveName($directiveName) { if (is_string($directiveName)) { return $directiveName; } return $this->compileValue($directiveName); } protected function compileAtRoot(Block $block) { assert($block instanceof AtRootBlock); $env = $this->pushEnv($block); $envs = $this->compactEnv($env); list($with, $without) = $this->compileWith(isset($block->with) ? $block->with : null); if ($block->selector) { $wrapped = new Block(); $wrapped->sourceName = $block->sourceName; $wrapped->sourceIndex = $block->sourceIndex; $wrapped->sourceLine = $block->sourceLine; $wrapped->sourceColumn = $block->sourceColumn; $wrapped->selectors = $block->selector; $wrapped->comments = []; $wrapped->parent = $block; $wrapped->children = $block->children; $wrapped->selfParent = $block->selfParent; $block->children = [[Type::T_BLOCK, $wrapped]]; $block->selector = null; } $selfParent = $block->selfParent; assert($selfParent !== null, 'at-root blocks must have a selfParent set.'); if ( ! $selfParent->selectors && isset($block->parent) && isset($block->parent->selectors) && $block->parent->selectors ) { $selfParent = $block->parent; } $this->env = $this->filterWithWithout($envs, $with, $without); assert($this->scope !== null); $saveScope = $this->scope; $this->scope = $this->filterScopeWithWithout($saveScope, $with, $without); $this->compileChildrenNoReturn($block->children, $this->scope, $selfParent); assert($this->scope !== null); $this->completeScope($this->scope, $saveScope); $this->scope = $saveScope; $this->env = $this->extractEnv($envs); $this->popEnv(); } protected function filterScopeWithWithout($scope, $with, $without) { $filteredScopes = []; $childStash = []; if ($scope->type === Type::T_ROOT) { return $scope; } assert($this->rootBlock !== null); while ($scope->parent && $scope->parent->type !== Type::T_ROOT) { array_unshift($childStash, $scope); $scope = $scope->parent; } for (;;) { if (! $scope) { break; } if ($this->isWith($scope, $with, $without)) { $s = clone $scope; $s->children = []; $s->lines = []; $s->parent = null; if ($s->type !== Type::T_MEDIA && $s->type !== Type::T_DIRECTIVE) { $s->selectors = []; } $filteredScopes[] = $s; } if (\count($childStash)) { $scope = array_shift($childStash); } elseif ($scope->children) { $scope = end($scope->children); } else { $scope = null; } } if (! \count($filteredScopes)) { return $this->rootBlock; } $newScope = array_shift($filteredScopes); $newScope->parent = $this->rootBlock; $this->rootBlock->children[] = $newScope; $p = &$newScope; while (\count($filteredScopes)) { $s = array_shift($filteredScopes); $s->parent = $p; $p->children[] = $s; $newScope = &$p->children[0]; $p = &$p->children[0]; } return $newScope; } protected function completeScope($scope, $previousScope) { if (! $scope->type && ! $scope->selectors && \count($scope->lines)) { $scope->selectors = $this->findScopeSelectors($previousScope, $scope->depth); } if ($scope->children) { foreach ($scope->children as $k => $c) { $scope->children[$k] = $this->completeScope($c, $previousScope); } } return $scope; } protected function findScopeSelectors($scope, $depth) { if ($scope->depth === $depth && $scope->selectors) { return $scope->selectors; } if ($scope->children) { foreach (array_reverse($scope->children) as $c) { if ($s = $this->findScopeSelectors($c, $depth)) { return $s; } } } return []; } protected function compileWith($withCondition) { $with = []; $without = ['rule' => true]; if ($withCondition) { if ($withCondition[0] === Type::T_INTERPOLATE) { $w = $this->compileValue($withCondition); $buffer = "($w)"; $parser = $this->parserFactory(__METHOD__); if ($parser->parseValue($buffer, $reParsedWith)) { $withCondition = $reParsedWith; } } $withConfig = $this->mapGet($withCondition, static::$with); if ($withConfig !== null) { $without = []; $list = $this->coerceList($withConfig); foreach ($list[2] as $item) { $keyword = $this->compileStringContent($this->coerceString($item)); $with[$keyword] = true; } } $withoutConfig = $this->mapGet($withCondition, static::$without); if ($withoutConfig !== null) { $without = []; $list = $this->coerceList($withoutConfig); foreach ($list[2] as $item) { $keyword = $this->compileStringContent($this->coerceString($item)); $without[$keyword] = true; } } } return [$with, $without]; } protected function filterWithWithout($envs, $with, $without) { $filtered = []; foreach ($envs as $e) { if ($e->block && ! $this->isWith($e->block, $with, $without)) { $ec = clone $e; $ec->block = null; $ec->selectors = []; $filtered[] = $ec; } else { $filtered[] = $e; } } return $this->extractEnv($filtered); } protected function isWith($block, $with, $without) { if (isset($block->type)) { if ($block->type === Type::T_MEDIA) { return $this->testWithWithout('media', $with, $without); } if ($block->type === Type::T_DIRECTIVE) { assert($block instanceof DirectiveBlock || $block instanceof OutputBlock); if (isset($block->name)) { return $this->testWithWithout($this->compileDirectiveName($block->name), $with, $without); } elseif (isset($block->selectors) && preg_match(',@(\w+),ims', json_encode($block->selectors), $m)) { return $this->testWithWithout($m[1], $with, $without); } else { return $this->testWithWithout('???', $with, $without); } } } elseif (isset($block->selectors)) { if (\count($block->selectors)) { $s = reset($block->selectors); while (\is_array($s)) { $s = reset($s); } if (\is_object($s) && $s instanceof Number) { return $this->testWithWithout('keyframes', $with, $without); } } return $this->testWithWithout('rule', $with, $without); } return true; } protected function testWithWithout($what, $with, $without) { if (\count($without)) { return (isset($without[$what]) || isset($without['all'])) ? false : true; } return (isset($with[$what]) || isset($with['all'])) ? true : false; } protected function compileKeyframeBlock(Block $block, $selectors) { $env = $this->pushEnv($block); $envs = $this->compactEnv($env); $this->env = $this->extractEnv(array_filter($envs, function (Environment $e) { return ! isset($e->block->selectors); })); $this->scope = $this->makeOutputBlock($block->type, $selectors); $this->scope->depth = 1; assert($this->scope->parent !== null); $this->scope->parent->children[] = $this->scope; $this->compileChildrenNoReturn($block->children, $this->scope); assert($this->scope !== null); $this->scope = $this->scope->parent; $this->env = $this->extractEnv($envs); $this->popEnv(); } protected function compileNestedPropertiesBlock(Block $block, OutputBlock $out) { assert($block instanceof NestedPropertyBlock); $prefix = $this->compileValue($block->prefix) . '-'; $nested = $this->makeOutputBlock($block->type); $nested->parent = $out; if ($block->hasValue) { $nested->depth = $out->depth + 1; } $out->children[] = $nested; foreach ($block->children as $child) { switch ($child[0]) { case Type::T_ASSIGN: array_unshift($child[1][2], $prefix); break; case Type::T_NESTED_PROPERTY: assert($child[1] instanceof NestedPropertyBlock); array_unshift($child[1]->prefix[2], $prefix); break; } $this->compileChild($child, $nested); } } protected function compileNestedBlock(Block $block, $selectors) { $this->pushEnv($block); $this->scope = $this->makeOutputBlock($block->type, $selectors); assert($this->scope->parent !== null); $this->scope->parent->children[] = $this->scope; if (!$block instanceof DirectiveBlock || $this->compileDirectiveName($block->name) !== 'font-face') { $needWrapping = false; foreach ($block->children as $child) { if ($child[0] === Type::T_ASSIGN) { $needWrapping = true; break; } } if ($needWrapping) { $wrapped = new Block(); $wrapped->sourceName = $block->sourceName; $wrapped->sourceIndex = $block->sourceIndex; $wrapped->sourceLine = $block->sourceLine; $wrapped->sourceColumn = $block->sourceColumn; $wrapped->selectors = []; $wrapped->comments = []; $wrapped->parent = $block; $wrapped->children = $block->children; $wrapped->selfParent = $block->selfParent; $block->children = [[Type::T_BLOCK, $wrapped]]; } } $this->compileChildrenNoReturn($block->children, $this->scope); assert($this->scope !== null); $this->scope = $this->scope->parent; $this->popEnv(); } protected function compileBlock(Block $block) { $env = $this->pushEnv($block); assert($block->selectors !== null); $env->selectors = $this->evalSelectors($block->selectors); $out = $this->makeOutputBlock(null); assert($this->scope !== null); $this->scope->children[] = $out; if (\count($block->children)) { $out->selectors = $this->multiplySelectors($env, $block->selfParent); $selfParentSelectors = null; if (isset($block->selfParent->selectors)) { $selfParentSelectors = $block->selfParent->selectors; $block->selfParent->selectors = $out->selectors; } $this->compileChildrenNoReturn($block->children, $out, $block->selfParent); if ($selfParentSelectors) { assert($block->selfParent !== null); $block->selfParent->selectors = $selfParentSelectors; } } $this->popEnv(); } protected function compileCommentValue($value, $pushEnv = false) { $c = $value[1]; if (isset($value[2])) { if ($pushEnv) { $this->pushEnv(); } try { $c = $this->compileValue($value[2]); } catch (SassScriptException $e) { $this->logger->warn('Ignoring interpolation errors in multiline comments is deprecated and will be removed in ScssPhp 2.0. ' . $this->addLocationToMessage($e->getMessage()), true); } catch (SassException $e) { $this->logger->warn('Ignoring interpolation errors in multiline comments is deprecated and will be removed in ScssPhp 2.0. ' . $e->getMessage(), true); } if ($pushEnv) { $this->popEnv(); } } return $c; } protected function compileComment($block) { $out = $this->makeOutputBlock(Type::T_COMMENT); $out->lines[] = $this->compileCommentValue($block, true); assert($this->scope !== null); $this->scope->children[] = $out; } protected function evalSelectors($selectors) { $this->shouldEvaluate = false; $evaluatedSelectors = []; foreach ($selectors as $selector) { $evaluatedSelectors[] = $this->evalSelector($selector); } $selectors = $evaluatedSelectors; if ($this->shouldEvaluate) { $selectors = $this->replaceSelfSelector($selectors, '&'); $buffer = $this->collapseSelectors($selectors); $parser = $this->parserFactory(__METHOD__); try { $isValid = $parser->parseSelector($buffer, $newSelectors, true); } catch (ParserException $e) { throw $this->error($e->getMessage()); } if ($isValid) { $selectors = array_map([$this, 'evalSelector'], $newSelectors); } } return $selectors; } protected function evalSelector($selector) { return array_map([$this, 'evalSelectorPart'], $selector); } protected function evalSelectorPart($part) { foreach ($part as &$p) { if (\is_array($p) && ($p[0] === Type::T_INTERPOLATE || $p[0] === Type::T_STRING)) { $p = $this->compileValue($p); if (preg_match(',[^\w-],', $p)) { $this->shouldEvaluate = true; } } elseif ( \is_string($p) && \strlen($p) >= 2 && ($p[0] === '"' || $p[0] === "'") && substr($p, -1) === $p[0] ) { $p = substr($p, 1, -1); } } return $this->flattenSelectorSingle($part); } protected function collapseSelectors($selectors) { $parts = []; foreach ($selectors as $selector) { $output = []; foreach ($selector as $node) { $compound = ''; array_walk_recursive( $node, function ($value, $key) use (&$compound) { $compound .= $value; } ); $output[] = $compound; } $parts[] = implode(' ', $output); } return implode(', ', $parts); } private function collapseSelectorsAsList($selectors) { $parts = []; foreach ($selectors as $selector) { $output = []; $glueNext = false; foreach ($selector as $node) { $compound = ''; array_walk_recursive( $node, function ($value, $key) use (&$compound) { $compound .= $value; } ); if ($this->isImmediateRelationshipCombinator($compound)) { if (\count($output)) { $output[\count($output) - 1] .= ' ' . $compound; } else { $output[] = $compound; } $glueNext = true; } elseif ($glueNext) { $output[\count($output) - 1] .= ' ' . $compound; $glueNext = false; } else { $output[] = $compound; } } foreach ($output as &$o) { $o = [Type::T_STRING, '', [$o]]; } $parts[] = [Type::T_LIST, ' ', $output]; } return [Type::T_LIST, ',', $parts]; } protected function replaceSelfSelector($selectors, $replace = null) { foreach ($selectors as &$part) { if (\is_array($part)) { if ($part === [Type::T_SELF]) { if (\is_null($replace)) { $replace = $this->reduce([Type::T_SELF]); $replace = $this->compileValue($replace); } $part = $replace; } else { $part = $this->replaceSelfSelector($part, $replace); } } } return $selectors; } protected function flattenSelectorSingle($single) { $joined = []; foreach ($single as $part) { if ( empty($joined) || ! \is_string($part) || preg_match('/[\[.:#%]/', $part) ) { $joined[] = $part; continue; } if (\is_array(end($joined))) { $joined[] = $part; } else { $joined[\count($joined) - 1] .= $part; } } return $joined; } protected function compileSelector($selector) { if (! \is_array($selector)) { return $selector; } return implode( ' ', array_map( [$this, 'compileSelectorPart'], $selector ) ); } protected function compileSelectorPart($piece) { foreach ($piece as &$p) { if (! \is_array($p)) { continue; } switch ($p[0]) { case Type::T_SELF: $p = '&'; break; default: $p = $this->compileValue($p); break; } } return implode($piece); } protected function hasSelectorPlaceholder($selector) { if (! \is_array($selector)) { return false; } foreach ($selector as $parts) { foreach ($parts as $part) { if (\strlen($part) && '%' === $part[0]) { return true; } } } return false; } protected function pushCallStack($name = '') { $this->callStack[] = [ 'n' => $name, Parser::SOURCE_INDEX => $this->sourceIndex, Parser::SOURCE_LINE => $this->sourceLine, Parser::SOURCE_COLUMN => $this->sourceColumn ]; if (\count($this->callStack) > 25000) { $msg = $this->callStackMessage(true, 100); $msg = 'Infinite calling loop'; throw $this->error($msg); } } protected function popCallStack() { array_pop($this->callStack); } protected function compileChildren($stms, OutputBlock $out, $traceName = '') { $this->pushCallStack($traceName); foreach ($stms as $stm) { $ret = $this->compileChild($stm, $out); if (isset($ret)) { $this->popCallStack(); return $ret; } } $this->popCallStack(); return null; } protected function compileChildrenNoReturn($stms, OutputBlock $out, $selfParent = null, $traceName = '') { $this->pushCallStack($traceName); foreach ($stms as $stm) { if ($selfParent && isset($stm[1]) && \is_object($stm[1]) && $stm[1] instanceof Block) { $oldSelfParent = $stm[1]->selfParent; $stm[1]->selfParent = $selfParent; $ret = $this->compileChild($stm, $out); $stm[1]->selfParent = $oldSelfParent; } elseif ($selfParent && \in_array($stm[0], [Type::T_INCLUDE, Type::T_EXTEND])) { $stm['selfParent'] = $selfParent; $ret = $this->compileChild($stm, $out); } else { $ret = $this->compileChild($stm, $out); } if (isset($ret)) { throw $this->error('@return may only be used within a function'); } } $this->popCallStack(); } protected function evaluateMediaQuery($queryList) { static $parser = null; $outQueryList = []; foreach ($queryList as $kql => $query) { $shouldReparse = false; foreach ($query as $kq => $q) { for ($i = 1; $i < \count($q); $i++) { $value = $this->compileValue($q[$i]); if ( $q[0] == Type::T_MEDIA_TYPE && (strpos($value, '(') !== false || strpos($value, ')') !== false || strpos($value, ':') !== false || strpos($value, ',') !== false) ) { $shouldReparse = true; } $queryList[$kql][$kq][$i] = [Type::T_KEYWORD, $value]; } } if ($shouldReparse) { if (\is_null($parser)) { $parser = $this->parserFactory(__METHOD__); } $queryString = $this->compileMediaQuery([$queryList[$kql]]); $queryString = reset($queryString); if ($queryString !== false && strpos($queryString, '@media ') === 0) { $queryString = substr($queryString, 7); $queries = []; if ($parser->parseMediaQueryList($queryString, $queries)) { $queries = $this->evaluateMediaQuery($queries[2]); while (\count($queries)) { $outQueryList[] = array_shift($queries); } continue; } } } $outQueryList[] = $queryList[$kql]; } return $outQueryList; } protected function compileMediaQuery($queryList) { $start = '@media '; $default = trim($start); $out = []; $current = ''; foreach ($queryList as $query) { $type = null; $parts = []; $mediaTypeOnly = true; foreach ($query as $q) { if ($q[0] !== Type::T_MEDIA_TYPE) { $mediaTypeOnly = false; break; } } foreach ($query as $q) { switch ($q[0]) { case Type::T_MEDIA_TYPE: $newType = array_map([$this, 'compileValue'], \array_slice($q, 1)); if (! $mediaTypeOnly) { if (\in_array(Type::T_NOT, $newType) || ($type && \in_array(Type::T_NOT, $type) )) { if ($type) { array_unshift($parts, implode(' ', array_filter($type))); } if (! empty($parts)) { if (\strlen($current)) { $current .= $this->formatter->tagSeparator; } $current .= implode(' and ', $parts); } if ($current) { $out[] = $start . $current; } $current = ''; $type = null; $parts = []; } } if ($newType === ['all'] && $default) { $default = $start . 'all'; } if ($newType !== ['all']) { if ($type) { $type = $this->mergeMediaTypes($type, $newType); if (empty($type)) { $parts = []; $default = ''; continue 3; } } else { $type = $newType; } } break; case Type::T_MEDIA_EXPRESSION: if (isset($q[2])) { $parts[] = '(' . $this->compileValue($q[1]) . $this->formatter->assignSeparator . $this->compileValue($q[2]) . ')'; } else { $parts[] = '(' . $this->compileValue($q[1]) . ')'; } break; case Type::T_MEDIA_VALUE: $parts[] = $this->compileValue($q[1]); break; } } if ($type) { array_unshift($parts, implode(' ', array_filter($type))); } if (! empty($parts)) { if (\strlen($current)) { $current .= $this->formatter->tagSeparator; } $current .= implode(' and ', $parts); } } if ($current) { $out[] = $start . $current; } if (! $out && $default) { $out[] = $default; } return $out; } protected function mergeDirectRelationships($selectors1, $selectors2) { if (empty($selectors1) || empty($selectors2)) { return array_merge($selectors1, $selectors2); } $part1 = end($selectors1); $part2 = end($selectors2); if (! $this->isImmediateRelationshipCombinator($part1[0]) && $part1 !== $part2) { return array_merge($selectors1, $selectors2); } $merged = []; do { $part1 = array_pop($selectors1); $part2 = array_pop($selectors2); if (! $this->isImmediateRelationshipCombinator($part1[0]) && $part1 !== $part2) { if ($this->isImmediateRelationshipCombinator(reset($merged)[0])) { array_unshift($merged, [$part1[0] . $part2[0]]); $merged = array_merge($selectors1, $selectors2, $merged); } else { $merged = array_merge($selectors1, [$part1], $selectors2, [$part2], $merged); } break; } array_unshift($merged, $part1); } while (! empty($selectors1) && ! empty($selectors2)); return $merged; } protected function mergeMediaTypes($type1, $type2) { if (empty($type1)) { return $type2; } if (empty($type2)) { return $type1; } if (\count($type1) > 1) { $m1 = strtolower($type1[0]); $t1 = strtolower($type1[1]); } else { $m1 = ''; $t1 = strtolower($type1[0]); } if (\count($type2) > 1) { $m2 = strtolower($type2[0]); $t2 = strtolower($type2[1]); } else { $m2 = ''; $t2 = strtolower($type2[0]); } if (($m1 === Type::T_NOT) ^ ($m2 === Type::T_NOT)) { if ($t1 === $t2) { return null; } return [ $m1 === Type::T_NOT ? $m2 : $m1, $m1 === Type::T_NOT ? $t2 : $t1, ]; } if ($m1 === Type::T_NOT && $m2 === Type::T_NOT) { if ($t1 !== $t2) { return null; } return [Type::T_NOT, $t1]; } if ($t1 !== $t2) { return null; } return [empty($m1) ? $m2 : $m1, $t1]; } protected function compileImport($rawPath, OutputBlock $out, $once = false) { if ($rawPath[0] === Type::T_STRING) { $path = $this->compileStringContent($rawPath); if (strpos($path, 'url(') !== 0 && $filePath = $this->findImport($path, $this->currentDirectory)) { $this->registerImport($this->currentDirectory, $path, $filePath); if (! $once || ! \in_array($filePath, $this->importedFiles)) { $this->importFile($filePath, $out); $this->importedFiles[] = $filePath; } return true; } $this->appendRootDirective('@import ' . $this->compileImportPath($rawPath) . ';', $out); return false; } if ($rawPath[0] === Type::T_LIST) { if (\count($rawPath[2]) === 0) { return false; } foreach ($rawPath[2] as $path) { if ($path[0] !== Type::T_STRING) { $this->appendRootDirective('@import ' . $this->compileImportPath($rawPath) . ';', $out); return false; } } foreach ($rawPath[2] as $path) { $this->compileImport($path, $out, $once); } return true; } $this->appendRootDirective('@import ' . $this->compileImportPath($rawPath) . ';', $out); return false; } protected function compileImportPath($rawPath) { $path = $this->compileValue($rawPath); if (strpos($path, 'url(') === 0) { $path = str_replace(array("\r", "\n"), array('', ' '), $path); } else { $path = $this->reduce($rawPath); $path = $this->escapeImportPathString($path); $path = $this->compileValue($path); } return $path; } protected function escapeImportPathString($path) { switch ($path[0]) { case Type::T_LIST: foreach ($path[2] as $k => $v) { $path[2][$k] = $this->escapeImportPathString($v); } break; case Type::T_STRING: if ($path[1]) { $path = $this->compileValue($path); $path = str_replace(' ', '\\ ', $path); $path = [Type::T_KEYWORD, $path]; } break; } return $path; } protected function appendRootDirective($line, $out, $allowed = [Type::T_COMMENT]) { $root = $out; while ($root->parent) { $root = $root->parent; } $i = 0; while ($i < \count($root->children)) { if (! isset($root->children[$i]->type) || ! \in_array($root->children[$i]->type, $allowed)) { break; } $i++; } $saveChildren = []; while ($i < \count($root->children)) { $saveChildren[] = array_pop($root->children); } $child = $this->makeOutputBlock(Type::T_COMMENT); $child->lines[] = $line; $child->sourceName = $this->sourceNames[$this->sourceIndex] ?: '(stdin)'; $child->sourceLine = $this->sourceLine; $child->sourceColumn = $this->sourceColumn; $root->children[] = $child; while (\count($saveChildren)) { $root->children[] = array_pop($saveChildren); } } protected function appendOutputLine(OutputBlock $out, $type, $line) { $outWrite = &$out; if (\count($out->children)) { $lastChild = &$out->children[\count($out->children) - 1]; if ( $lastChild->depth === $out->depth && \is_null($lastChild->selectors) && ! \count($lastChild->children) ) { $outWrite = $lastChild; } else { $nextLines = $this->makeOutputBlock($type); $nextLines->parent = $out; $nextLines->depth = $out->depth; $out->children[] = $nextLines; $outWrite = &$nextLines; } } $outWrite->lines[] = $line; } protected function compileChild($child, OutputBlock $out) { if (isset($child[Parser::SOURCE_LINE])) { $this->sourceIndex = isset($child[Parser::SOURCE_INDEX]) ? $child[Parser::SOURCE_INDEX] : null; $this->sourceLine = isset($child[Parser::SOURCE_LINE]) ? $child[Parser::SOURCE_LINE] : -1; $this->sourceColumn = isset($child[Parser::SOURCE_COLUMN]) ? $child[Parser::SOURCE_COLUMN] : -1; } elseif (\is_array($child) && isset($child[1]->sourceLine) && $child[1] instanceof Block) { $this->sourceIndex = $child[1]->sourceIndex; $this->sourceLine = $child[1]->sourceLine; $this->sourceColumn = $child[1]->sourceColumn; } elseif (! empty($out->sourceLine) && ! empty($out->sourceName)) { $this->sourceLine = $out->sourceLine; $sourceIndex = array_search($out->sourceName, $this->sourceNames); $this->sourceColumn = $out->sourceColumn; if ($sourceIndex === false) { $sourceIndex = null; } $this->sourceIndex = $sourceIndex; } switch ($child[0]) { case Type::T_SCSSPHP_IMPORT_ONCE: $rawPath = $this->reduce($child[1]); $this->compileImport($rawPath, $out, true); break; case Type::T_IMPORT: $rawPath = $this->reduce($child[1]); $this->compileImport($rawPath, $out); break; case Type::T_DIRECTIVE: $this->compileDirective($child[1], $out); break; case Type::T_AT_ROOT: $this->compileAtRoot($child[1]); break; case Type::T_MEDIA: $this->compileMedia($child[1]); break; case Type::T_BLOCK: $this->compileBlock($child[1]); break; case Type::T_CHARSET: break; case Type::T_CUSTOM_PROPERTY: list(, $name, $value) = $child; $compiledName = $this->compileValue($name); if ($value[0] !== Type::T_NULL) { $value = $this->reduce($value); if ($value[0] === Type::T_NULL || $value === static::$nullString) { break; } } $compiledValue = $this->compileValue($value); $line = $this->formatter->customProperty( $compiledName, $compiledValue ); $this->appendOutputLine($out, Type::T_ASSIGN, $line); break; case Type::T_ASSIGN: list(, $name, $value) = $child; if ($name[0] === Type::T_VARIABLE) { $flags = isset($child[3]) ? $child[3] : []; $isDefault = \in_array('!default', $flags); $isGlobal = \in_array('!global', $flags); if ($isGlobal) { $this->set($name[1], $this->reduce($value), false, $this->rootEnv, $value); break; } $shouldSet = $isDefault && (\is_null($result = $this->get($name[1], false)) || $result === static::$null); if (! $isDefault || $shouldSet) { $this->set($name[1], $this->reduce($value), true, null, $value); } break; } $compiledName = $this->compileValue($name); if (\in_array($compiledName, ['font', 'grid-row', 'grid-column', 'border-radius'])) { if ($value[0] === Type::T_VARIABLE) { $value = $this->get($value[1], true, null, true); } $shorthandValue=&$value; $shorthandDividerNeedsUnit = false; $maxListElements = null; $maxShorthandDividers = 1; switch ($compiledName) { case 'border-radius': $maxListElements = 4; $shorthandDividerNeedsUnit = true; break; } if ($compiledName === 'font' && $value[0] === Type::T_LIST && $value[1] === ',') { $shorthandValue=&$value[2][0]; } if ($shorthandValue[0] === Type::T_EXPRESSION && $shorthandValue[1] === '/') { $revert = true; if ($shorthandDividerNeedsUnit) { $divider = $shorthandValue[3]; if (\is_array($divider)) { $divider = $this->reduce($divider, true); } if ($divider instanceof Number && \intval($divider->getDimension()) && $divider->unitless()) { $revert = false; } } if ($revert) { $shorthandValue = $this->expToString($shorthandValue); } } elseif ($shorthandValue[0] === Type::T_LIST) { foreach ($shorthandValue[2] as &$item) { if ($item[0] === Type::T_EXPRESSION && $item[1] === '/') { if ($maxShorthandDividers > 0) { $revert = true; if (\is_null($maxListElements) || \count($shorthandValue[2]) <= $maxListElements) { if ($shorthandDividerNeedsUnit) { $divider = $item[3]; if (\is_array($divider)) { $divider = $this->reduce($divider, true); } if ($divider instanceof Number && \intval($divider->getDimension()) && $divider->unitless()) { $revert = false; } } } if ($revert) { $item = $this->expToString($item); $maxShorthandDividers--; } } } } } } if ($value[0] !== Type::T_NULL) { $value = $this->reduce($value); if ($value[0] === Type::T_NULL || $value === static::$nullString) { break; } } $compiledValue = $this->compileValue($value); if (\strlen($compiledValue)) { $line = $this->formatter->property( $compiledName, $compiledValue ); $this->appendOutputLine($out, Type::T_ASSIGN, $line); } break; case Type::T_COMMENT: if ($out->type === Type::T_ROOT) { $this->compileComment($child); break; } $line = $this->compileCommentValue($child, true); $this->appendOutputLine($out, Type::T_COMMENT, $line); break; case Type::T_MIXIN: case Type::T_FUNCTION: list(, $block) = $child; assert($block instanceof CallableBlock); $block->parentEnv = $this->getStoreEnv(); $this->set(static::$namespaces[$block->type] . $block->name, $block, true); break; case Type::T_EXTEND: foreach ($child[1] as $sel) { $replacedSel = $this->replaceSelfSelector($sel); if ($replacedSel !== $sel) { throw $this->error('Parent selectors aren\'t allowed here.'); } $results = $this->evalSelectors([$sel]); foreach ($results as $result) { if (\count($result) !== 1) { throw $this->error('complex selectors may not be extended.'); } $result = $result[0]; $selectors = $out->selectors; if (! $selectors && isset($child['selfParent'])) { $selectors = $this->multiplySelectors($this->env, $child['selfParent']); } assert($selectors !== null); if (\count($result) > 1) { $replacement = implode(', ', $result); $fname = $this->getPrettyPath($this->sourceNames[$this->sourceIndex]); $line = $this->sourceLine; $message = <<<EOL
on line $line of $fname:
Compound selectors may no longer be extended.
Consider `@extend $replacement` instead.
See http://bit.ly/ExtendCompound for details.
EOL;
$this->logger->warn($message); } $this->pushExtends($result, $selectors, $child); } } break; case Type::T_IF: list(, $if) = $child; assert($if instanceof IfBlock); if ($this->isTruthy($this->reduce($if->cond, true))) { return $this->compileChildren($if->children, $out); } foreach ($if->cases as $case) { if ( $case instanceof ElseBlock || $case instanceof ElseifBlock && $this->isTruthy($this->reduce($case->cond)) ) { return $this->compileChildren($case->children, $out); } } break; case Type::T_EACH: list(, $each) = $child; assert($each instanceof EachBlock); $list = $this->coerceList($this->reduce($each->list), ',', true); $this->pushEnv(); foreach ($list[2] as $item) { if (\count($each->vars) === 1) { $this->set($each->vars[0], $item, true); } else { list(,, $values) = $this->coerceList($item); foreach ($each->vars as $i => $var) { $this->set($var, isset($values[$i]) ? $values[$i] : static::$null, true); } } $ret = $this->compileChildren($each->children, $out); if ($ret) { $store = $this->env->store; $this->popEnv(); $this->backPropagateEnv($store, $each->vars); return $ret; } } $store = $this->env->store; $this->popEnv(); $this->backPropagateEnv($store, $each->vars); break; case Type::T_WHILE: list(, $while) = $child; assert($while instanceof WhileBlock); while ($this->isTruthy($this->reduce($while->cond, true))) { $ret = $this->compileChildren($while->children, $out); if ($ret) { return $ret; } } break; case Type::T_FOR: list(, $for) = $child; assert($for instanceof ForBlock); $startNumber = $this->assertNumber($this->reduce($for->start, true)); $endNumber = $this->assertNumber($this->reduce($for->end, true)); $start = $this->assertInteger($startNumber); $numeratorUnits = $startNumber->getNumeratorUnits(); $denominatorUnits = $startNumber->getDenominatorUnits(); $end = $this->assertInteger($endNumber->coerce($numeratorUnits, $denominatorUnits)); $d = $start < $end ? 1 : -1; $this->pushEnv(); for (;;) { if ( (! $for->until && $start - $d == $end) || ($for->until && $start == $end) ) { break; } $this->set($for->var, new Number($start, $numeratorUnits, $denominatorUnits)); $start += $d; $ret = $this->compileChildren($for->children, $out); if ($ret) { $store = $this->env->store; $this->popEnv(); $this->backPropagateEnv($store, [$for->var]); return $ret; } } $store = $this->env->store; $this->popEnv(); $this->backPropagateEnv($store, [$for->var]); break; case Type::T_RETURN: return $this->reduce($child[1], true); case Type::T_NESTED_PROPERTY: $this->compileNestedPropertiesBlock($child[1], $out); break; case Type::T_INCLUDE: list(, $name, $argValues, $content, $argUsing) = $child; $mixin = $this->get(static::$namespaces['mixin'] . $name, false); if (! $mixin) { throw $this->error("Undefined mixin $name"); } assert($mixin instanceof CallableBlock); $callingScope = $this->getStoreEnv(); $this->pushEnv(); $this->env->depth--; $selfParent = null; if (isset($child['selfParent']) && $child['selfParent'] instanceof Block && isset($child['selfParent']->selectors)) { $selfParent = $child['selfParent']; } else { $parentSelectors = $this->multiplySelectors($this->env); if ($parentSelectors) { $parent = new Block(); $parent->selectors = $parentSelectors; foreach ($mixin->children as $k => $child) { if (isset($child[1]) && $child[1] instanceof Block) { $mixin->children[$k][1]->parent = $parent; } } } } if (isset($content)) { $copyContent = clone $content; $copyContent->scope = clone $callingScope; $this->setRaw(static::$namespaces['special'] . 'content', $copyContent, $this->env); } else { $this->setRaw(static::$namespaces['special'] . 'content', null, $this->env); } if (isset($argUsing)) { $this->setRaw(static::$namespaces['special'] . 'using', $argUsing, $this->env); } else { $this->setRaw(static::$namespaces['special'] . 'using', null, $this->env); } if (isset($mixin->args)) { $this->applyArguments($mixin->args, $argValues); } $this->env->marker = 'mixin'; if (! empty($mixin->parentEnv)) { $this->env->declarationScopeParent = $mixin->parentEnv; } else { throw $this->error("@mixin $name() without parentEnv"); } $this->compileChildrenNoReturn($mixin->children, $out, $selfParent, $this->env->marker . ' ' . $name); $this->popEnv(); break; case Type::T_MIXIN_CONTENT: $env = isset($this->storeEnv) ? $this->storeEnv : $this->env; $content = $this->get(static::$namespaces['special'] . 'content', false, $env); $argUsing = $this->get(static::$namespaces['special'] . 'using', false, $env); $argContent = $child[1]; if (! $content) { break; } $storeEnv = $this->storeEnv; $varsUsing = []; if (isset($argUsing) && isset($argContent)) { $this->storeEnv = null; $varsUsing = $this->applyArguments($argUsing, $argContent, false); } $this->storeEnv = $content->scope; foreach ($varsUsing as $name => $val) { $this->set($name, $val, true, $this->storeEnv); } $this->compileChildrenNoReturn($content->children, $out); $this->storeEnv = $storeEnv; break; case Type::T_DEBUG: list(, $value) = $child; $fname = $this->getPrettyPath($this->sourceNames[$this->sourceIndex]); $line = $this->sourceLine; $value = $this->compileDebugValue($value); $this->logger->debug("$fname:$line DEBUG: $value"); break; case Type::T_WARN: list(, $value) = $child; $fname = $this->getPrettyPath($this->sourceNames[$this->sourceIndex]); $line = $this->sourceLine; $value = $this->compileDebugValue($value); $this->logger->warn("$value\n         on line $line of $fname"); break; case Type::T_ERROR: list(, $value) = $child; $fname = $this->getPrettyPath($this->sourceNames[$this->sourceIndex]); $line = $this->sourceLine; $value = $this->compileValue($this->reduce($value, true)); throw $this->error("File $fname on line $line ERROR: $value\n"); default: throw $this->error("unknown child type: $child[0]"); } return null; } protected function expToString($exp, $keepParens = false) { list(, $op, $left, $right, $inParens, $whiteLeft, $whiteRight) = $exp; $content = []; if ($keepParens && $inParens) { $content[] = '('; } $content[] = $this->reduce($left); if ($whiteLeft) { $content[] = ' '; } $content[] = $op; if ($whiteRight) { $content[] = ' '; } $content[] = $this->reduce($right); if ($keepParens && $inParens) { $content[] = ')'; } return [Type::T_STRING, '', $content]; } public function isTruthy($value) { return $value !== static::$false && $value !== static::$null; } protected function isImmediateRelationshipCombinator($value) { return $value === '>' || $value === '+' || $value === '~'; } protected function shouldEval($value) { switch ($value[0]) { case Type::T_EXPRESSION: if ($value[1] === '/') { return $this->shouldEval($value[2]) || $this->shouldEval($value[3]); } case Type::T_VARIABLE: case Type::T_FUNCTION_CALL: return true; } return false; } protected function reduce($value, $inExp = false) { if ($value instanceof Number) { return $value; } switch ($value[0]) { case Type::T_EXPRESSION: list(, $op, $left, $right, $inParens) = $value; $opName = isset(static::$operatorNames[$op]) ? static::$operatorNames[$op] : $op; $inExp = $inExp || $this->shouldEval($left) || $this->shouldEval($right); $left = $this->reduce($left, true); if ($op !== 'and' && $op !== 'or') { $right = $this->reduce($right, true); } if ( $opName == 'div' && ! $inParens && ! $inExp && (($right[0] !== Type::T_NUMBER && isset($right[2]) && $right[2] != '') || ($right[0] === Type::T_NUMBER && ! $right->unitless())) ) { return $this->expToString($value); } $left = $this->coerceForExpression($left); $right = $this->coerceForExpression($right); $ltype = $left[0]; $rtype = $right[0]; $ucOpName = ucfirst($opName); $ucLType = ucfirst($ltype); $ucRType = ucfirst($rtype); $shouldEval = $inParens || $inExp; if (\is_callable([$this, $fn = "op{$ucOpName}{$ucLType}{$ucRType}"])) { $out = $this->$fn($left, $right, $shouldEval); } elseif (\is_callable([$this, $fn = "op{$ucLType}{$ucRType}"])) { $out = $this->$fn($op, $left, $right, $shouldEval); } elseif (\is_callable([$this, $fn = "op{$ucOpName}"])) { $out = $this->$fn($left, $right, $shouldEval); } else { $out = null; } if (isset($out)) { return $out; } return $this->expToString($value); case Type::T_UNARY: list(, $op, $exp, $inParens) = $value; $inExp = $inExp || $this->shouldEval($exp); $exp = $this->reduce($exp); if ($exp instanceof Number) { switch ($op) { case '+': return $exp; case '-': return $exp->unaryMinus(); } } if ($op === 'not') { if ($inExp || $inParens) { if ($exp === static::$false || $exp === static::$null) { return static::$true; } return static::$false; } $op = $op . ' '; } return [Type::T_STRING, '', [$op, $exp]]; case Type::T_VARIABLE: return $this->reduce($this->get($value[1])); case Type::T_LIST: foreach ($value[2] as &$item) { $item = $this->reduce($item); } unset($item); if (isset($value[3]) && \is_array($value[3])) { foreach ($value[3] as &$item) { $item = $this->reduce($item); } unset($item); } return $value; case Type::T_MAP: foreach ($value[1] as &$item) { $item = $this->reduce($item); } foreach ($value[2] as &$item) { $item = $this->reduce($item); } return $value; case Type::T_STRING: foreach ($value[2] as &$item) { if (\is_array($item) || $item instanceof Number) { $item = $this->reduce($item); } } return $value; case Type::T_INTERPOLATE: $value[1] = $this->reduce($value[1]); if ($inExp) { return [Type::T_KEYWORD, $this->compileValue($value, false)]; } return $value; case Type::T_FUNCTION_CALL: return $this->fncall($value[1], $value[2]); case Type::T_SELF: $selfParent = ! empty($this->env->block->selfParent) ? $this->env->block->selfParent : null; $selfSelector = $this->multiplySelectors($this->env, $selfParent); $selfSelector = $this->collapseSelectorsAsList($selfSelector); return $selfSelector; default: return $value; } } protected function fncall($functionReference, $argValues) { if (is_string($functionReference)) { $name = $functionReference; $functionReference = $this->getFunctionReference($name); if ($functionReference === static::$null || $functionReference[0] !== Type::T_FUNCTION_REFERENCE) { $functionReference = [Type::T_FUNCTION, $name, [Type::T_LIST, ',', []]]; } } if ($functionReference[0] === Type::T_FUNCTION) { $listArgs = []; foreach ((array) $argValues as $arg) { if (empty($arg[0]) || count($argValues) === 1) { $listArgs[] = $this->reduce($this->stringifyFncallArgs($arg[1])); } } return [Type::T_FUNCTION, $functionReference[1], [Type::T_LIST, ',', $listArgs]]; } if ($functionReference === static::$null || $functionReference[0] !== Type::T_FUNCTION_REFERENCE) { return static::$defaultValue; } switch ($functionReference[1]) { case 'scss': return $this->callScssFunction($functionReference[3], $argValues); case 'user': case 'native': list(,,$name, $fn, $prototype) = $functionReference; $name = strtolower($name); if (\in_array($name, ['min', 'max']) && count($argValues) >= 1) { $cssFunction = $this->cssValidArg( [Type::T_FUNCTION_CALL, $name, $argValues], ['min', 'max', 'calc', 'env', 'var'] ); if ($cssFunction !== false) { return $cssFunction; } } $returnValue = $this->callNativeFunction($name, $fn, $prototype, $argValues); if (! isset($returnValue)) { return $this->fncall([Type::T_FUNCTION, $name, [Type::T_LIST, ',', []]], $argValues); } return $returnValue; default: return static::$defaultValue; } } protected function cssValidArg($arg, $allowed_function = [], $inFunction = false) { if ($arg instanceof Number) { return $this->stringifyFncallArgs($arg); } switch ($arg[0]) { case Type::T_INTERPOLATE: return [Type::T_KEYWORD, $this->CompileValue($arg)]; case Type::T_FUNCTION: if (! \in_array($arg[1], $allowed_function)) { return false; } if ($arg[2][0] === Type::T_LIST) { foreach ($arg[2][2] as $k => $subarg) { $arg[2][2][$k] = $this->cssValidArg($subarg, $allowed_function, $arg[1]); if ($arg[2][2][$k] === false) { return false; } } } return $arg; case Type::T_FUNCTION_CALL: if (! \in_array($arg[1], $allowed_function)) { return false; } $cssArgs = []; foreach ($arg[2] as $argValue) { if ($argValue === static::$null) { return false; } $cssArg = $this->cssValidArg($argValue[1], $allowed_function, $arg[1]); if (empty($argValue[0]) && $cssArg !== false) { $cssArgs[] = [$argValue[0], $cssArg]; } else { return false; } } return $this->fncall([Type::T_FUNCTION, $arg[1], [Type::T_LIST, ',', []]], $cssArgs); case Type::T_STRING: case Type::T_KEYWORD: if (!$inFunction or !\in_array($inFunction, ['calc', 'env', 'var'])) { return false; } return $this->stringifyFncallArgs($arg); case Type::T_LIST: if (!$inFunction) { return false; } if (empty($arg['enclosing']) and $arg[1] === '') { foreach ($arg[2] as $k => $subarg) { $arg[2][$k] = $this->cssValidArg($subarg, $allowed_function, $inFunction); if ($arg[2][$k] === false) { return false; } } $arg[0] = Type::T_STRING; return $arg; } return false; case Type::T_EXPRESSION: if (! \in_array($arg[1], ['+', '-', '/', '*'])) { return false; } $arg[2] = $this->cssValidArg($arg[2], $allowed_function, $inFunction); $arg[3] = $this->cssValidArg($arg[3], $allowed_function, $inFunction); if ($arg[2] === false || $arg[3] === false) { return false; } return $this->expToString($arg, true); case Type::T_VARIABLE: case Type::T_SELF: default: return false; } } protected function stringifyFncallArgs($arg) { if ($arg instanceof Number) { return $arg; } switch ($arg[0]) { case Type::T_LIST: foreach ($arg[2] as $k => $v) { $arg[2][$k] = $this->stringifyFncallArgs($v); } break; case Type::T_EXPRESSION: if ($arg[1] === '/') { $arg[2] = $this->stringifyFncallArgs($arg[2]); $arg[3] = $this->stringifyFncallArgs($arg[3]); $arg[5] = $arg[6] = false; $arg = $this->expToString($arg); } break; case Type::T_FUNCTION_CALL: $name = strtolower($arg[1]); if (in_array($name, ['max', 'min', 'calc'])) { $args = $arg[2]; $arg = $this->fncall([Type::T_FUNCTION, $name, [Type::T_LIST, ',', []]], $args); } break; } return $arg; } protected function getFunctionReference($name, $safeCopy = false) { if ($func = $this->get(static::$namespaces['function'] . $name, false)) { if ($safeCopy) { $func = clone $func; } return [Type::T_FUNCTION_REFERENCE, 'scss', $name, $func]; } $normalizedName = $this->normalizeName($name); if (isset($this->userFunctions[$normalizedName])) { list($f, $prototype) = $this->userFunctions[$normalizedName]; return [Type::T_FUNCTION_REFERENCE, 'user', $name, $f, $prototype]; } $lowercasedName = strtolower($normalizedName); if ($lowercasedName === 'min' || $lowercasedName === 'max' || $lowercasedName === 'rgb' || $lowercasedName === 'rgba' || $lowercasedName === 'hsl' || $lowercasedName === 'hsla') { $normalizedName = $lowercasedName; } if (($f = $this->getBuiltinFunction($normalizedName)) && \is_callable($f)) { $libName = $f[1]; $prototype = isset(static::$$libName) ? static::$$libName : null; if ($prototype === null || strtolower($normalizedName) !== $normalizedName) { $r = new \ReflectionMethod($this, $libName); $actualLibName = $r->name; if ($actualLibName !== $libName || strtolower($normalizedName) !== $normalizedName) { $kebabCaseName = preg_replace('~(?<=\\w)([A-Z])~', '-$1', substr($actualLibName, 3)); assert($kebabCaseName !== null); $originalName = strtolower($kebabCaseName); $warning = "Calling built-in functions with a non-standard name is deprecated since Scssphp 1.8.0 and will not work anymore in 2.0 (they will be treated as CSS function calls instead).\nUse \"$originalName\" instead of \"$name\"."; @trigger_error($warning, E_USER_DEPRECATED); $fname = $this->getPrettyPath($this->sourceNames[$this->sourceIndex]); $line = $this->sourceLine; Warn::deprecation("$warning\n         on line $line of $fname"); $prototype = isset(static::$$actualLibName) ? static::$$actualLibName : null; $f[1] = $libName = $actualLibName; } } if (\get_class($this) !== __CLASS__ && !isset($this->warnedChildFunctions[$libName])) { $r = new \ReflectionMethod($this, $libName); $declaringClass = $r->getDeclaringClass()->name; $needsWarning = $this->warnedChildFunctions[$libName] = $declaringClass !== __CLASS__; if ($needsWarning) { if (method_exists(__CLASS__, $libName)) { @trigger_error(sprintf('Overriding the "%s" core function by extending the Compiler is deprecated and will be unsupported in 2.0. Remove the "%s::%s" method.', $normalizedName, $declaringClass, $libName), E_USER_DEPRECATED); } else { @trigger_error(sprintf('Registering custom functions by extending the Compiler and using the lib* discovery mechanism is deprecated and will be removed in 2.0. Replace the "%s::%s" method with registering the "%s" function through "Compiler::registerFunction".', $declaringClass, $libName, $normalizedName), E_USER_DEPRECATED); } } } return [Type::T_FUNCTION_REFERENCE, 'native', $name, $f, $prototype]; } return static::$null; } protected function normalizeName($name) { return str_replace('-', '_', $name); } public function normalizeValue($value) { $value = $this->coerceForExpression($this->reduce($value)); if ($value instanceof Number) { return $value; } switch ($value[0]) { case Type::T_LIST: $value = $this->extractInterpolation($value); if ($value[0] !== Type::T_LIST) { return [Type::T_KEYWORD, $this->compileValue($value)]; } foreach ($value[2] as $key => $item) { $value[2][$key] = $this->normalizeValue($item); } if (! empty($value['enclosing'])) { unset($value['enclosing']); } if ($value[1] === '' && count($value[2]) > 1) { $value[1] = ' '; } return $value; case Type::T_STRING: return [$value[0], '"', [$this->compileStringContent($value)]]; case Type::T_INTERPOLATE: return [Type::T_KEYWORD, $this->compileValue($value)]; default: return $value; } } protected function opAddNumberNumber(Number $left, Number $right) { return $left->plus($right); } protected function opMulNumberNumber(Number $left, Number $right) { return $left->times($right); } protected function opSubNumberNumber(Number $left, Number $right) { return $left->minus($right); } protected function opDivNumberNumber(Number $left, Number $right) { return $left->dividedBy($right); } protected function opModNumberNumber(Number $left, Number $right) { return $left->modulo($right); } protected function opAdd($left, $right) { if ($strLeft = $this->coerceString($left)) { if ($right[0] === Type::T_STRING) { $right[1] = ''; } $strLeft[2][] = $right; return $strLeft; } if ($strRight = $this->coerceString($right)) { if ($left[0] === Type::T_STRING) { $left[1] = ''; } array_unshift($strRight[2], $left); return $strRight; } return null; } protected function opAnd($left, $right, $shouldEval) { $truthy = ($left === static::$null || $right === static::$null) || ($left === static::$false || $left === static::$true) && ($right === static::$false || $right === static::$true); if (! $shouldEval) { if (! $truthy) { return null; } } if ($left !== static::$false && $left !== static::$null) { return $this->reduce($right, true); } return $left; } protected function opOr($left, $right, $shouldEval) { $truthy = ($left === static::$null || $right === static::$null) || ($left === static::$false || $left === static::$true) && ($right === static::$false || $right === static::$true); if (! $shouldEval) { if (! $truthy) { return null; } } if ($left !== static::$false && $left !== static::$null) { return $left; } return $this->reduce($right, true); } protected function opColorColor($op, $left, $right) { if ($op !== '==' && $op !== '!=') { $warning = "Color arithmetic is deprecated and will be an error in future versions.\n" . "Consider using Sass's color functions instead."; $fname = $this->getPrettyPath($this->sourceNames[$this->sourceIndex]); $line = $this->sourceLine; Warn::deprecation("$warning\n         on line $line of $fname"); } $out = [Type::T_COLOR]; foreach ([1, 2, 3] as $i) { $lval = isset($left[$i]) ? $left[$i] : 0; $rval = isset($right[$i]) ? $right[$i] : 0; switch ($op) { case '+': $out[] = $lval + $rval; break; case '-': $out[] = $lval - $rval; break; case '*': $out[] = $lval * $rval; break; case '%': if ($rval == 0) { throw $this->error("color: Can't take modulo by zero"); } $out[] = $lval % $rval; break; case '/': if ($rval == 0) { throw $this->error("color: Can't divide by zero"); } $out[] = (int) ($lval / $rval); break; case '==': return $this->opEq($left, $right); case '!=': return $this->opNeq($left, $right); default: throw $this->error("color: unknown op $op"); } } if (isset($left[4])) { $out[4] = $left[4]; } elseif (isset($right[4])) { $out[4] = $right[4]; } return $this->fixColor($out); } protected function opColorNumber($op, $left, Number $right) { if ($op === '==') { return static::$false; } if ($op === '!=') { return static::$true; } $value = $right->getDimension(); return $this->opColorColor( $op, $left, [Type::T_COLOR, $value, $value, $value] ); } protected function opNumberColor($op, Number $left, $right) { if ($op === '==') { return static::$false; } if ($op === '!=') { return static::$true; } $value = $left->getDimension(); return $this->opColorColor( $op, [Type::T_COLOR, $value, $value, $value], $right ); } protected function opEq($left, $right) { if (($lStr = $this->coerceString($left)) && ($rStr = $this->coerceString($right))) { $lStr[1] = ''; $rStr[1] = ''; $left = $this->compileValue($lStr); $right = $this->compileValue($rStr); } return $this->toBool($left === $right); } protected function opNeq($left, $right) { if (($lStr = $this->coerceString($left)) && ($rStr = $this->coerceString($right))) { $lStr[1] = ''; $rStr[1] = ''; $left = $this->compileValue($lStr); $right = $this->compileValue($rStr); } return $this->toBool($left !== $right); } protected function opEqNumberNumber(Number $left, Number $right) { return $this->toBool($left->equals($right)); } protected function opNeqNumberNumber(Number $left, Number $right) { return $this->toBool(!$left->equals($right)); } protected function opGteNumberNumber(Number $left, Number $right) { return $this->toBool($left->greaterThanOrEqual($right)); } protected function opGtNumberNumber(Number $left, Number $right) { return $this->toBool($left->greaterThan($right)); } protected function opLteNumberNumber(Number $left, Number $right) { return $this->toBool($left->lessThanOrEqual($right)); } protected function opLtNumberNumber(Number $left, Number $right) { return $this->toBool($left->lessThan($right)); } public function toBool($thing) { return $thing ? static::$true : static::$false; } public function escapeNonPrintableChars($string, $inKeyword = false) { static $replacement = []; if (empty($replacement[$inKeyword])) { for ($i = 0; $i < 32; $i++) { if ($i !== 9 || $inKeyword) { $replacement[$inKeyword][chr($i)] = '\\' . dechex($i) . ($inKeyword ? ' ' : chr(0)); } } } $string = str_replace(array_keys($replacement[$inKeyword]), array_values($replacement[$inKeyword]), $string); if (strpos($string, chr(0)) !== false) { if (substr($string, -1) === chr(0)) { $string = substr($string, 0, -1); } $string = str_replace( [chr(0) . '\\',chr(0) . ' '], [ '\\', ' '], $string ); if (strpos($string, chr(0)) !== false) { $parts = explode(chr(0), $string); $string = array_shift($parts); while (count($parts)) { $next = array_shift($parts); if (strpos("0123456789abcdefABCDEF" . chr(9), $next[0]) !== false) { $string .= " "; } $string .= $next; } } } return $string; } public function compileValue($value, $quote = true) { $value = $this->reduce($value); if ($value instanceof Number) { return $value->output($this); } switch ($value[0]) { case Type::T_KEYWORD: return $this->escapeNonPrintableChars($value[1], true); case Type::T_COLOR: list(, $r, $g, $b) = $value; $r = $this->compileRGBAValue($r); $g = $this->compileRGBAValue($g); $b = $this->compileRGBAValue($b); if (\count($value) === 5) { $alpha = $this->compileRGBAValue($value[4], true); if (! is_numeric($alpha) || $alpha < 1) { $colorName = Colors::RGBaToColorName($r, $g, $b, $alpha); if (! \is_null($colorName)) { return $colorName; } if (is_numeric($alpha)) { $a = new Number($alpha, ''); } else { $a = $alpha; } return 'rgba(' . $r . ', ' . $g . ', ' . $b . ', ' . $a . ')'; } } if (! is_numeric($r) || ! is_numeric($g) || ! is_numeric($b)) { return 'rgb(' . $r . ', ' . $g . ', ' . $b . ')'; } $colorName = Colors::RGBaToColorName($r, $g, $b); if (! \is_null($colorName)) { return $colorName; } $h = sprintf('#%02x%02x%02x', $r, $g, $b); if ($h[1] === $h[2] && $h[3] === $h[4] && $h[5] === $h[6]) { $h = '#' . $h[1] . $h[3] . $h[5]; } return $h; case Type::T_STRING: $content = $this->compileStringContent($value, $quote); if ($value[1] && $quote) { $content = str_replace('\\', '\\\\', $content); $content = $this->escapeNonPrintableChars($content); if ( $value[1] === "'" && (strpos($content, '"') === false or strpos($content, "'") !== false) ) { $value[1] = '"'; } elseif ( $value[1] === '"' && (strpos($content, '"') !== false and strpos($content, "'") === false) ) { $value[1] = "'"; } $content = str_replace($value[1], '\\' . $value[1], $content); } return $value[1] . $content . $value[1]; case Type::T_FUNCTION: $args = ! empty($value[2]) ? $this->compileValue($value[2], $quote) : ''; return "$value[1]($args)"; case Type::T_FUNCTION_REFERENCE: $name = ! empty($value[2]) ? $value[2] : ''; return "get-function(\"$name\")"; case Type::T_LIST: $value = $this->extractInterpolation($value); if ($value[0] !== Type::T_LIST) { return $this->compileValue($value, $quote); } list(, $delim, $items) = $value; $pre = $post = ''; if (! empty($value['enclosing'])) { switch ($value['enclosing']) { case 'parent': break; case 'forced_parent': $pre = '('; $post = ')'; break; case 'bracket': case 'forced_bracket': $pre = '['; $post = ']'; break; } } $separator = $delim === '/' ? ' /' : $delim; $prefix_value = ''; if ($delim !== ' ') { $prefix_value = ' '; } $filtered = []; $same_string_quote = null; foreach ($items as $item) { if (\is_null($same_string_quote)) { $same_string_quote = false; if ($item[0] === Type::T_STRING) { $same_string_quote = $item[1]; foreach ($items as $ii) { if ($ii[0] !== Type::T_STRING) { $same_string_quote = false; break; } } } } if ($item[0] === Type::T_NULL) { continue; } if ($same_string_quote === '"' && $item[0] === Type::T_STRING && $item[1]) { $item[1] = $same_string_quote; } $compiled = $this->compileValue($item, $quote); if ($prefix_value && \strlen($compiled)) { $compiled = $prefix_value . $compiled; } $filtered[] = $compiled; } return $pre . substr(implode($separator, $filtered), \strlen($prefix_value)) . $post; case Type::T_MAP: $keys = $value[1]; $values = $value[2]; $filtered = []; for ($i = 0, $s = \count($keys); $i < $s; $i++) { $filtered[$this->compileValue($keys[$i], $quote)] = $this->compileValue($values[$i], $quote); } array_walk($filtered, function (&$value, $key) { $value = $key . ': ' . $value; }); return '(' . implode(', ', $filtered) . ')'; case Type::T_INTERPOLATED: list(, $interpolate, $left, $right) = $value; list(,, $whiteLeft, $whiteRight) = $interpolate; $delim = $left[1]; if ($delim && $delim !== ' ' && ! $whiteLeft) { $delim .= ' '; } $left = \count($left[2]) > 0 ? $this->compileValue($left, $quote) . $delim . $whiteLeft : ''; $delim = $right[1]; if ($delim && $delim !== ' ') { $delim .= ' '; } $right = \count($right[2]) > 0 ? $whiteRight . $delim . $this->compileValue($right, $quote) : ''; return $left . $this->compileValue($interpolate, $quote) . $right; case Type::T_INTERPOLATE: $reduced = $this->reduce($value[1]); if ($reduced instanceof Number) { return $this->compileValue($reduced, $quote); } switch ($reduced[0]) { case Type::T_LIST: $reduced = $this->extractInterpolation($reduced); if ($reduced[0] !== Type::T_LIST) { break; } list(, $delim, $items) = $reduced; if ($delim !== ' ') { $delim .= ' '; } $filtered = []; foreach ($items as $item) { if ($item[0] === Type::T_NULL) { continue; } if ($item[0] === Type::T_STRING) { $filtered[] = $this->compileStringContent($item, $quote); } elseif ($item[0] === Type::T_KEYWORD) { $filtered[] = $item[1]; } else { $filtered[] = $this->compileValue($item, $quote); } } $reduced = [Type::T_KEYWORD, implode("$delim", $filtered)]; break; case Type::T_STRING: $reduced = [Type::T_STRING, '', [$this->compileStringContent($reduced)]]; break; case Type::T_NULL: $reduced = [Type::T_KEYWORD, '']; } return $this->compileValue($reduced, $quote); case Type::T_NULL: return 'null'; case Type::T_COMMENT: return $this->compileCommentValue($value); default: throw $this->error('unknown value type: ' . json_encode($value)); } } protected function compileDebugValue($value) { $value = $this->reduce($value, true); if ($value instanceof Number) { return $this->compileValue($value); } switch ($value[0]) { case Type::T_STRING: return $this->compileStringContent($value); default: return $this->compileValue($value); } } protected function flattenList($list) { @trigger_error(sprintf('The "%s" method is deprecated.', __METHOD__), E_USER_DEPRECATED); return $this->compileValue($list); } public function getStringText(array $value) { if ($value[0] !== Type::T_STRING) { throw new \InvalidArgumentException('The argument is not a sass string. Did you forgot to use "assertString"?'); } return $this->compileStringContent($value); } protected function compileStringContent($string, $quote = true) { $parts = []; foreach ($string[2] as $part) { if (\is_array($part) || $part instanceof Number) { $parts[] = $this->compileValue($part, $quote); } else { $parts[] = $part; } } return implode($parts); } protected function extractInterpolation($list) { $items = $list[2]; foreach ($items as $i => $item) { if ($item[0] === Type::T_INTERPOLATE) { $before = [Type::T_LIST, $list[1], \array_slice($items, 0, $i)]; $after = [Type::T_LIST, $list[1], \array_slice($items, $i + 1)]; return [Type::T_INTERPOLATED, $item, $before, $after]; } } return $list; } protected function multiplySelectors(Environment $env, $selfParent = null) { $envs = $this->compactEnv($env); $selectors = []; $parentSelectors = [[]]; $selfParentSelectors = null; if (! \is_null($selfParent) && $selfParent->selectors) { $selfParentSelectors = $this->evalSelectors($selfParent->selectors); } while ($env = array_pop($envs)) { if (empty($env->selectors)) { continue; } $selectors = $env->selectors; do { $stillHasSelf = false; $prevSelectors = $selectors; $selectors = []; foreach ($parentSelectors as $parent) { foreach ($prevSelectors as $selector) { if ($selfParentSelectors) { foreach ($selfParentSelectors as $selfParent) { $s = $this->joinSelectors($parent, $selector, $stillHasSelf, $selfParent); $selectors[serialize($s)] = $s; } } else { $s = $this->joinSelectors($parent, $selector, $stillHasSelf); $selectors[serialize($s)] = $s; } } } } while ($stillHasSelf); $parentSelectors = $selectors; } $selectors = array_values($selectors); if (! $selectors && $selfParentSelectors) { $selectors = $selfParentSelectors; } return $selectors; } protected function joinSelectors($parent, $child, &$stillHasSelf, $selfParentSelectors = null) { $setSelf = false; $out = []; foreach ($child as $part) { $newPart = []; foreach ($part as $p) { if ($p === static::$selfSelector && $setSelf) { $stillHasSelf = true; } if ($p === static::$selfSelector && ! $setSelf) { $setSelf = true; if (\is_null($selfParentSelectors)) { $selfParentSelectors = $parent; } foreach ($selfParentSelectors as $i => $parentPart) { if ($i > 0) { $out[] = $newPart; $newPart = []; } foreach ($parentPart as $pp) { if (\is_array($pp)) { $flatten = []; array_walk_recursive($pp, function ($a) use (&$flatten) { $flatten[] = $a; }); $pp = implode($flatten); } $newPart[] = $pp; } } } else { $newPart[] = $p; } } $out[] = $newPart; } return $setSelf ? $out : array_merge($parent, $child); } protected function multiplyMedia(Environment $env = null, $childQueries = null) { if ( ! isset($env) || ! empty($env->block->type) && $env->block->type !== Type::T_MEDIA ) { return $childQueries; } if (empty($env->block->type)) { return $this->multiplyMedia($env->parent, $childQueries); } assert($env->block instanceof MediaBlock); $parentQueries = isset($env->block->queryList) ? $env->block->queryList : [[[Type::T_MEDIA_VALUE, $env->block->value]]]; $store = [$this->env, $this->storeEnv]; $this->env = $env; $this->storeEnv = null; $parentQueries = $this->evaluateMediaQuery($parentQueries); list($this->env, $this->storeEnv) = $store; if (\is_null($childQueries)) { $childQueries = $parentQueries; } else { $originalQueries = $childQueries; $childQueries = []; foreach ($parentQueries as $parentQuery) { foreach ($originalQueries as $childQuery) { $childQueries[] = array_merge( $parentQuery, [[Type::T_MEDIA_TYPE, [Type::T_KEYWORD, 'all']]], $childQuery ); } } } return $this->multiplyMedia($env->parent, $childQueries); } protected function compactEnv(Environment $env) { for ($envs = []; $env; $env = $env->parent) { $envs[] = $env; } return $envs; } protected function extractEnv($envs) { for ($env = null; $e = array_pop($envs);) { $e->parent = $env; $env = $e; } return $env; } protected function pushEnv(Block $block = null) { $env = new Environment(); $env->parent = $this->env; $env->parentStore = $this->storeEnv; $env->store = []; $env->block = $block; $env->depth = isset($this->env->depth) ? $this->env->depth + 1 : 0; $this->env = $env; $this->storeEnv = null; return $env; } protected function popEnv() { $this->storeEnv = $this->env->parentStore; $this->env = $this->env->parent; } protected function backPropagateEnv($store, $excludedVars = null) { foreach ($store as $key => $value) { if (empty($excludedVars) || ! \in_array($key, $excludedVars)) { $this->set($key, $value, true); } } } protected function getStoreEnv() { return isset($this->storeEnv) ? $this->storeEnv : $this->env; } protected function set($name, $value, $shadow = false, Environment $env = null, $valueUnreduced = null) { $name = $this->normalizeName($name); if (! isset($env)) { $env = $this->getStoreEnv(); } if ($shadow) { $this->setRaw($name, $value, $env, $valueUnreduced); } else { $this->setExisting($name, $value, $env, $valueUnreduced); } } protected function setExisting($name, $value, Environment $env, $valueUnreduced = null) { $storeEnv = $env; $specialContentKey = static::$namespaces['special'] . 'content'; $hasNamespace = $name[0] === '^' || $name[0] === '@' || $name[0] === '%'; $maxDepth = 10000; for (;;) { if ($maxDepth-- <= 0) { break; } if (\array_key_exists($name, $env->store)) { break; } if (! $hasNamespace && isset($env->marker)) { if (! empty($env->store[$specialContentKey])) { $env = $env->store[$specialContentKey]->scope; continue; } if (! empty($env->declarationScopeParent)) { $env = $env->declarationScopeParent; continue; } else { $env = $storeEnv; break; } } if (isset($env->parentStore)) { $env = $env->parentStore; } elseif (isset($env->parent)) { $env = $env->parent; } else { $env = $storeEnv; break; } } $env->store[$name] = $value; if ($valueUnreduced) { $env->storeUnreduced[$name] = $valueUnreduced; } } protected function setRaw($name, $value, Environment $env, $valueUnreduced = null) { $env->store[$name] = $value; if ($valueUnreduced) { $env->storeUnreduced[$name] = $valueUnreduced; } } public function get($name, $shouldThrow = true, Environment $env = null, $unreduced = false) { $normalizedName = $this->normalizeName($name); $specialContentKey = static::$namespaces['special'] . 'content'; if (! isset($env)) { $env = $this->getStoreEnv(); } $hasNamespace = $normalizedName[0] === '^' || $normalizedName[0] === '@' || $normalizedName[0] === '%'; $maxDepth = 10000; for (;;) { if ($maxDepth-- <= 0) { break; } if (\array_key_exists($normalizedName, $env->store)) { if ($unreduced && isset($env->storeUnreduced[$normalizedName])) { return $env->storeUnreduced[$normalizedName]; } return $env->store[$normalizedName]; } if (! $hasNamespace && isset($env->marker)) { if (! empty($env->store[$specialContentKey])) { $env = $env->store[$specialContentKey]->scope; continue; } if (! empty($env->declarationScopeParent)) { $env = $env->declarationScopeParent; } else { $env = $this->rootEnv; } continue; } if (isset($env->parentStore)) { $env = $env->parentStore; } elseif (isset($env->parent)) { $env = $env->parent; } else { break; } } if ($shouldThrow) { throw $this->error("Undefined variable \$$name" . ($maxDepth <= 0 ? ' (infinite recursion)' : '')); } return null; } protected function has($name, Environment $env = null) { return ! \is_null($this->get($name, false, $env)); } protected function injectVariables(array $args) { if (empty($args)) { return; } $parser = $this->parserFactory(__METHOD__); foreach ($args as $name => $strValue) { if ($name[0] === '$') { $name = substr($name, 1); } if (!\is_string($strValue) || ! $parser->parseValue($strValue, $value)) { $value = $this->coerceValue($strValue); } $this->set($name, $value); } } public function replaceVariables(array $variables) { $this->registeredVars = []; $this->addVariables($variables); } public function addVariables(array $variables) { $triggerWarning = false; foreach ($variables as $name => $value) { if (!$value instanceof Number && !\is_array($value)) { $triggerWarning = true; } $this->registeredVars[$name] = $value; } if ($triggerWarning) { @trigger_error('Passing raw values to as custom variables to the Compiler is deprecated. Use "\ScssPhp\ScssPhp\ValueConverter::parseValue" or "\ScssPhp\ScssPhp\ValueConverter::fromPhp" to convert them instead.', E_USER_DEPRECATED); } } public function setVariables(array $variables) { @trigger_error('The method "setVariables" of the Compiler is deprecated. Use the "addVariables" method for the equivalent behavior or "replaceVariables" if merging with previous variables was not desired.'); $this->addVariables($variables); } public function unsetVariable($name) { unset($this->registeredVars[$name]); } public function getVariables() { return $this->registeredVars; } public function addParsedFile($path) { if (! \is_null($path) && is_file($path)) { $this->parsedFiles[realpath($path)] = filemtime($path); } } public function getParsedFiles() { @trigger_error('The method "getParsedFiles" of the Compiler is deprecated. Use the "getIncludedFiles" method on the CompilationResult instance returned by compileString() instead. Be careful that the signature of the method is different.', E_USER_DEPRECATED); return $this->parsedFiles; } public function addImportPath($path) { if (! \in_array($path, $this->importPaths)) { $this->importPaths[] = $path; } } public function setImportPaths($path) { $paths = (array) $path; $actualImportPaths = array_filter($paths, function ($path) { return $path !== ''; }); $this->legacyCwdImportPath = \count($actualImportPaths) !== \count($paths); if ($this->legacyCwdImportPath) { @trigger_error('Passing an empty string in the import paths to refer to the current working directory is deprecated. If that\'s the intended behavior, the value of "getcwd()" should be used directly instead. If this was used for resolving relative imports of the input alongside "chdir" with the source directory, the path of the input file should be passed to "compileString()" instead.', E_USER_DEPRECATED); } $this->importPaths = $actualImportPaths; } public function setNumberPrecision($numberPrecision) { @trigger_error('The number precision is not configurable anymore. ' . 'The default is enough for all browsers.', E_USER_DEPRECATED); } public function setOutputStyle($style) { switch ($style) { case OutputStyle::EXPANDED: $this->configuredFormatter = Expanded::class; break; case OutputStyle::COMPRESSED: $this->configuredFormatter = Compressed::class; break; default: throw new \InvalidArgumentException(sprintf('Invalid output style "%s".', $style)); } } public function setFormatter($formatterName) { if (!\in_array($formatterName, [Expanded::class, Compressed::class], true)) { @trigger_error('Formatters other than Expanded and Compressed are deprecated.', E_USER_DEPRECATED); } @trigger_error('The method "setFormatter" is deprecated. Use "setOutputStyle" instead.', E_USER_DEPRECATED); $this->configuredFormatter = $formatterName; } public function setLineNumberStyle($lineNumberStyle) { @trigger_error('The line number output is not supported anymore. ' . 'Use source maps instead.', E_USER_DEPRECATED); } public function setCharset($charset) { $this->charset = $charset; } public function setSourceMap($sourceMap) { $this->sourceMap = $sourceMap; } public function setSourceMapOptions($sourceMapOptions) { $this->sourceMapOptions = $sourceMapOptions; } public function registerFunction($name, $callback, $argumentDeclaration = null) { if (self::isNativeFunction($name)) { @trigger_error(sprintf('The "%s" function is a core sass function. Overriding it with a custom implementation through "%s" is deprecated and won\'t be supported in ScssPhp 2.0 anymore.', $name, __METHOD__), E_USER_DEPRECATED); } if ($argumentDeclaration === null) { @trigger_error('Omitting the argument declaration when registering custom function is deprecated and won\'t be supported in ScssPhp 2.0 anymore.', E_USER_DEPRECATED); } $this->userFunctions[$this->normalizeName($name)] = [$callback, $argumentDeclaration]; } public function unregisterFunction($name) { unset($this->userFunctions[$this->normalizeName($name)]); } public function addFeature($name) { @trigger_error('Registering additional features is deprecated.', E_USER_DEPRECATED); $this->registeredFeatures[$name] = true; } protected function importFile($path, OutputBlock $out) { $this->pushCallStack('import ' . $this->getPrettyPath($path)); $realPath = realpath($path); if ($realPath === false) { $realPath = $path; } if (substr($path, -5) === '.sass') { $this->sourceIndex = \count($this->sourceNames); $this->sourceNames[] = $path; $this->sourceLine = 1; $this->sourceColumn = 1; throw $this->error('The Sass indented syntax is not implemented.'); } if (isset($this->importCache[$realPath])) { $this->handleImportLoop($realPath); $tree = $this->importCache[$realPath]; } else { $code = file_get_contents($path); $parser = $this->parserFactory($path); $tree = $parser->parse($code); $this->importCache[$realPath] = $tree; } $currentDirectory = $this->currentDirectory; $this->currentDirectory = dirname($path); $this->compileChildrenNoReturn($tree->children, $out); $this->currentDirectory = $currentDirectory; $this->popCallStack(); } private function registerImport($currentDirectory, $path, $filePath) { $this->resolvedImports[] = ['currentDir' => $currentDirectory, 'path' => $path, 'filePath' => $filePath]; } public static function isCssImport($url) { return 1 === preg_match('~\.css$|^https?://|^//~', $url); } public function findImport($url, $currentDir = null) { if (self::isCssImport($url)) { foreach ($this->importPaths as $dir) { if (\is_string($dir)) { continue; } if (\is_callable($dir)) { $file = \call_user_func($dir, $url); if (! \is_null($file)) { if (\is_array($dir)) { $callableDescription = (\is_object($dir[0]) ? \get_class($dir[0]) : $dir[0]).'::'.$dir[1]; } elseif ($dir instanceof \Closure) { $r = new \ReflectionFunction($dir); if (false !== strpos($r->name, '{closure}')) { $callableDescription = sprintf('closure{%s:%s}', $r->getFileName(), $r->getStartLine()); } elseif ($class = $r->getClosureScopeClass()) { $callableDescription = $class->name.'::'.$r->name; } else { $callableDescription = $r->name; } } elseif (\is_object($dir)) { $callableDescription = \get_class($dir) . '::__invoke'; } else { $callableDescription = 'callable'; } @trigger_error(sprintf('Returning a file to import for CSS or external references in custom importer callables is deprecated and will not be supported anymore in ScssPhp 2.0. This behavior is not compliant with the Sass specification. Update your "%s" importer.', $callableDescription), E_USER_DEPRECATED); return $file; } } } return null; } if (!\is_null($currentDir)) { $relativePath = $this->resolveImportPath($url, $currentDir); if (!\is_null($relativePath)) { return $relativePath; } } foreach ($this->importPaths as $dir) { if (\is_string($dir)) { $path = $this->resolveImportPath($url, $dir); if (!\is_null($path)) { return $path; } } elseif (\is_callable($dir)) { $file = \call_user_func($dir, $url); if (! \is_null($file)) { return $file; } } } if ($this->legacyCwdImportPath) { $path = $this->resolveImportPath($url, getcwd()); if (!\is_null($path)) { @trigger_error('Resolving imports relatively to the current working directory is deprecated. If that\'s the intended behavior, the value of "getcwd()" should be added as an import path explicitly instead. If this was used for resolving relative imports of the input alongside "chdir" with the source directory, the path of the input file should be passed to "compileString()" instead.', E_USER_DEPRECATED); return $path; } } throw $this->error("`$url` file not found for @import"); } private function resolveImportPath($url, $baseDir) { $path = Path::join($baseDir, $url); $hasExtension = preg_match('/.s[ac]ss$/', $url); if ($hasExtension) { return $this->checkImportPathConflicts($this->tryImportPath($path)); } $result = $this->checkImportPathConflicts($this->tryImportPathWithExtensions($path)); if (!\is_null($result)) { return $result; } return $this->tryImportPathAsDirectory($path); } private function checkImportPathConflicts(array $paths) { if (\count($paths) === 0) { return null; } if (\count($paths) === 1) { return $paths[0]; } $formattedPrettyPaths = []; foreach ($paths as $path) { $formattedPrettyPaths[] = '  ' . $this->getPrettyPath($path); } throw $this->error("It's not clear which file to import. Found:\n" . implode("\n", $formattedPrettyPaths)); } private function tryImportPathWithExtensions($path) { $result = array_merge( $this->tryImportPath($path.'.sass'), $this->tryImportPath($path.'.scss') ); if ($result) { return $result; } return $this->tryImportPath($path.'.css'); } private function tryImportPath($path) { $partial = dirname($path).'/_'.basename($path); $candidates = []; if (is_file($partial)) { $candidates[] = $partial; } if (is_file($path)) { $candidates[] = $path; } return $candidates; } private function tryImportPathAsDirectory($path) { if (!is_dir($path)) { return null; } return $this->checkImportPathConflicts($this->tryImportPathWithExtensions($path.'/index')); } private function getPrettyPath($path) { if ($path === null) { return '(unknown file)'; } $normalizedPath = $path; $normalizedRootDirectory = $this->rootDirectory.'/'; if (\DIRECTORY_SEPARATOR === '\\') { $normalizedRootDirectory = str_replace('\\', '/', $normalizedRootDirectory); $normalizedPath = str_replace('\\', '/', $path); } if (0 === strpos($normalizedPath, $normalizedRootDirectory)) { return substr($path, \strlen($normalizedRootDirectory)); } return $path; } public function setEncoding($encoding) { if (!$encoding || strtolower($encoding) === 'utf-8') { @trigger_error(sprintf('The "%s" method is deprecated.', __METHOD__), E_USER_DEPRECATED); } else { @trigger_error(sprintf('The "%s" method is deprecated. Parsing will only support UTF-8 in ScssPhp 2.0. The non-UTF-8 parsing of ScssPhp 1.x is not spec compliant.', __METHOD__), E_USER_DEPRECATED); } $this->encoding = $encoding; } public function setIgnoreErrors($ignoreErrors) { @trigger_error('Ignoring Sass errors is not longer supported.', E_USER_DEPRECATED); return $this; } public function getSourcePosition() { @trigger_error(sprintf('The "%s" method is deprecated.', __METHOD__), E_USER_DEPRECATED); $sourceFile = isset($this->sourceNames[$this->sourceIndex]) ? $this->sourceNames[$this->sourceIndex] : ''; return [$sourceFile, $this->sourceLine, $this->sourceColumn]; } public function throwError($msg) { @trigger_error( 'The method "throwError" is deprecated. Use "error" and throw the exception in the caller instead', E_USER_DEPRECATED ); throw $this->error(...func_get_args()); } public function error($msg, ...$args) { if ($args) { $msg = sprintf($msg, ...$args); } if (! $this->ignoreCallStackMessage) { $msg = $this->addLocationToMessage($msg); } return new CompilerException($msg); } private function addLocationToMessage($msg) { $line = $this->sourceLine; $column = $this->sourceColumn; $loc = isset($this->sourceNames[$this->sourceIndex]) ? $this->getPrettyPath($this->sourceNames[$this->sourceIndex]) . " on line $line, at column $column" : "line: $line, column: $column"; $msg = "$msg: $loc"; $callStackMsg = $this->callStackMessage(); if ($callStackMsg) { $msg .= "\nCall Stack:\n" . $callStackMsg; } return $msg; } public function errorArgsNumber($functionName, $ExpectedArgs, $nbActual) { @trigger_error(sprintf('The "%s" method is deprecated.', __METHOD__), E_USER_DEPRECATED); $nbExpected = \count($ExpectedArgs); if ($nbActual > $nbExpected) { return $this->error( 'Error: Only %d arguments allowed in %s(), but %d were passed.', $nbExpected, $functionName, $nbActual ); } else { $missing = []; while (count($ExpectedArgs) && count($ExpectedArgs) > $nbActual) { array_unshift($missing, array_pop($ExpectedArgs)); } return $this->error( 'Error: %s() argument%s %s missing.', $functionName, count($missing) > 1 ? 's' : '', implode(', ', $missing) ); } } protected function callStackMessage($all = false, $limit = null) { $callStackMsg = []; $ncall = 0; if ($this->callStack) { foreach (array_reverse($this->callStack) as $call) { if ($all || (isset($call['n']) && $call['n'])) { $msg = '#' . $ncall++ . ' ' . $call['n'] . ' '; $msg .= (isset($this->sourceNames[$call[Parser::SOURCE_INDEX]]) ? $this->getPrettyPath($this->sourceNames[$call[Parser::SOURCE_INDEX]]) : '(unknown file)'); $msg .= ' on line ' . $call[Parser::SOURCE_LINE]; $callStackMsg[] = $msg; if (! \is_null($limit) && $ncall > $limit) { break; } } } } return implode("\n", $callStackMsg); } protected function handleImportLoop($name) { for ($env = $this->env; $env; $env = $env->parent) { if (! $env->block) { continue; } $file = $this->sourceNames[$env->block->sourceIndex]; if ($file === null) { continue; } if (realpath($file) === $name) { throw $this->error('An @import loop has been found: %s imports %s', $file, basename($file)); } } } protected function callScssFunction($func, $argValues) { if (! $func) { return static::$defaultValue; } $name = $func->name; $this->pushEnv(); if (isset($func->args)) { $this->applyArguments($func->args, $argValues); } $tmp = new OutputBlock(); $tmp->lines = []; $tmp->children = []; $this->env->marker = 'function'; if (! empty($func->parentEnv)) { $this->env->declarationScopeParent = $func->parentEnv; } else { throw $this->error("@function $name() without parentEnv"); } $ret = $this->compileChildren($func->children, $tmp, $this->env->marker . ' ' . $name); $this->popEnv(); return ! isset($ret) ? static::$defaultValue : $ret; } protected function callNativeFunction($name, $function, $prototype, $args) { $libName = (is_array($function) ? end($function) : null); $sorted_kwargs = $this->sortNativeFunctionArgs($libName, $prototype, $args); if (\is_null($sorted_kwargs)) { return null; } @list($sorted, $kwargs) = $sorted_kwargs; if ($name !== 'if') { foreach ($sorted as &$val) { if ($val !== null) { $val = $this->reduce($val, true); } } } $returnValue = \call_user_func($function, $sorted, $kwargs); if (! isset($returnValue)) { return null; } if (\is_array($returnValue) || $returnValue instanceof Number) { return $returnValue; } @trigger_error(sprintf('Returning a PHP value from the "%s" custom function is deprecated. A sass value must be returned instead.', $name), E_USER_DEPRECATED); return $this->coerceValue($returnValue); } protected function getBuiltinFunction($name) { $libName = self::normalizeNativeFunctionName($name); return [$this, $libName]; } public static function normalizeNativeFunctionName($name) { $name = str_replace("-", "_", $name); $libName = 'lib' . preg_replace_callback( '/_(.)/', function ($m) { return ucfirst($m[1]); }, ucfirst($name) ); return $libName; } public static function isNativeFunction($name) { return method_exists(Compiler::class, self::normalizeNativeFunctionName($name)); } protected function sortNativeFunctionArgs($functionName, $prototypes, $args) { static $parser = null; if (! isset($prototypes)) { $keyArgs = []; $posArgs = []; if (\is_array($args) && \count($args) && \end($args) === static::$null) { array_pop($args); } foreach ($args as $arg) { list($key, $value) = $arg; if (empty($key) or empty($key[1])) { $posArgs[] = empty($arg[2]) ? $value : $arg; } else { $keyArgs[$key[1]] = $value; } } return [$posArgs, $keyArgs]; } if (\in_array($functionName, ['libRgb', 'libRgba', 'libHsl', 'libHsla'])) { foreach ($args as $k => $arg) { if (!isset($arg[1])) { continue; } if ($arg[1][0] === Type::T_LIST && \count($arg[1][2]) === 3) { $args[$k][1][2] = $this->extractSlashAlphaInColorFunction($arg[1][2]); } } } list($positionalArgs, $namedArgs, $names, $separator, $hasSplat) = $this->evaluateArguments($args, false); if (! \is_array(reset($prototypes))) { $prototypes = [$prototypes]; } $parsedPrototypes = array_map([$this, 'parseFunctionPrototype'], $prototypes); assert(!empty($parsedPrototypes)); $matchedPrototype = $this->selectFunctionPrototype($parsedPrototypes, \count($positionalArgs), $names); $this->verifyPrototype($matchedPrototype, \count($positionalArgs), $names, $hasSplat); $vars = $this->applyArgumentsToDeclaration($matchedPrototype, $positionalArgs, $namedArgs, $separator); $finalArgs = []; $keyArgs = []; foreach ($matchedPrototype['arguments'] as $argument) { list($normalizedName, $originalName, $default) = $argument; if (isset($vars[$normalizedName])) { $value = $vars[$normalizedName]; } else { $value = $default; } if ($value === [Type::T_KEYWORD, 'null']) { $value = null; } $finalArgs[] = $value; $keyArgs[$originalName] = $value; } if ($matchedPrototype['rest_argument'] !== null) { $value = $vars[$matchedPrototype['rest_argument']]; $finalArgs[] = $value; $keyArgs[$matchedPrototype['rest_argument']] = $value; } return [$finalArgs, $keyArgs]; } private function parseFunctionPrototype(array $prototype) { static $parser = null; $arguments = []; $restArgument = null; foreach ($prototype as $p) { if (null !== $restArgument) { throw new \InvalidArgumentException('The argument declaration is invalid. The rest argument must be the last one.'); } $default = null; $p = explode(':', $p, 2); $name = str_replace('_', '-', $p[0]); if (isset($p[1])) { $defaultSource = trim($p[1]); if ($defaultSource === 'null') { $default = [Type::T_KEYWORD, 'null']; } else { if (\is_null($parser)) { $parser = $this->parserFactory(__METHOD__); } $parser->parseValue($defaultSource, $default); } } if (substr($name, -3) === '...') { $restArgument = substr($name, 0, -3); } else { $arguments[] = [$name, $p[0], $default]; } } return [ 'arguments' => $arguments, 'rest_argument' => $restArgument, ]; } private function selectFunctionPrototype(array $prototypes, $positional, array $names) { $fuzzyMatch = null; $minMismatchDistance = null; foreach ($prototypes as $prototype) { if ($this->checkPrototypeMatches($prototype, $positional, $names)) { return $prototype; } $mismatchDistance = \count($prototype['arguments']) - $positional; if ($minMismatchDistance !== null) { if (abs($mismatchDistance) > abs($minMismatchDistance)) { continue; } if (abs($mismatchDistance) === abs($minMismatchDistance) && $mismatchDistance < 0) { continue; } } $minMismatchDistance = $mismatchDistance; $fuzzyMatch = $prototype; } return $fuzzyMatch; } private function checkPrototypeMatches(array $prototype, $positional, array $names) { $nameUsed = 0; foreach ($prototype['arguments'] as $i => $argument) { list ($name, $originalName, $default) = $argument; if ($i < $positional) { if (isset($names[$name])) { return false; } } elseif (isset($names[$name])) { $nameUsed++; } elseif ($default === null) { return false; } } if ($prototype['rest_argument'] !== null) { return true; } if ($positional > \count($prototype['arguments'])) { return false; } if ($nameUsed < \count($names)) { return false; } return true; } private function verifyPrototype(array $prototype, $positional, array $names, $hasSplat) { $nameUsed = 0; foreach ($prototype['arguments'] as $i => $argument) { list ($name, $originalName, $default) = $argument; if ($i < $positional) { if (isset($names[$name])) { throw new SassScriptException(sprintf('Argument $%s was passed both by position and by name.', $originalName)); } } elseif (isset($names[$name])) { $nameUsed++; } elseif ($default === null) { throw new SassScriptException(sprintf('Missing argument $%s', $originalName)); } } if ($prototype['rest_argument'] !== null) { return; } if ($positional > \count($prototype['arguments'])) { $message = sprintf( 'Only %d %sargument%s allowed, but %d %s passed.', \count($prototype['arguments']), empty($names) ? '' : 'positional ', \count($prototype['arguments']) === 1 ? '' : 's', $positional, $positional === 1 ? 'was' : 'were' ); if (!$hasSplat) { throw new SassScriptException($message); } $message = $this->addLocationToMessage($message); $message .= "\nThis will be an error in future versions of Sass."; $this->logger->warn($message, true); } if ($nameUsed < \count($names)) { $unknownNames = array_values(array_diff($names, array_column($prototype['arguments'], 0))); $lastName = array_pop($unknownNames); $message = sprintf( 'No argument%s named $%s%s.', $unknownNames ? 's' : '', $unknownNames ? implode(', $', $unknownNames) . ' or $' : '', $lastName ); throw new SassScriptException($message); } } private function evaluateArguments(array $args, $reduce = true) { if (\count($args) && end($args) === static::$null) { array_pop($args); } $splatSeparator = null; $keywordArgs = []; $names = []; $positionalArgs = []; $hasKeywordArgument = false; $hasSplat = false; foreach ($args as $arg) { if (!empty($arg[0])) { $hasKeywordArgument = true; assert(\is_string($arg[0][1])); $name = str_replace('_', '-', $arg[0][1]); if (isset($keywordArgs[$name])) { throw new SassScriptException(sprintf('Duplicate named argument $%s.', $arg[0][1])); } $keywordArgs[$name] = $this->maybeReduce($reduce, $arg[1]); $names[$name] = $name; } elseif (! empty($arg[2])) { $val = $this->reduce($arg[1], true); $hasSplat = true; if ($val[0] === Type::T_LIST) { foreach ($val[2] as $item) { if (\is_null($splatSeparator)) { $splatSeparator = $val[1]; } $positionalArgs[] = $this->maybeReduce($reduce, $item); } if (isset($val[3]) && \is_array($val[3])) { foreach ($val[3] as $name => $item) { assert(\is_string($name)); $normalizedName = str_replace('_', '-', $name); if (isset($keywordArgs[$normalizedName])) { throw new SassScriptException(sprintf('Duplicate named argument $%s.', $name)); } $keywordArgs[$normalizedName] = $this->maybeReduce($reduce, $item); $names[$normalizedName] = $normalizedName; $hasKeywordArgument = true; } } } elseif ($val[0] === Type::T_MAP) { foreach ($val[1] as $i => $name) { $name = $this->compileStringContent($this->coerceString($name)); $item = $val[2][$i]; if (! is_numeric($name)) { $normalizedName = str_replace('_', '-', $name); if (isset($keywordArgs[$normalizedName])) { throw new SassScriptException(sprintf('Duplicate named argument $%s.', $name)); } $keywordArgs[$normalizedName] = $this->maybeReduce($reduce, $item); $names[$normalizedName] = $normalizedName; $hasKeywordArgument = true; } else { if (\is_null($splatSeparator)) { $splatSeparator = $val[1]; } $positionalArgs[] = $this->maybeReduce($reduce, $item); } } } elseif ($val[0] !== Type::T_NULL) { $positionalArgs[] = $this->maybeReduce($reduce, $val); } } elseif ($hasKeywordArgument) { throw new SassScriptException('Positional arguments must come before keyword arguments.'); } else { $positionalArgs[] = $this->maybeReduce($reduce, $arg[1]); } } return [$positionalArgs, $keywordArgs, $names, $splatSeparator, $hasSplat]; } private function maybeReduce($reduce, $value) { if ($reduce) { return $this->reduce($value, true); } return $value; } protected function applyArguments($argDef, $argValues, $storeInEnv = true, $reduce = true) { $output = []; if (\is_null($argValues)) { $argValues = []; } if ($storeInEnv) { $storeEnv = $this->getStoreEnv(); $env = new Environment(); $env->store = $storeEnv->store; } $prototype = ['arguments' => [], 'rest_argument' => null]; $originalRestArgumentName = null; foreach ($argDef as $arg) { list($name, $default, $isVariable) = $arg; $normalizedName = str_replace('_', '-', $name); if ($isVariable) { $originalRestArgumentName = $name; $prototype['rest_argument'] = $normalizedName; } else { $prototype['arguments'][] = [$normalizedName, $name, !empty($default) ? $default : null]; } } list($positionalArgs, $namedArgs, $names, $splatSeparator, $hasSplat) = $this->evaluateArguments($argValues, $reduce); $this->verifyPrototype($prototype, \count($positionalArgs), $names, $hasSplat); $vars = $this->applyArgumentsToDeclaration($prototype, $positionalArgs, $namedArgs, $splatSeparator); foreach ($prototype['arguments'] as $argument) { list($normalizedName, $name) = $argument; if (!isset($vars[$normalizedName])) { continue; } $val = $vars[$normalizedName]; if ($storeInEnv) { $this->set($name, $this->reduce($val, true), true, $env); } else { $output[$name] = ($reduce ? $this->reduce($val, true) : $val); } } if ($prototype['rest_argument'] !== null) { assert($originalRestArgumentName !== null); $name = $originalRestArgumentName; $val = $vars[$prototype['rest_argument']]; if ($storeInEnv) { $this->set($name, $this->reduce($val, true), true, $env); } else { $output[$name] = ($reduce ? $this->reduce($val, true) : $val); } } if ($storeInEnv) { $storeEnv->store = $env->store; } foreach ($prototype['arguments'] as $argument) { list($normalizedName, $name, $default) = $argument; if (isset($vars[$normalizedName])) { continue; } assert($default !== null); if ($storeInEnv) { $this->set($name, $this->reduce($default, true), true); } else { $output[$name] = ($reduce ? $this->reduce($default, true) : $default); } } return $output; } private function applyArgumentsToDeclaration(array $prototype, array $positionalArgs, array $namedArgs, $splatSeparator) { $output = []; $minLength = min(\count($positionalArgs), \count($prototype['arguments'])); for ($i = 0; $i < $minLength; $i++) { list($name) = $prototype['arguments'][$i]; $val = $positionalArgs[$i]; $output[$name] = $val; } $restNamed = $namedArgs; for ($i = \count($positionalArgs); $i < \count($prototype['arguments']); $i++) { $argument = $prototype['arguments'][$i]; list($name) = $argument; if (isset($namedArgs[$name])) { $val = $namedArgs[$name]; unset($restNamed[$name]); } else { continue; } $output[$name] = $val; } if ($prototype['rest_argument'] !== null) { $name = $prototype['rest_argument']; $rest = array_values(array_slice($positionalArgs, \count($prototype['arguments']))); $val = [Type::T_LIST, \is_null($splatSeparator) ? ',' : $splatSeparator , $rest, $restNamed]; $output[$name] = $val; } return $output; } protected function coerceValue($value) { if (\is_array($value) || $value instanceof Number) { return $value; } if (\is_bool($value)) { return $this->toBool($value); } if (\is_null($value)) { return static::$null; } if (is_numeric($value)) { return new Number($value, ''); } if ($value === '') { return static::$emptyString; } $value = [Type::T_KEYWORD, $value]; $color = $this->coerceColor($value); if ($color) { return $color; } return $value; } private function tryMap($item) { if ($item instanceof Number) { return null; } if ($item[0] === Type::T_MAP) { return $item; } if ( $item[0] === Type::T_LIST && $item[2] === [] ) { return static::$emptyMap; } return null; } protected function coerceMap($item) { $map = $this->tryMap($item); if ($map !== null) { return $map; } return $item; } protected function coerceList($item, $delim = ',', $removeTrailingNull = false) { if ($item instanceof Number) { return [Type::T_LIST, '', [$item]]; } if ($item[0] === Type::T_LIST) { if ($removeTrailingNull && end($item[2]) === static::$null) { array_pop($item[2]); } return $item; } if ($item[0] === Type::T_MAP) { $keys = $item[1]; $values = $item[2]; $list = []; for ($i = 0, $s = \count($keys); $i < $s; $i++) { $key = $keys[$i]; $value = $values[$i]; $list[] = [ Type::T_LIST, ' ', [$key, $value] ]; } return [Type::T_LIST, $list ? ',' : '', $list]; } return [Type::T_LIST, '', [$item]]; } protected function coerceForExpression($value) { if ($color = $this->coerceColor($value)) { return $color; } return $value; } protected function coerceColor($value, $inRGBFunction = false) { if ($value instanceof Number) { return null; } switch ($value[0]) { case Type::T_COLOR: for ($i = 1; $i <= 3; $i++) { if (! is_numeric($value[$i])) { $cv = $this->compileRGBAValue($value[$i]); if (! is_numeric($cv)) { return null; } $value[$i] = $cv; } if (isset($value[4])) { if (! is_numeric($value[4])) { $cv = $this->compileRGBAValue($value[4], true); if (! is_numeric($cv)) { return null; } $value[4] = $cv; } } } return $value; case Type::T_LIST: if ($inRGBFunction) { if (\count($value[2]) == 3 || \count($value[2]) == 4) { $color = $value[2]; array_unshift($color, Type::T_COLOR); return $this->coerceColor($color); } } return null; case Type::T_KEYWORD: if (! \is_string($value[1])) { return null; } $name = strtolower($value[1]); if (preg_match('/^#([0-9a-f]+)$/i', $name, $m)) { $nofValues = \strlen($m[1]); if (\in_array($nofValues, [3, 4, 6, 8])) { $nbChannels = 3; $color = []; $num = hexdec($m[1]); switch ($nofValues) { case 4: $nbChannels = 4; case 3: for ($i = 0; $i < $nbChannels; $i++) { $t = $num & 0xf; array_unshift($color, $t << 4 | $t); $num >>= 4; } break; case 8: $nbChannels = 4; case 6: for ($i = 0; $i < $nbChannels; $i++) { array_unshift($color, $num & 0xff); $num >>= 8; } break; } if ($nbChannels === 4) { if ($color[3] === 255) { $color[3] = 1; } else { $color[3] = round($color[3] / 255, Number::PRECISION); } } array_unshift($color, Type::T_COLOR); return $color; } } if ($rgba = Colors::colorNameToRGBa($name)) { return isset($rgba[3]) ? [Type::T_COLOR, $rgba[0], $rgba[1], $rgba[2], $rgba[3]] : [Type::T_COLOR, $rgba[0], $rgba[1], $rgba[2]]; } return null; } return null; } protected function compileRGBAValue($value, $isAlpha = false) { if ($isAlpha) { return $this->compileColorPartValue($value, 0, 1, false); } return $this->compileColorPartValue($value, 0, 255, true); } protected function compileColorPartValue($value, $min, $max, $isInt = true) { if (! is_numeric($value)) { if (\is_array($value)) { $reduced = $this->reduce($value); if ($reduced instanceof Number) { $value = $reduced; } } if ($value instanceof Number) { if ($value->unitless()) { $num = $value->getDimension(); } elseif ($value->hasUnit('%')) { $num = $max * $value->getDimension() / 100; } else { throw $this->error('Expected %s to have no units or "%%".', $value); } $value = $num; } elseif (\is_array($value)) { $value = $this->compileValue($value); } } if (is_numeric($value)) { if ($isInt) { $value = round($value); } $value = min($max, max($min, $value)); return $value; } return $value; } protected function coerceString($value) { if ($value[0] === Type::T_STRING) { assert(\is_array($value)); return $value; } return [Type::T_STRING, '', [$this->compileValue($value)]]; } public function assertString($value, $varName = null) { if ($value[0] === Type::T_FUNCTION) { $value = $this->coerceString($value); } if (! \in_array($value[0], [Type::T_STRING, Type::T_KEYWORD])) { $value = $this->compileValue($value); throw SassScriptException::forArgument("$value is not a string.", $varName); } return $this->coerceString($value); } protected function coercePercent($value) { @trigger_error(sprintf('"%s" is deprecated since 1.7.0.', __METHOD__), E_USER_DEPRECATED); if ($value instanceof Number) { if ($value->hasUnit('%')) { return $value->getDimension() / 100; } return $value->getDimension(); } return 0; } public function assertMap($value, $varName = null) { $map = $this->tryMap($value); if ($map === null) { $value = $this->compileValue($value); throw SassScriptException::forArgument("$value is not a map.", $varName); } return $map; } public function assertList($value) { if ($value[0] !== Type::T_LIST) { throw $this->error('expecting list, %s received', $value[0]); } assert(\is_array($value)); return $value; } public function getArgumentListKeywords($value) { if ($value[0] !== Type::T_LIST || !isset($value[3]) || !\is_array($value[3])) { throw new \InvalidArgumentException('The argument is not a sass argument list.'); } return $value[3]; } public function assertColor($value, $varName = null) { if ($color = $this->coerceColor($value)) { return $color; } $value = $this->compileValue($value); throw SassScriptException::forArgument("$value is not a color.", $varName); } public function assertNumber($value, $varName = null) { if (!$value instanceof Number) { $value = $this->compileValue($value); throw SassScriptException::forArgument("$value is not a number.", $varName); } return $value; } public function assertInteger($value, $varName = null) { $value = $this->assertNumber($value, $varName)->getDimension(); if (round($value - \intval($value), Number::PRECISION) > 0) { throw SassScriptException::forArgument("$value is not an integer.", $varName); } return intval($value); } private function extractSlashAlphaInColorFunction($args) { $last = end($args); if (\count($args) === 3 && $last[0] === Type::T_EXPRESSION && $last[1] === '/') { array_pop($args); $args[] = $last[2]; $args[] = $last[3]; } return $args; } protected function fixColor($c) { foreach ([1, 2, 3] as $i) { if ($c[$i] < 0) { $c[$i] = 0; } if ($c[$i] > 255) { $c[$i] = 255; } if (!\is_int($c[$i])) { $c[$i] = round($c[$i]); } } return $c; } public function toHSL($red, $green, $blue) { $min = min($red, $green, $blue); $max = max($red, $green, $blue); $l = $min + $max; $d = $max - $min; if ((int) $d === 0) { $h = $s = 0; } else { if ($l < 255) { $s = $d / $l; } else { $s = $d / (510 - $l); } if ($red == $max) { $h = 60 * ($green - $blue) / $d; } elseif ($green == $max) { $h = 60 * ($blue - $red) / $d + 120; } else { $h = 60 * ($red - $green) / $d + 240; } } return [Type::T_HSL, fmod($h + 360, 360), $s * 100, $l / 5.1]; } protected function hueToRGB($m1, $m2, $h) { if ($h < 0) { $h += 1; } elseif ($h > 1) { $h -= 1; } if ($h * 6 < 1) { return $m1 + ($m2 - $m1) * $h * 6; } if ($h * 2 < 1) { return $m2; } if ($h * 3 < 2) { return $m1 + ($m2 - $m1) * (2 / 3 - $h) * 6; } return $m1; } public function toRGB($hue, $saturation, $lightness) { if ($hue < 0) { $hue += 360; } $h = $hue / 360; $s = min(100, max(0, $saturation)) / 100; $l = min(100, max(0, $lightness)) / 100; $m2 = $l <= 0.5 ? $l * ($s + 1) : $l + $s - $l * $s; $m1 = $l * 2 - $m2; $r = $this->hueToRGB($m1, $m2, $h + 1 / 3) * 255; $g = $this->hueToRGB($m1, $m2, $h) * 255; $b = $this->hueToRGB($m1, $m2, $h - 1 / 3) * 255; $out = [Type::T_COLOR, $r, $g, $b]; return $out; } private function HWBtoRGB($hue, $whiteness, $blackness) { $w = min(100, max(0, $whiteness)) / 100; $b = min(100, max(0, $blackness)) / 100; $sum = $w + $b; if ($sum > 1.0) { $w = $w / $sum; $b = $b / $sum; } $b = min(1.0 - $w, $b); $rgb = $this->toRGB($hue, 100, 50); for($i = 1; $i < 4; $i++) { $rgb[$i] *= (1.0 - $w - $b); $rgb[$i] = round($rgb[$i] + 255 * $w + 0.0001); } return $rgb; } private function RGBtoHWB($red, $green, $blue) { $min = min($red, $green, $blue); $max = max($red, $green, $blue); $d = $max - $min; if ((int) $d === 0) { $h = 0; } else { if ($red == $max) { $h = 60 * ($green - $blue) / $d; } elseif ($green == $max) { $h = 60 * ($blue - $red) / $d + 120; } else { $h = 60 * ($red - $green) / $d + 240; } } return [Type::T_HWB, fmod($h, 360), $min / 255 * 100, 100 - $max / 255 *100]; } protected static $libCall = ['function', 'args...']; protected function libCall($args) { $functionReference = $args[0]; if (in_array($functionReference[0], [Type::T_STRING, Type::T_KEYWORD])) { $name = $this->compileStringContent($this->coerceString($functionReference)); $warning = "Passing a string to call() is deprecated and will be illegal\n" . "in Sass 4.0. Use call(function-reference($name)) instead."; Warn::deprecation($warning); $functionReference = $this->libGetFunction([$this->assertString($functionReference, 'function')]); } if ($functionReference === static::$null) { return static::$null; } if (! in_array($functionReference[0], [Type::T_FUNCTION_REFERENCE, Type::T_FUNCTION])) { throw $this->error('Function reference expected, got ' . $functionReference[0]); } $callArgs = [ [null, $args[1], true] ]; return $this->reduce([Type::T_FUNCTION_CALL, $functionReference, $callArgs]); } protected static $libGetFunction = [ ['name'], ['name', 'css'] ]; protected function libGetFunction($args) { $name = $this->compileStringContent($this->assertString(array_shift($args), 'name')); $isCss = false; if (count($args)) { $isCss = array_shift($args); $isCss = (($isCss === static::$true) ? true : false); } if ($isCss) { return [Type::T_FUNCTION, $name, [Type::T_LIST, ',', []]]; } return $this->getFunctionReference($name, true); } protected static $libIf = ['condition', 'if-true', 'if-false:']; protected function libIf($args) { list($cond, $t, $f) = $args; if (! $this->isTruthy($this->reduce($cond, true))) { return $this->reduce($f, true); } return $this->reduce($t, true); } protected static $libIndex = ['list', 'value']; protected function libIndex($args) { list($list, $value) = $args; if ( $list[0] === Type::T_MAP || $list[0] === Type::T_STRING || $list[0] === Type::T_KEYWORD || $list[0] === Type::T_INTERPOLATE ) { $list = $this->coerceList($list, ' '); } if ($list[0] !== Type::T_LIST) { return static::$null; } if ($value instanceof Number) { $key = 0; foreach ($list[2] as $item) { $key++; $itemValue = $this->normalizeValue($item); if ($itemValue instanceof Number && $value->equals($itemValue)) { return new Number($key, ''); } } return static::$null; } $values = []; foreach ($list[2] as $item) { $values[] = $this->normalizeValue($item); } $key = array_search($this->normalizeValue($value), $values); return false === $key ? static::$null : new Number($key + 1, ''); } protected static $libRgb = [ ['color'], ['color', 'alpha'], ['channels'], ['red', 'green', 'blue'], ['red', 'green', 'blue', 'alpha'] ]; protected function libRgb($args, $kwargs, $funcName = 'rgb') { switch (\count($args)) { case 1: if (! $color = $this->coerceColor($args[0], true)) { $color = [Type::T_STRING, '', [$funcName . '(', $args[0], ')']]; } break; case 3: $color = [Type::T_COLOR, $args[0], $args[1], $args[2]]; if (! $color = $this->coerceColor($color)) { $color = [Type::T_STRING, '', [$funcName . '(', $args[0], ', ', $args[1], ', ', $args[2], ')']]; } return $color; case 2: if ($color = $this->coerceColor($args[0], true)) { $alpha = $this->compileRGBAValue($args[1], true); if (is_numeric($alpha)) { $color[4] = $alpha; } else { $color = [Type::T_STRING, '', [$funcName . '(', $color[1], ', ', $color[2], ', ', $color[3], ', ', $alpha, ')']]; } } else { $color = [Type::T_STRING, '', [$funcName . '(', $args[0], ', ', $args[1], ')']]; } break; case 4: default: $color = [Type::T_COLOR, $args[0], $args[1], $args[2], $args[3]]; if (! $color = $this->coerceColor($color)) { $color = [Type::T_STRING, '', [$funcName . '(', $args[0], ', ', $args[1], ', ', $args[2], ', ', $args[3], ')']]; } break; } return $color; } protected static $libRgba = [ ['color'], ['color', 'alpha'], ['channels'], ['red', 'green', 'blue'], ['red', 'green', 'blue', 'alpha'] ]; protected function libRgba($args, $kwargs) { return $this->libRgb($args, $kwargs, 'rgba'); } protected function alterColor(array $args, $operation, $fn) { $color = $this->assertColor($args[0], 'color'); if ($args[1][2]) { throw new SassScriptException('Only one positional argument is allowed. All other arguments must be passed by name.'); } $kwargs = $this->getArgumentListKeywords($args[1]); $scale = $operation === 'scale'; $change = $operation === 'change'; $getParam = function ($name, $max, $checkPercent = false, $assertPercent = false) use (&$kwargs, $scale, $change) { if (!isset($kwargs[$name])) { return null; } $number = $this->assertNumber($kwargs[$name], $name); unset($kwargs[$name]); if (!$scale && $checkPercent) { if (!$number->hasUnit('%')) { $warning = $this->error("{$name} Passing a number `$number` without unit % is deprecated."); $this->logger->warn($warning->getMessage(), true); } } if ($scale || $assertPercent) { $number->assertUnit('%', $name); } if ($scale) { $max = 100; } return $number->valueInRange($change ? 0 : -$max, $max, $name); }; $alpha = $getParam('alpha', 1); $red = $getParam('red', 255); $green = $getParam('green', 255); $blue = $getParam('blue', 255); if ($scale || !isset($kwargs['hue'])) { $hue = null; } else { $hueNumber = $this->assertNumber($kwargs['hue'], 'hue'); unset($kwargs['hue']); $hue = $hueNumber->getDimension(); } $saturation = $getParam('saturation', 100, true); $lightness = $getParam('lightness', 100, true); $whiteness = $getParam('whiteness', 100, false, true); $blackness = $getParam('blackness', 100, false, true); if (!empty($kwargs)) { $unknownNames = array_keys($kwargs); $lastName = array_pop($unknownNames); $message = sprintf( 'No argument%s named $%s%s.', $unknownNames ? 's' : '', $unknownNames ? implode(', $', $unknownNames) . ' or $' : '', $lastName ); throw new SassScriptException($message); } $hasRgb = $red !== null || $green !== null || $blue !== null; $hasSL = $saturation !== null || $lightness !== null; $hasWB = $whiteness !== null || $blackness !== null; if ($hasRgb && ($hasSL || $hasWB || $hue !== null)) { throw new SassScriptException(sprintf('RGB parameters may not be passed along with %s parameters.', $hasWB ? 'HWB' : 'HSL')); } if ($hasWB && $hasSL) { throw new SassScriptException('HSL parameters may not be passed along with HWB parameters.'); } if ($hasRgb) { $color[1] = round($fn($color[1], $red, 255)); $color[2] = round($fn($color[2], $green, 255)); $color[3] = round($fn($color[3], $blue, 255)); } elseif ($hasWB) { $hwb = $this->RGBtoHWB($color[1], $color[2], $color[3]); if ($hue !== null) { $hwb[1] = $change ? $hue : $hwb[1] + $hue; } $hwb[2] = $fn($hwb[2], $whiteness, 100); $hwb[3] = $fn($hwb[3], $blackness, 100); $rgb = $this->HWBtoRGB($hwb[1], $hwb[2], $hwb[3]); if (isset($color[4])) { $rgb[4] = $color[4]; } $color = $rgb; } elseif ($hue !== null || $hasSL) { $hsl = $this->toHSL($color[1], $color[2], $color[3]); if ($hue !== null) { $hsl[1] = $change ? $hue : $hsl[1] + $hue; } $hsl[2] = $fn($hsl[2], $saturation, 100); $hsl[3] = $fn($hsl[3], $lightness, 100); $rgb = $this->toRGB($hsl[1], $hsl[2], $hsl[3]); if (isset($color[4])) { $rgb[4] = $color[4]; } $color = $rgb; } if ($alpha !== null) { $existingAlpha = isset($color[4]) ? $color[4] : 1; $color[4] = $fn($existingAlpha, $alpha, 1); } return $color; } protected static $libAdjustColor = ['color', 'kwargs...']; protected function libAdjustColor($args) { return $this->alterColor($args, 'adjust', function ($base, $alter, $max) { if ($alter === null) { return $base; } $new = $base + $alter; if ($new < 0) { return 0; } if ($new > $max) { return $max; } return $new; }); } protected static $libChangeColor = ['color', 'kwargs...']; protected function libChangeColor($args) { return $this->alterColor($args,'change', function ($base, $alter, $max) { if ($alter === null) { return $base; } return $alter; }); } protected static $libScaleColor = ['color', 'kwargs...']; protected function libScaleColor($args) { return $this->alterColor($args, 'scale', function ($base, $scale, $max) { if ($scale === null) { return $base; } $scale = $scale / 100; if ($scale < 0) { return $base * $scale + $base; } return ($max - $base) * $scale + $base; }); } protected static $libIeHexStr = ['color']; protected function libIeHexStr($args) { $color = $this->coerceColor($args[0]); if (\is_null($color)) { throw $this->error('Error: argument `$color` of `ie-hex-str($color)` must be a color'); } $color[4] = isset($color[4]) ? round(255 * $color[4]) : 255; return [Type::T_STRING, '', [sprintf('#%02X%02X%02X%02X', $color[4], $color[1], $color[2], $color[3])]]; } protected static $libRed = ['color']; protected function libRed($args) { $color = $this->coerceColor($args[0]); if (\is_null($color)) { throw $this->error('Error: argument `$color` of `red($color)` must be a color'); } return new Number((int) $color[1], ''); } protected static $libGreen = ['color']; protected function libGreen($args) { $color = $this->coerceColor($args[0]); if (\is_null($color)) { throw $this->error('Error: argument `$color` of `green($color)` must be a color'); } return new Number((int) $color[2], ''); } protected static $libBlue = ['color']; protected function libBlue($args) { $color = $this->coerceColor($args[0]); if (\is_null($color)) { throw $this->error('Error: argument `$color` of `blue($color)` must be a color'); } return new Number((int) $color[3], ''); } protected static $libAlpha = ['color']; protected function libAlpha($args) { if ($color = $this->coerceColor($args[0])) { return new Number(isset($color[4]) ? $color[4] : 1, ''); } return null; } protected static $libOpacity = ['color']; protected function libOpacity($args) { $value = $args[0]; if ($value instanceof Number) { return null; } return $this->libAlpha($args); } protected static $libMix = [ ['color1', 'color2', 'weight:50%'], ['color-1', 'color-2', 'weight:50%'] ]; protected function libMix($args) { list($first, $second, $weight) = $args; $first = $this->assertColor($first, 'color1'); $second = $this->assertColor($second, 'color2'); $weightScale = $this->assertNumber($weight, 'weight')->valueInRange(0, 100, 'weight') / 100; $firstAlpha = isset($first[4]) ? $first[4] : 1; $secondAlpha = isset($second[4]) ? $second[4] : 1; $normalizedWeight = $weightScale * 2 - 1; $alphaDistance = $firstAlpha - $secondAlpha; $combinedWeight = $normalizedWeight * $alphaDistance == -1 ? $normalizedWeight : ($normalizedWeight + $alphaDistance) / (1 + $normalizedWeight * $alphaDistance); $weight1 = ($combinedWeight + 1) / 2.0; $weight2 = 1.0 - $weight1; $new = [Type::T_COLOR, $weight1 * $first[1] + $weight2 * $second[1], $weight1 * $first[2] + $weight2 * $second[2], $weight1 * $first[3] + $weight2 * $second[3], ]; if ($firstAlpha != 1.0 || $secondAlpha != 1.0) { $new[] = $firstAlpha * $weightScale + $secondAlpha * (1 - $weightScale); } return $this->fixColor($new); } protected static $libHsl = [ ['channels'], ['hue', 'saturation'], ['hue', 'saturation', 'lightness'], ['hue', 'saturation', 'lightness', 'alpha'] ]; protected function libHsl($args, $kwargs, $funcName = 'hsl') { $args_to_check = $args; if (\count($args) == 1) { if ($args[0][0] !== Type::T_LIST || \count($args[0][2]) < 3 || \count($args[0][2]) > 4) { return [Type::T_STRING, '', [$funcName . '(', $args[0], ')']]; } $args = $args[0][2]; $args_to_check = $kwargs['channels'][2]; } if (\count($args) === 2) { foreach ($args as $arg) { if ($arg[0] === Type::T_FUNCTION && in_array($arg[1], ['var'])) { return null; } } throw new SassScriptException('Missing argument $lightness.'); } foreach ($kwargs as $arg) { if (in_array($arg[0], [Type::T_FUNCTION_CALL, Type::T_FUNCTION]) && in_array($arg[1], ['min', 'max'])) { return null; } } foreach ($args_to_check as $k => $arg) { if (in_array($arg[0], [Type::T_FUNCTION_CALL, Type::T_FUNCTION]) && in_array($arg[1], ['min', 'max'])) { if (count($kwargs) > 1 || ($k >= 2 && count($args) === 4)) { return null; } $args[$k] = $this->stringifyFncallArgs($arg); } if ( $k >= 2 && count($args) === 4 && in_array($arg[0], [Type::T_FUNCTION_CALL, Type::T_FUNCTION]) && in_array($arg[1], ['calc','env']) ) { return null; } } $hue = $this->reduce($args[0]); $saturation = $this->reduce($args[1]); $lightness = $this->reduce($args[2]); $alpha = null; if (\count($args) === 4) { $alpha = $this->compileColorPartValue($args[3], 0, 100, false); if (!$hue instanceof Number || !$saturation instanceof Number || ! $lightness instanceof Number || ! is_numeric($alpha)) { return [Type::T_STRING, '', [$funcName . '(', $args[0], ', ', $args[1], ', ', $args[2], ', ', $args[3], ')']]; } } else { if (!$hue instanceof Number || !$saturation instanceof Number || ! $lightness instanceof Number) { return [Type::T_STRING, '', [$funcName . '(', $args[0], ', ', $args[1], ', ', $args[2], ')']]; } } $hueValue = fmod($hue->getDimension(), 360); while ($hueValue < 0) { $hueValue += 360; } $color = $this->toRGB($hueValue, max(0, min($saturation->getDimension(), 100)), max(0, min($lightness->getDimension(), 100))); if (! \is_null($alpha)) { $color[4] = $alpha; } return $color; } protected static $libHsla = [ ['channels'], ['hue', 'saturation'], ['hue', 'saturation', 'lightness'], ['hue', 'saturation', 'lightness', 'alpha']]; protected function libHsla($args, $kwargs) { return $this->libHsl($args, $kwargs, 'hsla'); } protected static $libHue = ['color']; protected function libHue($args) { $color = $this->assertColor($args[0], 'color'); $hsl = $this->toHSL($color[1], $color[2], $color[3]); return new Number($hsl[1], 'deg'); } protected static $libSaturation = ['color']; protected function libSaturation($args) { $color = $this->assertColor($args[0], 'color'); $hsl = $this->toHSL($color[1], $color[2], $color[3]); return new Number($hsl[2], '%'); } protected static $libLightness = ['color']; protected function libLightness($args) { $color = $this->assertColor($args[0], 'color'); $hsl = $this->toHSL($color[1], $color[2], $color[3]); return new Number($hsl[3], '%'); } protected function adjustHsl($color, $idx, $amount) { $hsl = $this->toHSL($color[1], $color[2], $color[3]); $hsl[$idx] += $amount; if ($idx !== 1) { $hsl[$idx] = min(max(0, $hsl[$idx]), 100); } $out = $this->toRGB($hsl[1], $hsl[2], $hsl[3]); if (isset($color[4])) { $out[4] = $color[4]; } return $out; } protected static $libAdjustHue = ['color', 'degrees']; protected function libAdjustHue($args) { $color = $this->assertColor($args[0], 'color'); $degrees = $this->assertNumber($args[1], 'degrees')->getDimension(); return $this->adjustHsl($color, 1, $degrees); } protected static $libLighten = ['color', 'amount']; protected function libLighten($args) { $color = $this->assertColor($args[0], 'color'); $amount = Util::checkRange('amount', new Range(0, 100), $args[1], '%'); return $this->adjustHsl($color, 3, $amount); } protected static $libDarken = ['color', 'amount']; protected function libDarken($args) { $color = $this->assertColor($args[0], 'color'); $amount = Util::checkRange('amount', new Range(0, 100), $args[1], '%'); return $this->adjustHsl($color, 3, -$amount); } protected static $libSaturate = [['color', 'amount'], ['amount']]; protected function libSaturate($args) { $value = $args[0]; if (count($args) === 1) { $this->assertNumber($args[0], 'amount'); return null; } $color = $this->assertColor($args[0], 'color'); $amount = $this->assertNumber($args[1], 'amount'); return $this->adjustHsl($color, 2, $amount->valueInRange(0, 100, 'amount')); } protected static $libDesaturate = ['color', 'amount']; protected function libDesaturate($args) { $color = $this->assertColor($args[0], 'color'); $amount = $this->assertNumber($args[1], 'amount'); return $this->adjustHsl($color, 2, -$amount->valueInRange(0, 100, 'amount')); } protected static $libGrayscale = ['color']; protected function libGrayscale($args) { $value = $args[0]; if ($value instanceof Number) { return null; } return $this->adjustHsl($this->assertColor($value, 'color'), 2, -100); } protected static $libComplement = ['color']; protected function libComplement($args) { return $this->adjustHsl($this->assertColor($args[0], 'color'), 1, 180); } protected static $libInvert = ['color', 'weight:100%']; protected function libInvert($args) { $value = $args[0]; $weight = $this->assertNumber($args[1], 'weight'); if ($value instanceof Number) { if ($weight->getDimension() != 100 || !$weight->hasUnit('%')) { throw new SassScriptException('Only one argument may be passed to the plain-CSS invert() function.'); } return null; } $color = $this->assertColor($value, 'color'); $inverted = $color; $inverted[1] = 255 - $inverted[1]; $inverted[2] = 255 - $inverted[2]; $inverted[3] = 255 - $inverted[3]; return $this->libMix([$inverted, $color, $weight]); } protected static $libOpacify = ['color', 'amount']; protected function libOpacify($args) { $color = $this->assertColor($args[0], 'color'); $amount = $this->assertNumber($args[1], 'amount'); $color[4] = (isset($color[4]) ? $color[4] : 1) + $amount->valueInRange(0, 1, 'amount'); $color[4] = min(1, max(0, $color[4])); return $color; } protected static $libFadeIn = ['color', 'amount']; protected function libFadeIn($args) { return $this->libOpacify($args); } protected static $libTransparentize = ['color', 'amount']; protected function libTransparentize($args) { $color = $this->assertColor($args[0], 'color'); $amount = $this->assertNumber($args[1], 'amount'); $color[4] = (isset($color[4]) ? $color[4] : 1) - $amount->valueInRange(0, 1, 'amount'); $color[4] = min(1, max(0, $color[4])); return $color; } protected static $libFadeOut = ['color', 'amount']; protected function libFadeOut($args) { return $this->libTransparentize($args); } protected static $libUnquote = ['string']; protected function libUnquote($args) { try { $str = $this->assertString($args[0], 'string'); } catch (SassScriptException $e) { $value = $this->compileValue($args[0]); $fname = $this->getPrettyPath($this->sourceNames[$this->sourceIndex]); $line = $this->sourceLine; $message = "Passing $value, a non-string value, to unquote()
will be an error in future versions of Sass.\n         on line $line of $fname"; $this->logger->warn($message, true); return $args[0]; } $str[1] = ''; return $str; } protected static $libQuote = ['string']; protected function libQuote($args) { $value = $this->assertString($args[0], 'string'); $value[1] = '"'; return $value; } protected static $libPercentage = ['number']; protected function libPercentage($args) { $num = $this->assertNumber($args[0], 'number'); $num->assertNoUnits('number'); return new Number($num->getDimension() * 100, '%'); } protected static $libRound = ['number']; protected function libRound($args) { $num = $this->assertNumber($args[0], 'number'); return new Number(round($num->getDimension()), $num->getNumeratorUnits(), $num->getDenominatorUnits()); } protected static $libFloor = ['number']; protected function libFloor($args) { $num = $this->assertNumber($args[0], 'number'); return new Number(floor($num->getDimension()), $num->getNumeratorUnits(), $num->getDenominatorUnits()); } protected static $libCeil = ['number']; protected function libCeil($args) { $num = $this->assertNumber($args[0], 'number'); return new Number(ceil($num->getDimension()), $num->getNumeratorUnits(), $num->getDenominatorUnits()); } protected static $libAbs = ['number']; protected function libAbs($args) { $num = $this->assertNumber($args[0], 'number'); return new Number(abs($num->getDimension()), $num->getNumeratorUnits(), $num->getDenominatorUnits()); } protected static $libMin = ['numbers...']; protected function libMin($args) { $min = null; foreach ($args[0][2] as $arg) { $number = $this->assertNumber($arg); if (\is_null($min) || $min->greaterThan($number)) { $min = $number; } } if (!\is_null($min)) { return $min; } throw $this->error('At least one argument must be passed.'); } protected static $libMax = ['numbers...']; protected function libMax($args) { $max = null; foreach ($args[0][2] as $arg) { $number = $this->assertNumber($arg); if (\is_null($max) || $max->lessThan($number)) { $max = $number; } } if (!\is_null($max)) { return $max; } throw $this->error('At least one argument must be passed.'); } protected static $libLength = ['list']; protected function libLength($args) { $list = $this->coerceList($args[0], ',', true); return new Number(\count($list[2]), ''); } protected static $libListSeparator = ['list']; protected function libListSeparator($args) { if (! \in_array($args[0][0], [Type::T_LIST, Type::T_MAP])) { return [Type::T_KEYWORD, 'space']; } $list = $this->coerceList($args[0]); if ($list[1] === '' && \count($list[2]) <= 1 && empty($list['enclosing'])) { return [Type::T_KEYWORD, 'space']; } if ($list[1] === ',') { return [Type::T_KEYWORD, 'comma']; } if ($list[1] === '/') { return [Type::T_KEYWORD, 'slash']; } return [Type::T_KEYWORD, 'space']; } protected static $libNth = ['list', 'n']; protected function libNth($args) { $list = $this->coerceList($args[0], ',', false); $n = $this->assertInteger($args[1]); if ($n > 0) { $n--; } elseif ($n < 0) { $n += \count($list[2]); } return isset($list[2][$n]) ? $list[2][$n] : static::$defaultValue; } protected static $libSetNth = ['list', 'n', 'value']; protected function libSetNth($args) { $list = $this->coerceList($args[0]); $n = $this->assertInteger($args[1]); if ($n > 0) { $n--; } elseif ($n < 0) { $n += \count($list[2]); } if (! isset($list[2][$n])) { throw $this->error('Invalid argument for "n"'); } $list[2][$n] = $args[2]; return $list; } protected static $libMapGet = ['map', 'key', 'keys...']; protected function libMapGet($args) { $map = $this->assertMap($args[0], 'map'); if (!isset($args[2])) { $args[2] = self::$emptyArgumentList; } $keys = array_merge([$args[1]], $args[2][2]); $value = static::$null; foreach ($keys as $key) { if (!\is_array($map) || $map[0] !== Type::T_MAP) { return static::$null; } $map = $this->mapGet($map, $key); if ($map === null) { return static::$null; } $value = $map; } return $value; } private function mapGet(array $map, $key) { $index = $this->mapGetEntryIndex($map, $key); if ($index !== null) { return $map[2][$index]; } return null; } private function mapGetEntryIndex(array $map, $key) { $key = $this->compileStringContent($this->coerceString($key)); for ($i = \count($map[1]) - 1; $i >= 0; $i--) { if ($key === $this->compileStringContent($this->coerceString($map[1][$i]))) { return $i; } } return null; } protected static $libMapKeys = ['map']; protected function libMapKeys($args) { $map = $this->assertMap($args[0], 'map'); $keys = $map[1]; return [Type::T_LIST, ',', $keys]; } protected static $libMapValues = ['map']; protected function libMapValues($args) { $map = $this->assertMap($args[0], 'map'); $values = $map[2]; return [Type::T_LIST, ',', $values]; } protected static $libMapRemove = [ ['map'], ['map', 'key', 'keys...'], ]; protected function libMapRemove($args) { $map = $this->assertMap($args[0], 'map'); if (\count($args) === 1) { return $map; } $keys = []; $keys[] = $this->compileStringContent($this->coerceString($args[1])); foreach ($args[2][2] as $key) { $keys[] = $this->compileStringContent($this->coerceString($key)); } for ($i = \count($map[1]) - 1; $i >= 0; $i--) { if (in_array($this->compileStringContent($this->coerceString($map[1][$i])), $keys)) { array_splice($map[1], $i, 1); array_splice($map[2], $i, 1); } } return $map; } protected static $libMapHasKey = ['map', 'key', 'keys...']; protected function libMapHasKey($args) { $map = $this->assertMap($args[0], 'map'); if (!isset($args[2])) { $args[2] = self::$emptyArgumentList; } $keys = array_merge([$args[1]], $args[2][2]); $lastKey = array_pop($keys); foreach ($keys as $key) { $value = $this->mapGet($map, $key); if ($value === null || $value instanceof Number || $value[0] !== Type::T_MAP) { return self::$false; } $map = $value; } return $this->toBool($this->mapHasKey($map, $lastKey)); } private function mapHasKey(array $map, $keyValue) { $key = $this->compileStringContent($this->coerceString($keyValue)); for ($i = \count($map[1]) - 1; $i >= 0; $i--) { if ($key === $this->compileStringContent($this->coerceString($map[1][$i]))) { return true; } } return false; } protected static $libMapMerge = [ ['map1', 'map2'], ['map-1', 'map-2'], ['map1', 'args...'] ]; protected function libMapMerge($args) { $map1 = $this->assertMap($args[0], 'map1'); $map2 = $args[1]; $keys = []; if ($map2[0] === Type::T_LIST && isset($map2[3]) && \is_array($map2[3])) { if (\count($map2[2]) === 0) { throw new SassScriptException('Expected $args to contain a key.'); } if (\count($map2[2]) === 1) { throw new SassScriptException('Expected $args to contain a value.'); } $keys = $map2[2]; $map2 = array_pop($keys); } $map2 = $this->assertMap($map2, 'map2'); return $this->modifyMap($map1, $keys, function ($oldValue) use ($map2) { $nestedMap = $this->tryMap($oldValue); if ($nestedMap === null) { return $map2; } return $this->mergeMaps($nestedMap, $map2); }); } private function modifyMap(array $map, array $keys, callable $modify, $addNesting = true) { if ($keys === []) { return $modify($map); } return $this->modifyNestedMap($map, $keys, $modify, $addNesting); } private function modifyNestedMap(array $map, array $keys, callable $modify, $addNesting) { $key = array_shift($keys); $nestedValueIndex = $this->mapGetEntryIndex($map, $key); if ($keys === []) { if ($nestedValueIndex !== null) { $map[2][$nestedValueIndex] = $modify($map[2][$nestedValueIndex]); } else { $map[1][] = $key; $map[2][] = $modify(self::$null); } return $map; } $nestedMap = $nestedValueIndex !== null ? $this->tryMap($map[2][$nestedValueIndex]) : null; if ($nestedMap === null && !$addNesting) { return $map; } if ($nestedMap === null) { $nestedMap = self::$emptyMap; } $newNestedMap = $this->modifyNestedMap($nestedMap, $keys, $modify, $addNesting); if ($nestedValueIndex !== null) { $map[2][$nestedValueIndex] = $newNestedMap; } else { $map[1][] = $key; $map[2][] = $newNestedMap; } return $map; } private function mergeMaps(array $map1, array $map2) { foreach ($map2[1] as $i2 => $key2) { $map1EntryIndex = $this->mapGetEntryIndex($map1, $key2); if ($map1EntryIndex !== null) { $map1[2][$map1EntryIndex] = $map2[2][$i2]; continue; } $map1[1][] = $key2; $map1[2][] = $map2[2][$i2]; } return $map1; } protected static $libKeywords = ['args']; protected function libKeywords($args) { $value = $args[0]; if ($value[0] !== Type::T_LIST || !isset($value[3]) || !\is_array($value[3])) { $compiledValue = $this->compileValue($value); throw SassScriptException::forArgument($compiledValue . ' is not an argument list.', 'args'); } $keys = []; $values = []; foreach ($this->getArgumentListKeywords($value) as $name => $arg) { $keys[] = [Type::T_KEYWORD, $name]; $values[] = $arg; } return [Type::T_MAP, $keys, $values]; } protected static $libIsBracketed = ['list']; protected function libIsBracketed($args) { $list = $args[0]; $this->coerceList($list, ' '); if (! empty($list['enclosing']) && $list['enclosing'] === 'bracket') { return self::$true; } return self::$false; } protected function listSeparatorForJoin($list1, $sep) { @trigger_error(sprintf('The "%s" method is deprecated.', __METHOD__), E_USER_DEPRECATED); if (! isset($sep)) { return $list1[1]; } switch ($this->compileValue($sep)) { case 'comma': return ','; case 'space': return ' '; default: return $list1[1]; } } protected static $libJoin = ['list1', 'list2', 'separator:auto', 'bracketed:auto']; protected function libJoin($args) { list($list1, $list2, $sep, $bracketed) = $args; $list1 = $this->coerceList($list1, ' ', true); $list2 = $this->coerceList($list2, ' ', true); switch ($this->compileStringContent($this->assertString($sep, 'separator'))) { case 'comma': $separator = ','; break; case 'space': $separator = ' '; break; case 'slash': $separator = '/'; break; case 'auto': if ($list1[1] !== '' || count($list1[2]) > 1 || !empty($list1['enclosing']) && $list1['enclosing'] !== 'parent') { $separator = $list1[1] ?: ' '; } elseif ($list2[1] !== '' || count($list2[2]) > 1 || !empty($list2['enclosing']) && $list2['enclosing'] !== 'parent') { $separator = $list2[1] ?: ' '; } else { $separator = ' '; } break; default: throw SassScriptException::forArgument('Must be "space", "comma", "slash", or "auto".', 'separator'); } if ($bracketed === static::$true) { $bracketed = true; } elseif ($bracketed === static::$false) { $bracketed = false; } elseif ($bracketed === [Type::T_KEYWORD, 'auto']) { $bracketed = 'auto'; } elseif ($bracketed === static::$null) { $bracketed = false; } else { $bracketed = $this->compileValue($bracketed); $bracketed = ! ! $bracketed; if ($bracketed === true) { $bracketed = true; } } if ($bracketed === 'auto') { $bracketed = false; if (! empty($list1['enclosing']) && $list1['enclosing'] === 'bracket') { $bracketed = true; } } $res = [Type::T_LIST, $separator, array_merge($list1[2], $list2[2])]; if ($bracketed) { $res['enclosing'] = 'bracket'; } return $res; } protected static $libAppend = ['list', 'val', 'separator:auto']; protected function libAppend($args) { list($list1, $value, $sep) = $args; $list1 = $this->coerceList($list1, ' ', true); switch ($this->compileStringContent($this->assertString($sep, 'separator'))) { case 'comma': $separator = ','; break; case 'space': $separator = ' '; break; case 'slash': $separator = '/'; break; case 'auto': $separator = $list1[1] === '' && \count($list1[2]) <= 1 && (empty($list1['enclosing']) || $list1['enclosing'] === 'parent') ? ' ' : $list1[1]; break; default: throw SassScriptException::forArgument('Must be "space", "comma", "slash", or "auto".', 'separator'); } $res = [Type::T_LIST, $separator, array_merge($list1[2], [$value])]; if (isset($list1['enclosing'])) { $res['enclosing'] = $list1['enclosing']; } return $res; } protected static $libZip = ['lists...']; protected function libZip($args) { $argLists = []; foreach ($args[0][2] as $arg) { $argLists[] = $this->coerceList($arg); } $lists = []; $firstList = array_shift($argLists); $result = [Type::T_LIST, ',', $lists]; if (! \is_null($firstList)) { foreach ($firstList[2] as $key => $item) { $list = [Type::T_LIST, ' ', [$item]]; foreach ($argLists as $arg) { if (isset($arg[2][$key])) { $list[2][] = $arg[2][$key]; } else { break 2; } } $lists[] = $list; } $result[2] = $lists; } else { $result['enclosing'] = 'parent'; } return $result; } protected static $libTypeOf = ['value']; protected function libTypeOf($args) { $value = $args[0]; return [Type::T_KEYWORD, $this->getTypeOf($value)]; } private function getTypeOf($value) { switch ($value[0]) { case Type::T_KEYWORD: if ($value === static::$true || $value === static::$false) { return 'bool'; } if ($this->coerceColor($value)) { return 'color'; } case Type::T_FUNCTION: return 'string'; case Type::T_FUNCTION_REFERENCE: return 'function'; case Type::T_LIST: if (isset($value[3]) && \is_array($value[3])) { return 'arglist'; } default: return $value[0]; } } protected static $libUnit = ['number']; protected function libUnit($args) { $num = $this->assertNumber($args[0], 'number'); return [Type::T_STRING, '"', [$num->unitStr()]]; } protected static $libUnitless = ['number']; protected function libUnitless($args) { $value = $this->assertNumber($args[0], 'number'); return $this->toBool($value->unitless()); } protected static $libComparable = [ ['number1', 'number2'], ['number-1', 'number-2'] ]; protected function libComparable($args) { list($number1, $number2) = $args; if ( ! $number1 instanceof Number || ! $number2 instanceof Number ) { throw $this->error('Invalid argument(s) for "comparable"'); } return $this->toBool($number1->isComparableTo($number2)); } protected static $libStrIndex = ['string', 'substring']; protected function libStrIndex($args) { $string = $this->assertString($args[0], 'string'); $stringContent = $this->compileStringContent($string); $substring = $this->assertString($args[1], 'substring'); $substringContent = $this->compileStringContent($substring); if (! \strlen($substringContent)) { $result = 0; } else { $result = Util::mbStrpos($stringContent, $substringContent); } return $result === false ? static::$null : new Number($result + 1, ''); } protected static $libStrInsert = ['string', 'insert', 'index']; protected function libStrInsert($args) { $string = $this->assertString($args[0], 'string'); $stringContent = $this->compileStringContent($string); $insert = $this->assertString($args[1], 'insert'); $insertContent = $this->compileStringContent($insert); $index = $this->assertInteger($args[2], 'index'); if ($index > 0) { $index = $index - 1; } if ($index < 0) { $index = max(Util::mbStrlen($stringContent) + 1 + $index, 0); } $string[2] = [ Util::mbSubstr($stringContent, 0, $index), $insertContent, Util::mbSubstr($stringContent, $index) ]; return $string; } protected static $libStrLength = ['string']; protected function libStrLength($args) { $string = $this->assertString($args[0], 'string'); $stringContent = $this->compileStringContent($string); return new Number(Util::mbStrlen($stringContent), ''); } protected static $libStrSlice = ['string', 'start-at', 'end-at:-1']; protected function libStrSlice($args) { $string = $this->assertString($args[0], 'string'); $stringContent = $this->compileStringContent($string); $start = $this->assertNumber($args[1], 'start-at'); $start->assertNoUnits('start-at'); $startInt = $this->assertInteger($start, 'start-at'); $end = $this->assertNumber($args[2], 'end-at'); $end->assertNoUnits('end-at'); $endInt = $this->assertInteger($end, 'end-at'); if ($endInt === 0) { return [Type::T_STRING, $string[1], []]; } if ($startInt > 0) { $startInt--; } if ($endInt < 0) { $endInt = Util::mbStrlen($stringContent) + $endInt; } else { $endInt--; } if ($endInt < $startInt) { return [Type::T_STRING, $string[1], []]; } $length = $endInt - $startInt + 1; $string[2] = [Util::mbSubstr($stringContent, $startInt, $length)]; return $string; } protected static $libToLowerCase = ['string']; protected function libToLowerCase($args) { $string = $this->assertString($args[0], 'string'); $stringContent = $this->compileStringContent($string); $string[2] = [$this->stringTransformAsciiOnly($stringContent, 'strtolower')]; return $string; } protected static $libToUpperCase = ['string']; protected function libToUpperCase($args) { $string = $this->assertString($args[0], 'string'); $stringContent = $this->compileStringContent($string); $string[2] = [$this->stringTransformAsciiOnly($stringContent, 'strtoupper')]; return $string; } protected function stringTransformAsciiOnly($stringContent, $filter) { $mblength = Util::mbStrlen($stringContent); if ($mblength === strlen($stringContent)) { return $filter($stringContent); } $filteredString = ""; for ($i = 0; $i < $mblength; $i++) { $char = Util::mbSubstr($stringContent, $i, 1); if (strlen($char) > 1) { $filteredString .= $char; } else { $filteredString .= $filter($char); } } return $filteredString; } protected static $libFeatureExists = ['feature']; protected function libFeatureExists($args) { $string = $this->assertString($args[0], 'feature'); $name = $this->compileStringContent($string); return $this->toBool( \array_key_exists($name, $this->registeredFeatures) ? $this->registeredFeatures[$name] : false ); } protected static $libFunctionExists = ['name']; protected function libFunctionExists($args) { $string = $this->assertString($args[0], 'name'); $name = $this->compileStringContent($string); if ($this->has(static::$namespaces['function'] . $name)) { return self::$true; } $name = $this->normalizeName($name); if (isset($this->userFunctions[$name])) { return self::$true; } $f = $this->getBuiltinFunction($name); return $this->toBool(\is_callable($f)); } protected static $libGlobalVariableExists = ['name']; protected function libGlobalVariableExists($args) { $string = $this->assertString($args[0], 'name'); $name = $this->compileStringContent($string); return $this->toBool($this->has($name, $this->rootEnv)); } protected static $libMixinExists = ['name']; protected function libMixinExists($args) { $string = $this->assertString($args[0], 'name'); $name = $this->compileStringContent($string); return $this->toBool($this->has(static::$namespaces['mixin'] . $name)); } protected static $libVariableExists = ['name']; protected function libVariableExists($args) { $string = $this->assertString($args[0], 'name'); $name = $this->compileStringContent($string); return $this->toBool($this->has($name)); } protected static $libCounter = ['args...']; protected function libCounter($args) { $list = array_map([$this, 'compileValue'], $args[0][2]); return [Type::T_STRING, '', ['counter(' . implode(',', $list) . ')']]; } protected static $libRandom = ['limit:null']; protected function libRandom($args) { if (isset($args[0]) && $args[0] !== static::$null) { $n = $this->assertInteger($args[0], 'limit'); if ($n < 1) { throw new SassScriptException("\$limit: Must be greater than 0, was $n."); } return new Number(mt_rand(1, $n), ''); } $max = mt_getrandmax(); return new Number(mt_rand(0, $max - 1) / $max, ''); } protected static $libUniqueId = []; protected function libUniqueId() { static $id; if (! isset($id)) { $id = PHP_INT_SIZE === 4 ? mt_rand(0, pow(36, 5)) . str_pad(mt_rand(0, pow(36, 5)) % 10000000, 7, '0', STR_PAD_LEFT) : mt_rand(0, pow(36, 8)); } $id += mt_rand(0, 10) + 1; return [Type::T_STRING, '', ['u' . str_pad(base_convert($id, 10, 36), 8, '0', STR_PAD_LEFT)]]; } protected function inspectFormatValue($value, $force_enclosing_display = false) { if ($value === static::$null) { $value = [Type::T_KEYWORD, 'null']; } $stringValue = [$value]; if ($value instanceof Number) { return [Type::T_STRING, '', $stringValue]; } if ($value[0] === Type::T_LIST) { if (end($value[2]) === static::$null) { array_pop($value[2]); $value[2][] = [Type::T_STRING, '', ['']]; $force_enclosing_display = true; } if ( ! empty($value['enclosing']) && ($force_enclosing_display || ($value['enclosing'] === 'bracket') || ! \count($value[2])) ) { $value['enclosing'] = 'forced_' . $value['enclosing']; $force_enclosing_display = true; } elseif (! \count($value[2])) { $value['enclosing'] = 'forced_parent'; } foreach ($value[2] as $k => $listelement) { $value[2][$k] = $this->inspectFormatValue($listelement, $force_enclosing_display); } $stringValue = [$value]; } return [Type::T_STRING, '', $stringValue]; } protected static $libInspect = ['value']; protected function libInspect($args) { $value = $args[0]; return $this->inspectFormatValue($value); } protected function getSelectorArg($arg, $varname = null, $allowParent = false) { static $parser = null; if (\is_null($parser)) { $parser = $this->parserFactory(__METHOD__); } if (! $this->checkSelectorArgType($arg)) { $var_value = $this->compileValue($arg); throw SassScriptException::forArgument("$var_value is not a valid selector: it must be a string, a list of strings, or a list of lists of strings", $varname); } if ($arg[0] === Type::T_STRING) { $arg[1] = ''; } $arg = $this->compileValue($arg); $parsedSelector = []; if ($parser->parseSelector($arg, $parsedSelector, true)) { $selector = $this->evalSelectors($parsedSelector); $gluedSelector = $this->glueFunctionSelectors($selector); if (! $allowParent) { foreach ($gluedSelector as $selector) { foreach ($selector as $s) { if (in_array(static::$selfSelector, $s)) { throw SassScriptException::forArgument("Parent selectors aren't allowed here.", $varname); } } } } return $gluedSelector; } throw SassScriptException::forArgument("expected more input, invalid selector.", $varname); } protected function checkSelectorArgType($arg, $maxDepth = 2) { if ($arg[0] === Type::T_LIST && $maxDepth > 0) { foreach ($arg[2] as $elt) { if (! $this->checkSelectorArgType($elt, $maxDepth - 1)) { return false; } } return true; } if (!in_array($arg[0], [Type::T_STRING, Type::T_KEYWORD])) { return false; } return true; } protected function formatOutputSelector($selectors) { $selectors = $this->collapseSelectorsAsList($selectors); return $selectors; } protected static $libIsSuperselector = ['super', 'sub']; protected function libIsSuperselector($args) { list($super, $sub) = $args; $super = $this->getSelectorArg($super, 'super'); $sub = $this->getSelectorArg($sub, 'sub'); return $this->toBool($this->isSuperSelector($super, $sub)); } protected function isSuperSelector($super, $sub) { if (! $super) { throw $this->error('Invalid super selector for isSuperSelector()'); } if (! $sub) { throw $this->error('Invalid sub selector for isSuperSelector()'); } if (count($sub) > 1) { foreach ($sub as $s) { if (! $this->isSuperSelector($super, [$s])) { return false; } } return true; } if (count($super) > 1) { foreach ($super as $s) { if ($this->isSuperSelector([$s], $sub)) { return true; } } return false; } $super = reset($super); $sub = reset($sub); $i = 0; $nextMustMatch = false; foreach ($super as $node) { $compound = ''; array_walk_recursive( $node, function ($value, $key) use (&$compound) { $compound .= $value; } ); if ($this->isImmediateRelationshipCombinator($compound)) { if ($node !== $sub[$i]) { return false; } $nextMustMatch = true; $i++; } else { while ($i < \count($sub) && ! $this->isSuperPart($node, $sub[$i])) { if ($nextMustMatch) { return false; } $i++; } if ($i >= \count($sub)) { return false; } $nextMustMatch = false; $i++; } } return true; } protected function isSuperPart($superParts, $subParts) { $i = 0; foreach ($superParts as $superPart) { while ($i < \count($subParts) && $subParts[$i] !== $superPart) { $i++; } if ($i >= \count($subParts)) { return false; } $i++; } return true; } protected static $libSelectorAppend = ['selector...']; protected function libSelectorAppend($args) { $args = reset($args); $args = $args[2]; if (\count($args) < 1) { throw $this->error('selector-append() needs at least 1 argument'); } $selectors = []; foreach ($args as $arg) { $selectors[] = $this->getSelectorArg($arg, 'selector'); } return $this->formatOutputSelector($this->selectorAppend($selectors)); } protected function selectorAppend($selectors) { $lastSelectors = array_pop($selectors); if (! $lastSelectors) { throw $this->error('Invalid selector list in selector-append()'); } while (\count($selectors)) { $previousSelectors = array_pop($selectors); if (! $previousSelectors) { throw $this->error('Invalid selector list in selector-append()'); } $appended = []; foreach ($previousSelectors as $previousSelector) { foreach ($lastSelectors as $lastSelector) { $previous = $previousSelector; foreach ($previousSelector as $j => $previousSelectorParts) { foreach ($lastSelector as $lastSelectorParts) { foreach ($lastSelectorParts as $lastSelectorPart) { $previous[$j][] = $lastSelectorPart; } } } $appended[] = $previous; } } $lastSelectors = $appended; } return $lastSelectors; } protected static $libSelectorExtend = [ ['selector', 'extendee', 'extender'], ['selectors', 'extendee', 'extender'] ]; protected function libSelectorExtend($args) { list($selectors, $extendee, $extender) = $args; $selectors = $this->getSelectorArg($selectors, 'selector'); $extendee = $this->getSelectorArg($extendee, 'extendee'); $extender = $this->getSelectorArg($extender, 'extender'); if (! $selectors || ! $extendee || ! $extender) { throw $this->error('selector-extend() invalid arguments'); } $extended = $this->extendOrReplaceSelectors($selectors, $extendee, $extender); return $this->formatOutputSelector($extended); } protected static $libSelectorReplace = [ ['selector', 'original', 'replacement'], ['selectors', 'original', 'replacement'] ]; protected function libSelectorReplace($args) { list($selectors, $original, $replacement) = $args; $selectors = $this->getSelectorArg($selectors, 'selector'); $original = $this->getSelectorArg($original, 'original'); $replacement = $this->getSelectorArg($replacement, 'replacement'); if (! $selectors || ! $original || ! $replacement) { throw $this->error('selector-replace() invalid arguments'); } $replaced = $this->extendOrReplaceSelectors($selectors, $original, $replacement, true); return $this->formatOutputSelector($replaced); } protected function extendOrReplaceSelectors($selectors, $extendee, $extender, $replace = false) { $saveExtends = $this->extends; $saveExtendsMap = $this->extendsMap; $this->extends = []; $this->extendsMap = []; foreach ($extendee as $es) { if (\count($es) !== 1) { throw $this->error('Can\'t extend complex selector.'); } $this->pushExtends(reset($es), $extender, null); } $extended = []; foreach ($selectors as $selector) { if (! $replace) { $extended[] = $selector; } $n = \count($extended); $this->matchExtends($selector, $extended); if ($replace && \count($extended) === $n) { $extended[] = $selector; } } $this->extends = $saveExtends; $this->extendsMap = $saveExtendsMap; return $extended; } protected static $libSelectorNest = ['selector...']; protected function libSelectorNest($args) { $args = reset($args); $args = $args[2]; if (\count($args) < 1) { throw $this->error('selector-nest() needs at least 1 argument'); } $selectorsMap = []; foreach ($args as $arg) { $selectorsMap[] = $this->getSelectorArg($arg, 'selector', true); } assert(!empty($selectorsMap)); $envs = []; foreach ($selectorsMap as $selectors) { $env = new Environment(); $env->selectors = $selectors; $envs[] = $env; } $envs = array_reverse($envs); $env = $this->extractEnv($envs); $outputSelectors = $this->multiplySelectors($env); return $this->formatOutputSelector($outputSelectors); } protected static $libSelectorParse = [ ['selector'], ['selectors'] ]; protected function libSelectorParse($args) { $selectors = reset($args); $selectors = $this->getSelectorArg($selectors, 'selector'); return $this->formatOutputSelector($selectors); } protected static $libSelectorUnify = ['selectors1', 'selectors2']; protected function libSelectorUnify($args) { list($selectors1, $selectors2) = $args; $selectors1 = $this->getSelectorArg($selectors1, 'selectors1'); $selectors2 = $this->getSelectorArg($selectors2, 'selectors2'); if (! $selectors1 || ! $selectors2) { throw $this->error('selector-unify() invalid arguments'); } $compound1 = reset($selectors1); $compound2 = reset($selectors2); $unified = $this->unifyCompoundSelectors($compound1, $compound2); return $this->formatOutputSelector($unified); } protected function unifyCompoundSelectors($compound1, $compound2) { if (! \count($compound1)) { return $compound2; } if (! \count($compound2)) { return $compound1; } $lastPart1 = array_pop($compound1); $lastPart2 = array_pop($compound2); $last = $this->mergeParts($lastPart1, $lastPart2); if (! $last) { return [[]]; } $unifiedCompound = [$last]; $unifiedSelectors = [$unifiedCompound]; while (\count($compound1) || \count($compound2)) { $part1 = end($compound1); $part2 = end($compound2); if ($part1 && ($match2 = $this->matchPartInCompound($part1, $compound2))) { list($compound2, $part2, $after2) = $match2; if ($after2) { $unifiedSelectors = $this->prependSelectors($unifiedSelectors, $after2); } $c = $this->mergeParts($part1, $part2); $unifiedSelectors = $this->prependSelectors($unifiedSelectors, [$c]); $part1 = $part2 = null; array_pop($compound1); } if ($part2 && ($match1 = $this->matchPartInCompound($part2, $compound1))) { list($compound1, $part1, $after1) = $match1; if ($after1) { $unifiedSelectors = $this->prependSelectors($unifiedSelectors, $after1); } $c = $this->mergeParts($part2, $part1); $unifiedSelectors = $this->prependSelectors($unifiedSelectors, [$c]); $part1 = $part2 = null; array_pop($compound2); } $new = []; if ($part1 && $part2) { array_pop($compound1); array_pop($compound2); $s = $this->prependSelectors($unifiedSelectors, [$part2]); $new = array_merge($new, $this->prependSelectors($s, [$part1])); $s = $this->prependSelectors($unifiedSelectors, [$part1]); $new = array_merge($new, $this->prependSelectors($s, [$part2])); } elseif ($part1) { array_pop($compound1); $new = array_merge($new, $this->prependSelectors($unifiedSelectors, [$part1])); } elseif ($part2) { array_pop($compound2); $new = array_merge($new, $this->prependSelectors($unifiedSelectors, [$part2])); } if ($new) { $unifiedSelectors = $new; } } return $unifiedSelectors; } protected function prependSelectors($selectors, $parts) { $new = []; foreach ($selectors as $compoundSelector) { array_unshift($compoundSelector, $parts); $new[] = $compoundSelector; } return $new; } protected function matchPartInCompound($part, $compound) { $partTag = $this->findTagName($part); $before = $compound; $after = []; while (\count($before)) { $p = array_pop($before); if ($partTag && $partTag !== '*' && $partTag == $this->findTagName($p)) { return [$before, $p, $after]; } $after[] = $p; } $before = $compound; $after = []; while (\count($before)) { $p = array_pop($before); if ($this->checkCompatibleTags($partTag, $this->findTagName($p))) { if (\count(array_intersect($part, $p))) { return [$before, $p, $after]; } } $after[] = $p; } return false; } protected function mergeParts($parts1, $parts2) { $tag1 = $this->findTagName($parts1); $tag2 = $this->findTagName($parts2); $tag = $this->checkCompatibleTags($tag1, $tag2); if ($tag === false) { return []; } if ($tag) { if ($tag1) { $parts1 = array_diff($parts1, [$tag1]); } if ($tag2) { $parts2 = array_diff($parts2, [$tag2]); } } $mergedParts = array_merge($parts1, $parts2); $mergedOrderedParts = []; foreach ($mergedParts as $part) { if (strpos($part, ':') === 0) { $mergedOrderedParts[] = $part; } } $mergedParts = array_diff($mergedParts, $mergedOrderedParts); $mergedParts = array_merge($mergedParts, $mergedOrderedParts); if ($tag) { array_unshift($mergedParts, $tag); } return $mergedParts; } protected function checkCompatibleTags($tag1, $tag2) { $tags = [$tag1, $tag2]; $tags = array_unique($tags); $tags = array_filter($tags); if (\count($tags) > 1) { $tags = array_diff($tags, ['*']); } if (\count($tags) > 1) { return false; } return $tags; } protected function findTagName($parts) { foreach ($parts as $part) { if (! preg_match('/^[\[.:#%_-]/', $part)) { return $part; } } return ''; } protected static $libSimpleSelectors = ['selector']; protected function libSimpleSelectors($args) { $selector = reset($args); $selector = $this->getSelectorArg($selector, 'selector'); $selector = reset($selector); $part = reset($selector); $listParts = []; foreach ($part as $p) { $listParts[] = [Type::T_STRING, '', [$p]]; } return [Type::T_LIST, ',', $listParts]; } protected static $libScssphpGlob = ['pattern']; protected function libScssphpGlob($args) { @trigger_error(sprintf('The "scssphp-glob" function is deprecated an will be removed in ScssPhp 2.0. Register your own alternative through "%s::registerFunction', __CLASS__), E_USER_DEPRECATED); $this->logger->warn('The "scssphp-glob" function is deprecated an will be removed in ScssPhp 2.0.', true); $string = $this->assertString($args[0], 'pattern'); $pattern = $this->compileStringContent($string); $matches = glob($pattern); $listParts = []; foreach ($matches as $match) { if (! is_file($match)) { continue; } $listParts[] = [Type::T_STRING, '"', [$match]]; } return [Type::T_LIST, ',', $listParts]; } } abstract class Formatter { public $indentLevel; public $indentChar; public $break; public $open; public $close; public $tagSeparator; public $assignSeparator; public $keepSemicolons; protected $currentBlock; protected $currentLine; protected $currentColumn; protected $sourceMapGenerator; protected $strippedSemicolon; abstract public function __construct(); protected function indentStr() { return ''; } public function property($name, $value) { return rtrim($name) . $this->assignSeparator . $value . ';'; } public function customProperty($name, $value) { return rtrim($name) . trim($this->assignSeparator) . $value . ';'; } protected function blockLines(OutputBlock $block) { $inner = $this->indentStr(); $glue = $this->break . $inner; $this->write($inner . implode($glue, $block->lines)); if (! empty($block->children)) { $this->write($this->break); } } protected function blockSelectors(OutputBlock $block) { assert(! empty($block->selectors)); $inner = $this->indentStr(); $this->write($inner . implode($this->tagSeparator, $block->selectors) . $this->open . $this->break); } protected function blockChildren(OutputBlock $block) { foreach ($block->children as $child) { $this->block($child); } } protected function block(OutputBlock $block) { if (empty($block->lines) && empty($block->children)) { return; } $this->currentBlock = $block; $pre = $this->indentStr(); if (! empty($block->selectors)) { $this->blockSelectors($block); $this->indentLevel++; } if (! empty($block->lines)) { $this->blockLines($block); } if (! empty($block->children)) { $this->blockChildren($block); } if (! empty($block->selectors)) { $this->indentLevel--; if (! $this->keepSemicolons) { $this->strippedSemicolon = ''; } if (empty($block->children)) { $this->write($this->break); } $this->write($pre . $this->close . $this->break); } } protected function testEmptyChildren($block) { $isEmpty = empty($block->lines); if ($block->children) { foreach ($block->children as $k => &$child) { if (! $this->testEmptyChildren($child)) { $isEmpty = false; continue; } if ($child->type === Type::T_MEDIA || $child->type === Type::T_DIRECTIVE) { $child->children = []; $child->selectors = null; } } } return $isEmpty; } public function format(OutputBlock $block, SourceMapGenerator $sourceMapGenerator = null) { $this->sourceMapGenerator = null; if ($sourceMapGenerator) { $this->currentLine = 1; $this->currentColumn = 0; $this->sourceMapGenerator = $sourceMapGenerator; } $this->testEmptyChildren($block); ob_start(); try { $this->block($block); } catch (\Exception $e) { ob_end_clean(); throw $e; } catch (\Throwable $e) { ob_end_clean(); throw $e; } $out = ob_get_clean(); assert($out !== false); return $out; } protected function write($str) { if (! empty($this->strippedSemicolon)) { echo $this->strippedSemicolon; $this->strippedSemicolon = ''; } if ( ! $this->keepSemicolons && $str && (strpos($str, ';') !== false) && (substr($str, -1) === ';') ) { $str = substr($str, 0, -1); $this->strippedSemicolon = ';'; } if ($this->sourceMapGenerator) { $lines = explode("\n", $str); $lastLine = array_pop($lines); foreach ($lines as $line) { if ($line !== '') { assert($this->currentBlock->sourceLine !== null); assert($this->currentBlock->sourceName !== null); $this->sourceMapGenerator->addMapping( $this->currentLine, $this->currentColumn, $this->currentBlock->sourceLine, $this->currentBlock->sourceColumn > 0 ? $this->currentBlock->sourceColumn - 1 : 0, $this->currentBlock->sourceName ); } $this->currentLine++; $this->currentColumn = 0; } if ($lastLine !== '') { assert($this->currentBlock->sourceLine !== null); assert($this->currentBlock->sourceName !== null); $this->sourceMapGenerator->addMapping( $this->currentLine, $this->currentColumn, $this->currentBlock->sourceLine, $this->currentBlock->sourceColumn > 0 ? $this->currentBlock->sourceColumn - 1 : 0, $this->currentBlock->sourceName ); } $this->currentColumn += \strlen($lastLine); } echo $str; } } abstract class Node { public $type; public $sourceIndex; public $sourceLine; public $sourceColumn; } final class OutputStyle { const EXPANDED = 'expanded'; const COMPRESSED = 'compressed'; } class Parser { const SOURCE_INDEX = -1; const SOURCE_LINE = -2; const SOURCE_COLUMN = -3; protected static $precedence = [ '=' => 0, 'or' => 1, 'and' => 2, '==' => 3, '!=' => 3, '<=' => 4, '>=' => 4, '<' => 4, '>' => 4, '+' => 5, '-' => 5, '*' => 6, '/' => 6, '%' => 6, ]; protected static $commentPattern; protected static $operatorPattern; protected static $whitePattern; protected $cache; private $sourceName; private $sourceIndex; private $sourcePositions; private $count; private $env; private $inParens; private $eatWhiteDefault; private $discardComments; private $allowVars; private $buffer; private $utf8; private $encoding; private $patternModifiers; private $commentsSeen; private $cssOnly; private $logger; public function __construct($sourceName, $sourceIndex = 0, $encoding = 'utf-8', Cache $cache = null, $cssOnly = false, LoggerInterface $logger = null) { $this->sourceName = $sourceName ?: '(stdin)'; $this->sourceIndex = $sourceIndex; $this->utf8 = ! $encoding || strtolower($encoding) === 'utf-8'; $this->patternModifiers = $this->utf8 ? 'Aisu' : 'Ais'; $this->commentsSeen = []; $this->allowVars = true; $this->cssOnly = $cssOnly; $this->logger = $logger ?: new QuietLogger(); if (empty(static::$operatorPattern)) { static::$operatorPattern = '([*\/%+-]|[!=]\=|\>\=?|\<\=?|and|or)'; $commentSingle = '\/\/'; $commentMultiLeft = '\/\*'; $commentMultiRight = '\*\/'; static::$commentPattern = $commentMultiLeft . '.*?' . $commentMultiRight; static::$whitePattern = $this->utf8 ? '/' . $commentSingle . '[^\n]*\s*|(' . static::$commentPattern . ')\s*|\s+/AisuS' : '/' . $commentSingle . '[^\n]*\s*|(' . static::$commentPattern . ')\s*|\s+/AisS'; } $this->cache = $cache; } public function getSourceName() { return $this->sourceName; } public function throwParseError($msg = 'parse error') { @trigger_error( 'The method "throwParseError" is deprecated. Use "parseError" and throw the exception in the caller instead', E_USER_DEPRECATED ); throw $this->parseError($msg); } public function parseError($msg = 'parse error') { list($line, $column) = $this->getSourcePosition($this->count); $loc = empty($this->sourceName) ? "line: $line, column: $column" : "$this->sourceName on line $line, at column $column"; if ($this->peek('(.*?)(\n|$)', $m, $this->count)) { $this->restoreEncoding(); $e = new ParserException("$msg: failed at `$m[1]` $loc"); $e->setSourcePosition([$this->sourceName, $line, $column]); return $e; } $this->restoreEncoding(); $e = new ParserException("$msg: $loc"); $e->setSourcePosition([$this->sourceName, $line, $column]); return $e; } public function parse($buffer) { if ($this->cache) { $cacheKey = $this->sourceName . ':' . md5($buffer); $parseOptions = [ 'utf8' => $this->utf8, ]; $v = $this->cache->getCache('parse', $cacheKey, $parseOptions); if (! \is_null($v)) { return $v; } } if (substr($buffer, 0, 3) === "\xef\xbb\xbf") { $buffer = substr($buffer, 3); } $this->buffer = rtrim($buffer, "\x00..\x1f"); $this->count = 0; $this->env = null; $this->inParens = false; $this->eatWhiteDefault = true; $this->saveEncoding(); $this->extractLineNumbers($buffer); $this->pushBlock(null); $this->whitespace(); $this->pushBlock(null); $this->popBlock(); while ($this->parseChunk()) { ; } if ($this->count !== \strlen($this->buffer)) { throw $this->parseError(); } if (! empty($this->env->parent)) { throw $this->parseError('unclosed block'); } $this->restoreEncoding(); assert($this->env !== null); if ($this->cache) { $this->cache->setCache('parse', $cacheKey, $this->env, $parseOptions); } return $this->env; } public function parseValue($buffer, &$out) { $this->count = 0; $this->env = null; $this->inParens = false; $this->eatWhiteDefault = true; $this->buffer = (string) $buffer; $this->saveEncoding(); $this->extractLineNumbers($this->buffer); $list = $this->valueList($out); $this->restoreEncoding(); return $list; } public function parseSelector($buffer, &$out, $shouldValidate = true) { $this->count = 0; $this->env = null; $this->inParens = false; $this->eatWhiteDefault = true; $this->buffer = (string) $buffer; $this->saveEncoding(); $this->extractLineNumbers($this->buffer); $this->discardComments = true; $this->whitespace(); $this->discardComments = false; $selector = $this->selectors($out); $this->restoreEncoding(); if ($shouldValidate && $this->count !== strlen($buffer)) { throw $this->parseError("`" . substr($buffer, $this->count) . "` is not a valid Selector in `$buffer`"); } return $selector; } public function parseMediaQueryList($buffer, &$out) { $this->count = 0; $this->env = null; $this->inParens = false; $this->eatWhiteDefault = true; $this->buffer = (string) $buffer; $this->saveEncoding(); $this->extractLineNumbers($this->buffer); $isMediaQuery = $this->mediaQueryList($out); $this->restoreEncoding(); return $isMediaQuery; } protected function parseChunk() { $s = $this->count; if (isset($this->buffer[$this->count]) && $this->buffer[$this->count] === '@') { if ( $this->literal('@at-root', 8) && ($this->selectors($selector) || true) && ($this->map($with) || true) && (($this->matchChar('(') && $this->interpolation($with) && $this->matchChar(')')) || true) && $this->matchChar('{', false) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $atRoot = new AtRootBlock(); $this->registerPushedBlock($atRoot, $s); $atRoot->selector = $selector; $atRoot->with = $with; return true; } $this->seek($s); if ( $this->literal('@media', 6) && $this->mediaQueryList($mediaQueryList) && $this->matchChar('{', false) ) { $media = new MediaBlock(); $this->registerPushedBlock($media, $s); $media->queryList = $mediaQueryList[2]; return true; } $this->seek($s); if ( $this->literal('@mixin', 6) && $this->keyword($mixinName) && ($this->argumentDef($args) || true) && $this->matchChar('{', false) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $mixin = new CallableBlock(Type::T_MIXIN); $this->registerPushedBlock($mixin, $s); $mixin->name = $mixinName; $mixin->args = $args; return true; } $this->seek($s); if ( ($this->literal('@include', 8) && $this->keyword($mixinName) && ($this->matchChar('(') && ($this->argValues($argValues) || true) && $this->matchChar(')') || true) && ($this->end()) || ($this->literal('using', 5) && $this->argumentDef($argUsing) && ($this->end() || $this->matchChar('{') && $hasBlock = true)) || $this->matchChar('{') && $hasBlock = true) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $child = [ Type::T_INCLUDE, $mixinName, isset($argValues) ? $argValues : null, null, isset($argUsing) ? $argUsing : null ]; if (! empty($hasBlock)) { $include = new ContentBlock(); $this->registerPushedBlock($include, $s); $include->child = $child; } else { $this->append($child, $s); } return true; } $this->seek($s); if ( $this->literal('@scssphp-import-once', 20) && $this->valueList($importPath) && $this->end() ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); list($line, $column) = $this->getSourcePosition($s); $file = $this->sourceName; $this->logger->warn("The \"@scssphp-import-once\" directive is deprecated and will be removed in ScssPhp 2.0, in \"$file\", line $line, column $column.", true); $this->append([Type::T_SCSSPHP_IMPORT_ONCE, $importPath], $s); return true; } $this->seek($s); if ( $this->literal('@import', 7) && $this->valueList($importPath) && $importPath[0] !== Type::T_FUNCTION_CALL && $this->end() ) { if ($this->cssOnly) { $this->assertPlainCssValid([Type::T_IMPORT, $importPath], $s); $this->append([Type::T_COMMENT, rtrim(substr($this->buffer, $s, $this->count - $s))]); return true; } $this->append([Type::T_IMPORT, $importPath], $s); return true; } $this->seek($s); if ( $this->literal('@import', 7) && $this->url($importPath) && $this->end() ) { if ($this->cssOnly) { $this->assertPlainCssValid([Type::T_IMPORT, $importPath], $s); $this->append([Type::T_COMMENT, rtrim(substr($this->buffer, $s, $this->count - $s))]); return true; } $this->append([Type::T_IMPORT, $importPath], $s); return true; } $this->seek($s); if ( $this->literal('@extend', 7) && $this->selectors($selectors) && $this->end() ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $optional = $this->stripOptionalFlag($selectors); $this->append([Type::T_EXTEND, $selectors, $optional], $s); return true; } $this->seek($s); if ( $this->literal('@function', 9) && $this->keyword($fnName) && $this->argumentDef($args) && $this->matchChar('{', false) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $func = new CallableBlock(Type::T_FUNCTION); $this->registerPushedBlock($func, $s); $func->name = $fnName; $func->args = $args; return true; } $this->seek($s); if ( $this->literal('@return', 7) && ($this->valueList($retVal) || true) && $this->end() ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $this->append([Type::T_RETURN, isset($retVal) ? $retVal : [Type::T_NULL]], $s); return true; } $this->seek($s); if ( $this->literal('@each', 5) && $this->genericList($varNames, 'variable', ',', false) && $this->literal('in', 2) && $this->valueList($list) && $this->matchChar('{', false) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $each = new EachBlock(); $this->registerPushedBlock($each, $s); foreach ($varNames[2] as $varName) { $each->vars[] = $varName[1]; } $each->list = $list; return true; } $this->seek($s); if ( $this->literal('@while', 6) && $this->expression($cond) && $this->matchChar('{', false) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); while ( $cond[0] === Type::T_LIST && ! empty($cond['enclosing']) && $cond['enclosing'] === 'parent' && \count($cond[2]) == 1 ) { $cond = reset($cond[2]); } $while = new WhileBlock(); $this->registerPushedBlock($while, $s); $while->cond = $cond; return true; } $this->seek($s); if ( $this->literal('@for', 4) && $this->variable($varName) && $this->literal('from', 4) && $this->expression($start) && ($this->literal('through', 7) || ($forUntil = true && $this->literal('to', 2))) && $this->expression($end) && $this->matchChar('{', false) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $for = new ForBlock(); $this->registerPushedBlock($for, $s); $for->var = $varName[1]; $for->start = $start; $for->end = $end; $for->until = isset($forUntil); return true; } $this->seek($s); if ( $this->literal('@if', 3) && $this->functionCallArgumentsList($cond, false, '{', false) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $if = new IfBlock(); $this->registerPushedBlock($if, $s); while ( $cond[0] === Type::T_LIST && ! empty($cond['enclosing']) && $cond['enclosing'] === 'parent' && \count($cond[2]) == 1 ) { $cond = reset($cond[2]); } $if->cond = $cond; $if->cases = []; return true; } $this->seek($s); if ( $this->literal('@debug', 6) && $this->functionCallArgumentsList($value, false) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $this->append([Type::T_DEBUG, $value], $s); return true; } $this->seek($s); if ( $this->literal('@warn', 5) && $this->functionCallArgumentsList($value, false) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $this->append([Type::T_WARN, $value], $s); return true; } $this->seek($s); if ( $this->literal('@error', 6) && $this->functionCallArgumentsList($value, false) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $this->append([Type::T_ERROR, $value], $s); return true; } $this->seek($s); if ( $this->literal('@content', 8) && ($this->end() || $this->matchChar('(') && $this->argValues($argContent) && $this->matchChar(')') && $this->end()) ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $this->append([Type::T_MIXIN_CONTENT, isset($argContent) ? $argContent : null], $s); return true; } $this->seek($s); $last = $this->last(); if (isset($last) && $last[0] === Type::T_IF) { list(, $if) = $last; assert($if instanceof IfBlock); if ($this->literal('@else', 5)) { if ($this->matchChar('{', false)) { $else = new ElseBlock(); } elseif ( $this->literal('if', 2) && $this->functionCallArgumentsList($cond, false, '{', false) ) { $else = new ElseifBlock(); $else->cond = $cond; } if (isset($else)) { $this->registerPushedBlock($else, $s); $if->cases[] = $else; return true; } } $this->seek($s); } if ( $this->literal('@charset', 8) && $this->valueList($charset) && $this->end() ) { return true; } $this->seek($s); if ( $this->literal('@supports', 9) && ($t1 = $this->supportsQuery($supportQuery)) && ($t2 = $this->matchChar('{', false)) ) { $directive = new DirectiveBlock(); $this->registerPushedBlock($directive, $s); $directive->name = 'supports'; $directive->value = $supportQuery; return true; } $this->seek($s); if ( $this->matchChar('@', false) && $this->mixedKeyword($dirName) && $this->directiveValue($dirValue, '{') ) { if (count($dirName) === 1 && is_string(reset($dirName))) { $dirName = reset($dirName); } else { $dirName = [Type::T_STRING, '', $dirName]; } if ($dirName === 'media') { $directive = new MediaBlock(); } else { $directive = new DirectiveBlock(); $directive->name = $dirName; } $this->registerPushedBlock($directive, $s); if (isset($dirValue)) { ! $this->cssOnly || ($dirValue = $this->assertPlainCssValid($dirValue)); $directive->value = $dirValue; } return true; } $this->seek($s); if ( $this->matchChar('@', false) && $this->mixedKeyword($dirName) && ! $this->isKnownGenericDirective($dirName) && ($this->end(false) || ($this->directiveValue($dirValue, '') && $this->end(false))) ) { if (\count($dirName) === 1 && \is_string(\reset($dirName))) { $dirName = \reset($dirName); } else { $dirName = [Type::T_STRING, '', $dirName]; } if ( ! empty($this->env->parent) && $this->env->type && ! \in_array($this->env->type, [Type::T_DIRECTIVE, Type::T_MEDIA]) ) { $plain = \trim(\substr($this->buffer, $s, $this->count - $s)); throw $this->parseError( "Unknown directive `{$plain}` not allowed in `" . $this->env->type . "` block" ); } $s = $this->count; $hasBlankLine = false; if ($this->match('\s*?\n\s*\n', $out, false)) { $hasBlankLine = true; $this->seek($s); } $isNotRoot = ! empty($this->env->parent); $this->append([Type::T_DIRECTIVE, [$dirName, $dirValue, $hasBlankLine, $isNotRoot]], $s); $this->whitespace(); return true; } $this->seek($s); return false; } $inCssSelector = null; if ($this->cssOnly) { $inCssSelector = (! empty($this->env->parent) && ! in_array($this->env->type, [Type::T_DIRECTIVE, Type::T_MEDIA])); } if (($this->customProperty($name) ) && $this->matchChar(':', false)) { $start = $this->count; foreach ([';','}'] as $ending) { if ( $this->openString($ending, $stringValue, '(', ')', false) && $this->end() ) { $end = $this->count; $value = $stringValue; $nestingPairs = [['[', ']'], ['{', '}']]; foreach ($nestingPairs as $nestingPair) { $p = strpos($this->buffer, $nestingPair[0], $start); if ($p && $p < $end) { $this->seek($start); if ( $this->openString($ending, $stringValue, $nestingPair[0], $nestingPair[1], false) && $this->end() && $this->count > $end ) { $end = $this->count; $value = $stringValue; } } } $this->seek($end); $this->append([Type::T_CUSTOM_PROPERTY, $name, $value], $s); return true; } } } $this->seek($s); if ( $this->keyword($name, false) && $this->literal(': ', 2) && $this->valueList($value) && $this->end() ) { $name = [Type::T_STRING, '', [$name]]; $this->append([Type::T_ASSIGN, $name, $value], $s); return true; } $this->seek($s); if ( $this->variable($name) && $this->matchChar(':') && $this->valueList($value) && $this->end() ) { ! $this->cssOnly || $this->assertPlainCssValid(false, $s); $assignmentFlags = $this->stripAssignmentFlags($value); $this->append([Type::T_ASSIGN, $name, $value, $assignmentFlags], $s); return true; } $this->seek($s); if ( $this->selectors($selectors) && $this->matchChar('{', false) ) { ! $this->cssOnly || ! $inCssSelector || $this->assertPlainCssValid(false); $this->pushBlock($selectors, $s); if ($this->eatWhiteDefault) { $this->whitespace(); $this->append(null); } return true; } $this->seek($s); if ( $this->propertyName($name) && $this->matchChar(':') ) { $foundSomething = false; if ($this->valueList($value)) { if (empty($this->env->parent)) { throw $this->parseError('expected "{"'); } $this->append([Type::T_ASSIGN, $name, $value], $s); $foundSomething = true; } if ($this->matchChar('{', false)) { ! $this->cssOnly || $this->assertPlainCssValid(false); $propBlock = new NestedPropertyBlock(); $this->registerPushedBlock($propBlock, $s); $propBlock->prefix = $name; $propBlock->hasValue = $foundSomething; $foundSomething = true; } elseif ($foundSomething) { $foundSomething = $this->end(); } if ($foundSomething) { return true; } } $this->seek($s); if ($this->matchChar('}', false)) { $block = $this->popBlock(); if (! isset($block->type) || $block->type !== Type::T_IF) { assert($this->env !== null); if ($this->env->parent) { $this->append(null); } } if ($block instanceof ContentBlock) { $include = $block->child; assert(\is_array($include)); unset($block->child); $include[3] = $block; $this->append($include, $s); } elseif (!$block instanceof ElseBlock && !$block instanceof ElseifBlock) { $type = isset($block->type) ? $block->type : Type::T_BLOCK; $this->append([$type, $block], $s); } if ($this->eatWhiteDefault) { $this->whitespace(); assert($this->env !== null); if ($this->env->comments) { $this->append(null); } } return true; } if ($this->matchChar(';')) { return true; } return false; } protected function pushBlock($selectors, $pos = 0) { $b = new Block(); $b->selectors = $selectors; $this->registerPushedBlock($b, $pos); return $b; } private function registerPushedBlock(Block $b, $pos) { list($line, $column) = $this->getSourcePosition($pos); $b->sourceName = $this->sourceName; $b->sourceLine = $line; $b->sourceColumn = $column; $b->sourceIndex = $this->sourceIndex; $b->comments = []; $b->parent = $this->env; if (! $this->env) { $b->children = []; } elseif (empty($this->env->children)) { $this->env->children = $this->env->comments; $b->children = []; $this->env->comments = []; } else { $b->children = $this->env->comments; $this->env->comments = []; } $this->env = $b; if ($this->eatWhiteDefault) { $this->whitespace(); assert($this->env !== null); if ($this->env->comments) { $this->append(null); } } } protected function pushSpecialBlock($type, $pos) { $block = $this->pushBlock(null, $pos); $block->type = $type; return $block; } protected function popBlock() { assert($this->env !== null); if ($this->env->comments) { $this->append(null); } $block = $this->env; if (empty($block->parent)) { throw $this->parseError('unexpected }'); } if ($block->type == Type::T_AT_ROOT) { $block->selfParent = $block->parent; } $this->env = $block->parent; unset($block->parent); return $block; } protected function peek($regex, &$out, $from = null) { if (! isset($from)) { $from = $this->count; } $r = '/' . $regex . '/' . $this->patternModifiers; $result = preg_match($r, $this->buffer, $out, 0, $from); return $result; } protected function seek($where) { $this->count = $where; } protected function assertPlainCssValid($parsed, $startPos = null) { $type = ''; if ($parsed) { $type = $parsed[0]; $parsed = $this->isPlainCssValidElement($parsed); } if (! $parsed) { if (! \is_null($startPos)) { $plain = rtrim(substr($this->buffer, $startPos, $this->count - $startPos)); $message = "Error : `{$plain}` isn't allowed in plain CSS"; } else { $message = 'Error: SCSS syntax not allowed in CSS file'; } if ($type) { $message .= " ($type)"; } throw $this->parseError($message); } return $parsed; } protected function isPlainCssValidElement($parsed, $allowExpression = false) { if (is_string($parsed)) { return $parsed; } if ( \in_array($parsed[0], [Type::T_FUNCTION, Type::T_FUNCTION_CALL]) && !\in_array($parsed[1], [ 'alpha', 'attr', 'calc', 'cubic-bezier', 'env', 'grayscale', 'hsl', 'hsla', 'hwb', 'invert', 'linear-gradient', 'min', 'max', 'radial-gradient', 'repeating-linear-gradient', 'repeating-radial-gradient', 'rgb', 'rgba', 'rotate', 'saturate', 'var', ]) && Compiler::isNativeFunction($parsed[1]) ) { return false; } switch ($parsed[0]) { case Type::T_BLOCK: case Type::T_KEYWORD: case Type::T_NULL: case Type::T_NUMBER: case Type::T_MEDIA: return $parsed; case Type::T_COMMENT: if (isset($parsed[2])) { return false; } return $parsed; case Type::T_DIRECTIVE: if (\is_array($parsed[1])) { $parsed[1][1] = $this->isPlainCssValidElement($parsed[1][1]); if (! $parsed[1][1]) { return false; } } return $parsed; case Type::T_IMPORT: if ($parsed[1][0] === Type::T_LIST) { return false; } $parsed[1] = $this->isPlainCssValidElement($parsed[1]); if ($parsed[1] === false) { return false; } return $parsed; case Type::T_STRING: foreach ($parsed[2] as $k => $substr) { if (\is_array($substr)) { $parsed[2][$k] = $this->isPlainCssValidElement($substr); if (! $parsed[2][$k]) { return false; } } } return $parsed; case Type::T_LIST: if (!empty($parsed['enclosing'])) { return false; } foreach ($parsed[2] as $k => $listElement) { $parsed[2][$k] = $this->isPlainCssValidElement($listElement); if (! $parsed[2][$k]) { return false; } } return $parsed; case Type::T_ASSIGN: foreach ([1, 2, 3] as $k) { if (! empty($parsed[$k])) { $parsed[$k] = $this->isPlainCssValidElement($parsed[$k]); if (! $parsed[$k]) { return false; } } } return $parsed; case Type::T_EXPRESSION: list( ,$op, $lhs, $rhs, $inParens, $whiteBefore, $whiteAfter) = $parsed; if (! $allowExpression && ! \in_array($op, ['and', 'or', '/'])) { return false; } $lhs = $this->isPlainCssValidElement($lhs, true); if (! $lhs) { return false; } $rhs = $this->isPlainCssValidElement($rhs, true); if (! $rhs) { return false; } return [ Type::T_STRING, '', [ $this->inParens ? '(' : '', $lhs, ($whiteBefore ? ' ' : '') . $op . ($whiteAfter ? ' ' : ''), $rhs, $this->inParens ? ')' : '' ] ]; case Type::T_CUSTOM_PROPERTY: case Type::T_UNARY: $parsed[2] = $this->isPlainCssValidElement($parsed[2]); if (! $parsed[2]) { return false; } return $parsed; case Type::T_FUNCTION: $argsList = $parsed[2]; foreach ($argsList[2] as $argElement) { if (! $this->isPlainCssValidElement($argElement)) { return false; } } return $parsed; case Type::T_FUNCTION_CALL: $parsed[0] = Type::T_FUNCTION; $argsList = [Type::T_LIST, ',', []]; foreach ($parsed[2] as $arg) { if ($arg[0] || ! empty($arg[2])) { return false; } $arg = $this->isPlainCssValidElement($arg[1], $parsed[1] === 'calc'); if (! $arg) { return false; } $argsList[2][] = $arg; } $parsed[2] = $argsList; return $parsed; } return false; } protected function matchString(&$m, $delim) { $token = null; $end = \strlen($this->buffer); foreach (['#{', '\\', "\r", $delim] as $lookahead) { $pos = strpos($this->buffer, $lookahead, $this->count); if ($pos !== false && $pos < $end) { $end = $pos; $token = $lookahead; } } if (! isset($token)) { return false; } $match = substr($this->buffer, $this->count, $end - $this->count); $m = [ $match . $token, $match, $token ]; $this->count = $end + \strlen($token); return true; } protected function match($regex, &$out, $eatWhitespace = null) { $r = '/' . $regex . '/' . $this->patternModifiers; if (! preg_match($r, $this->buffer, $out, 0, $this->count)) { return false; } $this->count += \strlen($out[0]); if (! isset($eatWhitespace)) { $eatWhitespace = $this->eatWhiteDefault; } if ($eatWhitespace) { $this->whitespace(); } return true; } protected function matchChar($char, $eatWhitespace = null) { if (! isset($this->buffer[$this->count]) || $this->buffer[$this->count] !== $char) { return false; } $this->count++; if (! isset($eatWhitespace)) { $eatWhitespace = $this->eatWhiteDefault; } if ($eatWhitespace) { $this->whitespace(); } return true; } protected function literal($what, $len, $eatWhitespace = null) { if (strcasecmp(substr($this->buffer, $this->count, $len), $what) !== 0) { return false; } $this->count += $len; if (! isset($eatWhitespace)) { $eatWhitespace = $this->eatWhiteDefault; } if ($eatWhitespace) { $this->whitespace(); } return true; } protected function whitespace() { $gotWhite = false; while (preg_match(static::$whitePattern, $this->buffer, $m, 0, $this->count)) { if (isset($m[1]) && empty($this->commentsSeen[$this->count])) { $comment = []; $startCommentCount = $this->count; $endCommentCount = $this->count + \strlen($m[1]); $p = strpos($this->buffer, '#{', $this->count); while ($p !== false && $p < $endCommentCount) { $c = substr($this->buffer, $this->count, $p - $this->count); $comment[] = $c; $this->count = $p; $out = null; if ($this->interpolation($out)) { if ($out[3]) { while ($this->buffer[$this->count - 1] !== '}') { $this->count--; } $out[3] = ''; } $comment[] = [Type::T_COMMENT, substr($this->buffer, $p, $this->count - $p), $out]; } else { list($line, $column) = $this->getSourcePosition($this->count); $file = $this->sourceName; if (!$this->discardComments) { $this->logger->warn("Unterminated interpolations in multiline comments are deprecated and will be removed in ScssPhp 2.0, in \"$file\", line $line, column $column.", true); } $comment[] = substr($this->buffer, $this->count, 2); $this->count += 2; } $p = strpos($this->buffer, '#{', $this->count); } $c = substr($this->buffer, $this->count, $endCommentCount - $this->count); if (! $comment) { $commentStatement = [Type::T_COMMENT, $c]; } else { $comment[] = $c; $staticComment = substr($this->buffer, $startCommentCount, $endCommentCount - $startCommentCount); $commentStatement = [Type::T_COMMENT, $staticComment, [Type::T_STRING, '', $comment]]; } list($line, $column) = $this->getSourcePosition($startCommentCount); $commentStatement[self::SOURCE_LINE] = $line; $commentStatement[self::SOURCE_COLUMN] = $column; $commentStatement[self::SOURCE_INDEX] = $this->sourceIndex; $this->appendComment($commentStatement); $this->commentsSeen[$startCommentCount] = true; $this->count = $endCommentCount; } else { $this->count += \strlen($m[0]); ! $this->cssOnly || ! \strlen(trim($m[0])) || $this->assertPlainCssValid(false, $this->count - \strlen($m[0])); } $gotWhite = true; } return $gotWhite; } protected function appendComment($comment) { assert($this->env !== null); if (! $this->discardComments) { $this->env->comments[] = $comment; } } protected function append($statement, $pos = null) { assert($this->env !== null); if (! \is_null($statement)) { ! $this->cssOnly || ($statement = $this->assertPlainCssValid($statement, $pos)); if (! \is_null($pos)) { list($line, $column) = $this->getSourcePosition($pos); $statement[static::SOURCE_LINE] = $line; $statement[static::SOURCE_COLUMN] = $column; $statement[static::SOURCE_INDEX] = $this->sourceIndex; } $this->env->children[] = $statement; } $comments = $this->env->comments; if ($comments) { $this->env->children = array_merge($this->env->children, $comments); $this->env->comments = []; } } protected function last() { assert($this->env !== null); $i = \count($this->env->children) - 1; if (isset($this->env->children[$i])) { return $this->env->children[$i]; } return null; } protected function mediaQueryList(&$out) { return $this->genericList($out, 'mediaQuery', ',', false); } protected function mediaQuery(&$out) { $expressions = null; $parts = []; if ( ($this->literal('only', 4) && ($only = true) || $this->literal('not', 3) && ($not = true) || true) && $this->mixedKeyword($mediaType) ) { $prop = [Type::T_MEDIA_TYPE]; if (isset($only)) { $prop[] = [Type::T_KEYWORD, 'only']; } if (isset($not)) { $prop[] = [Type::T_KEYWORD, 'not']; } $media = [Type::T_LIST, '', []]; foreach ((array) $mediaType as $type) { if (\is_array($type)) { $media[2][] = $type; } else { $media[2][] = [Type::T_KEYWORD, $type]; } } $prop[] = $media; $parts[] = $prop; } if (empty($parts) || $this->literal('and', 3)) { $this->genericList($expressions, 'mediaExpression', 'and', false); if (\is_array($expressions)) { $parts = array_merge($parts, $expressions[2]); } } $out = $parts; return true; } protected function supportsQuery(&$out) { $expressions = null; $parts = []; $s = $this->count; $not = false; if ( ($this->literal('not', 3) && ($not = true) || true) && $this->matchChar('(') && ($this->expression($property)) && $this->literal(': ', 2) && $this->valueList($value) && $this->matchChar(')') ) { $support = [Type::T_STRING, '', [[Type::T_KEYWORD, ($not ? 'not ' : '') . '(']]]; $support[2][] = $property; $support[2][] = [Type::T_KEYWORD, ': ']; $support[2][] = $value; $support[2][] = [Type::T_KEYWORD, ')']; $parts[] = $support; $s = $this->count; } else { $this->seek($s); } if ( $this->matchChar('(') && $this->supportsQuery($subQuery) && $this->matchChar(')') ) { $parts[] = [Type::T_STRING, '', [[Type::T_KEYWORD, '('], $subQuery, [Type::T_KEYWORD, ')']]]; $s = $this->count; } else { $this->seek($s); } if ( $this->literal('not', 3) && $this->supportsQuery($subQuery) ) { $parts[] = [Type::T_STRING, '', [[Type::T_KEYWORD, 'not '], $subQuery]]; $s = $this->count; } else { $this->seek($s); } if ( $this->literal('selector(', 9) && $this->selector($selector) && $this->matchChar(')') ) { $support = [Type::T_STRING, '', [[Type::T_KEYWORD, 'selector(']]]; $selectorList = [Type::T_LIST, '', []]; foreach ($selector as $sc) { $compound = [Type::T_STRING, '', []]; foreach ($sc as $scp) { if (\is_array($scp)) { $compound[2][] = $scp; } else { $compound[2][] = [Type::T_KEYWORD, $scp]; } } $selectorList[2][] = $compound; } $support[2][] = $selectorList; $support[2][] = [Type::T_KEYWORD, ')']; $parts[] = $support; $s = $this->count; } else { $this->seek($s); } if ($this->variable($var) or $this->interpolation($var)) { $parts[] = $var; $s = $this->count; } else { $this->seek($s); } if ( $this->literal('and', 3) && $this->genericList($expressions, 'supportsQuery', ' and', false) ) { array_unshift($expressions[2], [Type::T_STRING, '', $parts]); $parts = [$expressions]; $s = $this->count; } else { $this->seek($s); } if ( $this->literal('or', 2) && $this->genericList($expressions, 'supportsQuery', ' or', false) ) { array_unshift($expressions[2], [Type::T_STRING, '', $parts]); $parts = [$expressions]; $s = $this->count; } else { $this->seek($s); } if (\count($parts)) { if ($this->eatWhiteDefault) { $this->whitespace(); } $out = [Type::T_STRING, '', $parts]; return true; } return false; } protected function mediaExpression(&$out) { $s = $this->count; $value = null; if ( $this->matchChar('(') && $this->expression($feature) && ($this->matchChar(':') && $this->expression($value) || true) && $this->matchChar(')') ) { $out = [Type::T_MEDIA_EXPRESSION, $feature]; if ($value) { $out[] = $value; } return true; } $this->seek($s); return false; } protected function argValues(&$out) { $discardComments = $this->discardComments; $this->discardComments = true; if ($this->genericList($list, 'argValue', ',', false)) { $out = $list[2]; $this->discardComments = $discardComments; return true; } $this->discardComments = $discardComments; return false; } protected function argValue(&$out) { $s = $this->count; $keyword = null; if (! $this->variable($keyword) || ! $this->matchChar(':')) { $this->seek($s); $keyword = null; } if ($this->genericList($value, 'expression', '', true)) { $out = [$keyword, $value, false]; $s = $this->count; if ($this->literal('...', 3)) { $out[2] = true; } else { $this->seek($s); } return true; } return false; } protected function isKnownGenericDirective($directiveName) { if (\is_array($directiveName) && \is_string(reset($directiveName))) { $directiveName = reset($directiveName); } if (! \is_string($directiveName)) { return false; } if ( \in_array($directiveName, [ 'at-root', 'media', 'mixin', 'include', 'scssphp-import-once', 'import', 'extend', 'function', 'break', 'continue', 'return', 'each', 'while', 'for', 'if', 'debug', 'warn', 'error', 'content', 'else', 'charset', 'supports', 'use', 'forward', ]) ) { return true; } return false; } protected function directiveValue(&$out, $endChar = false) { $s = $this->count; if ($this->variable($out)) { if ($endChar && $this->matchChar($endChar, false)) { return true; } if (! $endChar && $this->end()) { return true; } } $this->seek($s); if (\is_string($endChar) && $this->openString($endChar ? $endChar : ';', $out, null, null, true, ";}{")) { if ($endChar && $this->matchChar($endChar, false)) { return true; } $ss = $this->count; if (!$endChar && $this->end()) { $this->seek($ss); return true; } } $this->seek($s); $allowVars = $this->allowVars; $this->allowVars = false; $res = $this->genericList($out, 'spaceList', ','); $this->allowVars = $allowVars; if ($res) { if ($endChar && $this->matchChar($endChar, false)) { return true; } if (! $endChar && $this->end()) { return true; } } $this->seek($s); if ($endChar && $this->matchChar($endChar, false)) { return true; } return false; } protected function valueList(&$out) { $discardComments = $this->discardComments; $this->discardComments = true; $res = $this->genericList($out, 'spaceList', ','); $this->discardComments = $discardComments; return $res; } protected function functionCallArgumentsList(&$out, $mandatoryEnclos = true, $charAfter = null, $eatWhiteSp = null) { $s = $this->count; if ( $this->matchChar('(') && $this->valueList($out) && $this->matchChar(')') && ($charAfter ? $this->matchChar($charAfter, $eatWhiteSp) : $this->end()) ) { return true; } if (! $mandatoryEnclos) { $this->seek($s); if ( $this->valueList($out) && ($charAfter ? $this->matchChar($charAfter, $eatWhiteSp) : $this->end()) ) { return true; } } $this->seek($s); return false; } protected function spaceList(&$out) { return $this->genericList($out, 'expression'); } protected function genericList(&$out, $parseItem, $delim = '', $flatten = true) { $s = $this->count; $items = []; $value = null; while ($this->$parseItem($value)) { $trailing_delim = false; $items[] = $value; if ($delim) { if (! $this->literal($delim, \strlen($delim))) { break; } $trailing_delim = true; } else { assert(\is_array($value) || $value instanceof Number); if ($value[0] === Type::T_KEYWORD) { assert(\is_array($value)); $word = $value[1]; $last_char = substr($word, -1); if ( strlen($word) > 1 && in_array($last_char, [ "'", '"']) && substr($word, -2, 1) !== '\\' ) { $word = str_replace('\\' . $last_char, '\\\\', $word); if (strpos($word, $last_char) < strlen($word) - 1) { continue; } $currentCount = $this->count; $this->count--; while (substr($this->buffer, $this->count, 1) !== $last_char) { $this->count--; } $nextValue = null; if ($this->$parseItem($nextValue)) { assert(\is_array($nextValue) || $nextValue instanceof Number); if ($nextValue[0] === Type::T_KEYWORD && $nextValue[1] === $last_char) { $this->seek($currentCount); continue; } if ($nextValue[0] !== Type::T_STRING) { $this->seek($currentCount); continue; } $value[1] = substr($value[1], 0, -1); array_pop($items); $items[] = $value; $items[] = $nextValue; } else { $this->seek($currentCount); continue; } } } } } if (! $items) { $this->seek($s); return false; } if ($trailing_delim) { $items[] = [Type::T_NULL]; } if ($flatten && \count($items) === 1) { $out = $items[0]; } else { $out = [Type::T_LIST, $delim, $items]; } return true; } protected function expression(&$out, $listOnly = false, $lookForExp = true) { $s = $this->count; $discard = $this->discardComments; $this->discardComments = true; $allowedTypes = ($listOnly ? [Type::T_LIST] : [Type::T_LIST, Type::T_MAP]); if ($this->matchChar('(')) { if ($this->enclosedExpression($lhs, $s, ')', $allowedTypes)) { if ($lookForExp) { $out = $this->expHelper($lhs, 0); } else { $out = $lhs; } $this->discardComments = $discard; return true; } $this->seek($s); } if (\in_array(Type::T_LIST, $allowedTypes) && $this->matchChar('[')) { if ($this->enclosedExpression($lhs, $s, ']', [Type::T_LIST])) { if ($lookForExp) { $out = $this->expHelper($lhs, 0); } else { $out = $lhs; } $this->discardComments = $discard; return true; } $this->seek($s); } if (! $listOnly && $this->value($lhs)) { if ($lookForExp) { $out = $this->expHelper($lhs, 0); } else { $out = $lhs; } $this->discardComments = $discard; return true; } $this->discardComments = $discard; return false; } protected function enclosedExpression(&$out, $s, $closingParen = ')', $allowedTypes = [Type::T_LIST, Type::T_MAP]) { if ($this->matchChar($closingParen) && \in_array(Type::T_LIST, $allowedTypes)) { $out = [Type::T_LIST, '', []]; switch ($closingParen) { case ')': $out['enclosing'] = 'parent'; break; case ']': $out['enclosing'] = 'bracket'; break; } return true; } if ( $this->valueList($out) && $this->matchChar($closingParen) && ! ($closingParen === ')' && \in_array($out[0], [Type::T_EXPRESSION, Type::T_UNARY])) && \in_array(Type::T_LIST, $allowedTypes) ) { if ($out[0] !== Type::T_LIST || ! empty($out['enclosing'])) { $out = [Type::T_LIST, '', [$out]]; } switch ($closingParen) { case ')': $out['enclosing'] = 'parent'; break; case ']': $out['enclosing'] = 'bracket'; break; } return true; } $this->seek($s); if (\in_array(Type::T_MAP, $allowedTypes) && $this->map($out)) { return true; } return false; } protected function expHelper($lhs, $minP) { $operators = static::$operatorPattern; $ss = $this->count; $whiteBefore = isset($this->buffer[$this->count - 1]) && ctype_space($this->buffer[$this->count - 1]); while ($this->match($operators, $m, false) && static::$precedence[$m[1]] >= $minP) { $whiteAfter = isset($this->buffer[$this->count]) && ctype_space($this->buffer[$this->count]); $varAfter = isset($this->buffer[$this->count]) && $this->buffer[$this->count] === '$'; $this->whitespace(); $op = $m[1]; if ($op === '-' && $whiteBefore && ! $whiteAfter && ! $varAfter) { break; } if (! $this->value($rhs) && ! $this->expression($rhs, true, false)) { break; } if ($op === '-' && ! $whiteAfter && $rhs[0] === Type::T_KEYWORD) { break; } $rhs = $this->expHelper($rhs, static::$precedence[$op] + 1); $lhs = [Type::T_EXPRESSION, $op, $lhs, $rhs, $this->inParens, $whiteBefore, $whiteAfter]; $ss = $this->count; $whiteBefore = isset($this->buffer[$this->count - 1]) && ctype_space($this->buffer[$this->count - 1]); } $this->seek($ss); return $lhs; } protected function value(&$out) { if (! isset($this->buffer[$this->count])) { return false; } $s = $this->count; $char = $this->buffer[$this->count]; if ( $this->literal('url(', 4) && $this->match('data:([a-z]+)\/([a-z0-9.+-]+);base64,', $m, false) ) { $len = strspn( $this->buffer, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwyxz0123456789+/=', $this->count ); $this->count += $len; if ($this->matchChar(')')) { $content = substr($this->buffer, $s, $this->count - $s); $out = [Type::T_KEYWORD, $content]; return true; } } $this->seek($s); if ( $this->literal('url(', 4, false) && $this->match('\s*(\/\/[^\s\)]+)\s*', $m) ) { $content = 'url(' . $m[1]; if ($this->matchChar(')')) { $content .= ')'; $out = [Type::T_KEYWORD, $content]; return true; } } $this->seek($s); if ($char === 'n' && $this->literal('not', 3, false)) { if ( $this->whitespace() && $this->value($inner) ) { $out = [Type::T_UNARY, 'not', $inner, $this->inParens]; return true; } $this->seek($s); if ($this->parenValue($inner)) { $out = [Type::T_UNARY, 'not', $inner, $this->inParens]; return true; } $this->seek($s); } if ($char === '+') { $this->count++; $follow_white = $this->whitespace(); if ($this->value($inner)) { $out = [Type::T_UNARY, '+', $inner, $this->inParens]; return true; } if ($follow_white) { $out = [Type::T_KEYWORD, $char]; return true; } $this->seek($s); return false; } if ($char === '-') { if ($this->customProperty($out)) { return true; } $this->count++; $follow_white = $this->whitespace(); if ($this->variable($inner) || $this->unit($inner) || $this->parenValue($inner)) { $out = [Type::T_UNARY, '-', $inner, $this->inParens]; return true; } if ( $this->keyword($inner) && ! $this->func($inner, $out) ) { $out = [Type::T_UNARY, '-', $inner, $this->inParens]; return true; } if ($follow_white) { $out = [Type::T_KEYWORD, $char]; return true; } $this->seek($s); } if ($char === '(' && $this->parenValue($out)) { return true; } if ($char === '#') { if ($this->interpolation($out) || $this->color($out)) { return true; } $this->count++; if ($this->keyword($keyword)) { $out = [Type::T_KEYWORD, '#' . $keyword]; return true; } $this->count--; } if ($this->matchChar('&', true)) { $out = [Type::T_SELF]; return true; } if ($char === '$' && $this->variable($out)) { return true; } if ($char === 'p' && $this->progid($out)) { return true; } if (($char === '"' || $char === "'") && $this->string($out)) { return true; } if ($this->unit($out)) { return true; } if ( $this->literal('U+', 2) && $this->match('\?+|([0-9A-F]+(\?+|(-[0-9A-F]+))?)', $m, false) ) { $unicode = explode('-', $m[0]); if (strlen(reset($unicode)) <= 6 && strlen(end($unicode)) <= 6) { $out = [Type::T_KEYWORD, 'U+' . $m[0]]; return true; } $this->count -= strlen($m[0]) + 2; } if ($this->keyword($keyword, false)) { if ($this->func($keyword, $out)) { return true; } $this->whitespace(); if ($keyword === 'null') { $out = [Type::T_NULL]; } else { $out = [Type::T_KEYWORD, $keyword]; } return true; } return false; } protected function parenValue(&$out) { $s = $this->count; $inParens = $this->inParens; if ($this->matchChar('(')) { if ($this->matchChar(')')) { $out = [Type::T_LIST, '', []]; return true; } $this->inParens = true; if ( $this->expression($exp) && $this->matchChar(')') ) { $out = $exp; $this->inParens = $inParens; return true; } } $this->inParens = $inParens; $this->seek($s); return false; } protected function progid(&$out) { $s = $this->count; if ( $this->literal('progid:', 7, false) && $this->openString('(', $fn) && $this->matchChar('(') ) { $this->openString(')', $args, '('); if ($this->matchChar(')')) { $out = [Type::T_STRING, '', [ 'progid:', $fn, '(', $args, ')' ]]; return true; } } $this->seek($s); return false; } protected function func($name, &$func) { $s = $this->count; if ($this->matchChar('(')) { if ($name === 'alpha' && $this->argumentList($args)) { $func = [Type::T_FUNCTION, $name, [Type::T_STRING, '', $args]]; return true; } if ($name !== 'expression' && ! preg_match('/^(-[a-z]+-)?calc$/', $name)) { $ss = $this->count; if ( $this->argValues($args) && $this->matchChar(')') ) { $func = [Type::T_FUNCTION_CALL, $name, $args]; return true; } $this->seek($ss); } if ( ($this->openString(')', $str, '(') || true) && $this->matchChar(')') ) { $args = []; if (! empty($str)) { $args[] = [null, [Type::T_STRING, '', [$str]]]; } $func = [Type::T_FUNCTION_CALL, $name, $args]; return true; } } $this->seek($s); return false; } protected function argumentList(&$out) { $s = $this->count; $this->matchChar('('); $args = []; while ($this->keyword($var)) { if ( $this->matchChar('=') && $this->expression($exp) ) { $args[] = [Type::T_STRING, '', [$var . '=']]; $arg = $exp; } else { break; } $args[] = $arg; if (! $this->matchChar(',')) { break; } $args[] = [Type::T_STRING, '', [', ']]; } if (! $this->matchChar(')') || ! $args) { $this->seek($s); return false; } $out = $args; return true; } protected function argumentDef(&$out) { $s = $this->count; $this->matchChar('('); $args = []; while ($this->variable($var)) { $arg = [$var[1], null, false]; $ss = $this->count; if ( $this->matchChar(':') && $this->genericList($defaultVal, 'expression', '', true) ) { $arg[1] = $defaultVal; } else { $this->seek($ss); } $ss = $this->count; if ($this->literal('...', 3)) { $sss = $this->count; if (! $this->matchChar(')')) { throw $this->parseError('... has to be after the final argument'); } $arg[2] = true; $this->seek($sss); } else { $this->seek($ss); } $args[] = $arg; if (! $this->matchChar(',')) { break; } } if (! $this->matchChar(')')) { $this->seek($s); return false; } $out = $args; return true; } protected function map(&$out) { $s = $this->count; if (! $this->matchChar('(')) { return false; } $keys = []; $values = []; while ( $this->genericList($key, 'expression', '', true) && $this->matchChar(':') && $this->genericList($value, 'expression', '', true) ) { $keys[] = $key; $values[] = $value; if (! $this->matchChar(',')) { break; } } if (! $keys || ! $this->matchChar(')')) { $this->seek($s); return false; } $out = [Type::T_MAP, $keys, $values]; return true; } protected function color(&$out) { $s = $this->count; if ($this->match('(#([0-9a-f]+)\b)', $m)) { if (\in_array(\strlen($m[2]), [3,4,6,8])) { $out = [Type::T_KEYWORD, $m[0]]; return true; } $this->seek($s); return false; } return false; } protected function unit(&$unit) { $s = $this->count; if ($this->match('([0-9]*(\.)?[0-9]+)([%a-zA-Z]+)?', $m, false)) { if (\strlen($this->buffer) === $this->count || ! ctype_digit($this->buffer[$this->count])) { $this->whitespace(); $unit = new Node\Number($m[1], empty($m[3]) ? '' : $m[3]); return true; } $this->seek($s); } return false; } protected function string(&$out, $keepDelimWithInterpolation = false) { $s = $this->count; if ($this->matchChar('"', false)) { $delim = '"'; } elseif ($this->matchChar("'", false)) { $delim = "'"; } else { return false; } $content = []; $oldWhite = $this->eatWhiteDefault; $this->eatWhiteDefault = false; $hasInterpolation = false; while ($this->matchString($m, $delim)) { if ($m[1] !== '') { $content[] = $m[1]; } if ($m[2] === '#{') { $this->count -= \strlen($m[2]); if ($this->interpolation($inter, false)) { $content[] = $inter; $hasInterpolation = true; } else { $this->count += \strlen($m[2]); $content[] = '#{'; } } elseif ($m[2] === "\r") { $content[] = chr(10); if ($this->matchChar("\n", false)) { $content[] = ' '; } } elseif ($m[2] === '\\') { if ( $this->literal("\r\n", 2, false) || $this->matchChar("\r", false) || $this->matchChar("\n", false) || $this->matchChar("\f", false) ) { } elseif ($this->matchEscapeCharacter($c)) { $content[] = $c; } else { throw $this->parseError('Unterminated escape sequence'); } } else { $this->count -= \strlen($delim); break; } } $this->eatWhiteDefault = $oldWhite; if ($this->literal($delim, \strlen($delim))) { if ($hasInterpolation && ! $keepDelimWithInterpolation) { $delim = '"'; } $out = [Type::T_STRING, $delim, $content]; return true; } $this->seek($s); return false; } protected function matchEscapeCharacter(&$out, $inKeywords = false) { $s = $this->count; if ($this->match('[a-f0-9]', $m, false)) { $hex = $m[0]; for ($i = 5; $i--;) { if ($this->match('[a-f0-9]', $m, false)) { $hex .= $m[0]; } else { break; } } $this->matchChar(' ', false); $value = hexdec($hex); if (!$inKeywords && ($value == 0 || ($value >= 0xD800 && $value <= 0xDFFF) || $value >= 0x10FFFF)) { $out = "\xEF\xBF\xBD"; } elseif ($value < 0x20) { $out = Util::mbChr($value); } else { $out = Util::mbChr($value); } return true; } if ($this->match('.', $m, false)) { if ($inKeywords && in_array($m[0], ["'",'"','@','&',' ','\\',':','/','%'])) { $this->seek($s); return false; } $out = $m[0]; return true; } return false; } protected function mixedKeyword(&$out, $restricted = false) { $parts = []; $oldWhite = $this->eatWhiteDefault; $this->eatWhiteDefault = false; for (;;) { if ($restricted ? $this->restrictedKeyword($key) : $this->keyword($key)) { $parts[] = $key; continue; } if ($this->interpolation($inter)) { $parts[] = $inter; continue; } break; } $this->eatWhiteDefault = $oldWhite; if (! $parts) { return false; } if ($this->eatWhiteDefault) { $this->whitespace(); } $out = $parts; return true; } protected function openString($end, &$out, $nestOpen = null, $nestClose = null, $rtrim = true, $disallow = null) { $oldWhite = $this->eatWhiteDefault; $this->eatWhiteDefault = false; if ($nestOpen && ! $nestClose) { $nestClose = $end; } $patt = ($disallow ? '[^' . $this->pregQuote($disallow) . ']' : '.'); $patt = '(' . $patt . '*?)([\'"]|#\{|' . $this->pregQuote($end) . '|' . (($nestClose && $nestClose !== $end) ? $this->pregQuote($nestClose) . '|' : '') . static::$commentPattern . ')'; $nestingLevel = 0; $content = []; while ($this->match($patt, $m, false)) { if (isset($m[1]) && $m[1] !== '') { $content[] = $m[1]; if ($nestOpen) { $nestingLevel += substr_count($m[1], $nestOpen); } } $tok = $m[2]; $this->count -= \strlen($tok); if ($tok === $end && ! $nestingLevel) { break; } if ($tok === $nestClose) { $nestingLevel--; } if (($tok === "'" || $tok === '"') && $this->string($str, true)) { $content[] = $str; continue; } if ($tok === '#{' && $this->interpolation($inter)) { $content[] = $inter; continue; } $content[] = $tok; $this->count += \strlen($tok); } $this->eatWhiteDefault = $oldWhite; if (! $content || $tok !== $end) { return false; } if ($rtrim && \is_string(end($content))) { $content[\count($content) - 1] = rtrim(end($content)); } $out = [Type::T_STRING, '', $content]; return true; } protected function interpolation(&$out, $lookWhite = true) { $oldWhite = $this->eatWhiteDefault; $allowVars = $this->allowVars; $this->allowVars = true; $this->eatWhiteDefault = true; $s = $this->count; if ( $this->literal('#{', 2) && $this->valueList($value) && $this->matchChar('}', false) ) { if ($value === [Type::T_SELF]) { $out = $value; } else { if ($lookWhite) { $left = ($s > 0 && preg_match('/\s/', $this->buffer[$s - 1])) ? ' ' : ''; $right = ( ! empty($this->buffer[$this->count]) && preg_match('/\s/', $this->buffer[$this->count]) ) ? ' ' : ''; } else { $left = $right = false; } $out = [Type::T_INTERPOLATE, $value, $left, $right]; } $this->eatWhiteDefault = $oldWhite; $this->allowVars = $allowVars; if ($this->eatWhiteDefault) { $this->whitespace(); } return true; } $this->seek($s); $this->eatWhiteDefault = $oldWhite; $this->allowVars = $allowVars; return false; } protected function propertyName(&$out) { $parts = []; $oldWhite = $this->eatWhiteDefault; $this->eatWhiteDefault = false; for (;;) { if ($this->interpolation($inter)) { $parts[] = $inter; continue; } if ($this->keyword($text)) { $parts[] = $text; continue; } if (! $parts && $this->match('[:.#]', $m, false)) { $parts[] = $m[0]; continue; } break; } $this->eatWhiteDefault = $oldWhite; if (! $parts) { return false; } if (preg_match(static::$whitePattern, $this->buffer, $m, 0, $this->count)) { if (! empty($m[0])) { $parts[] = $m[0]; $this->count += \strlen($m[0]); } } $this->whitespace(); $out = [Type::T_STRING, '', $parts]; return true; } protected function customProperty(&$out) { $s = $this->count; if (! $this->literal('--', 2, false)) { return false; } $parts = ['--']; $oldWhite = $this->eatWhiteDefault; $this->eatWhiteDefault = false; for (;;) { if ($this->interpolation($inter)) { $parts[] = $inter; continue; } if ($this->matchChar('&', false)) { $parts[] = [Type::T_SELF]; continue; } if ($this->variable($var)) { $parts[] = $var; continue; } if ($this->keyword($text)) { $parts[] = $text; continue; } break; } $this->eatWhiteDefault = $oldWhite; if (\count($parts) == 1) { $this->seek($s); return false; } $this->whitespace(); $out = [Type::T_STRING, '', $parts]; return true; } protected function selectors(&$out, $subSelector = false) { $s = $this->count; $selectors = []; while ($this->selector($sel, $subSelector)) { $selectors[] = $sel; if (! $this->matchChar(',', true)) { break; } while ($this->matchChar(',', true)) { ; } } if (! $selectors) { $this->seek($s); return false; } $out = $selectors; return true; } protected function selector(&$out, $subSelector = false) { $selector = []; $discardComments = $this->discardComments; $this->discardComments = true; for (;;) { $s = $this->count; if ($this->match('[>+~]+', $m, true)) { if ( $subSelector && \is_string($subSelector) && strpos($subSelector, 'nth-') === 0 && $m[0] === '+' && $this->match("(\d+|n\b)", $counter) ) { $this->seek($s); } else { $selector[] = [$m[0]]; continue; } } if ($this->selectorSingle($part, $subSelector)) { $selector[] = $part; $this->whitespace(); continue; } break; } $this->discardComments = $discardComments; if (! $selector) { return false; } $out = $selector; return true; } protected function matchEscapeCharacterInSelector(&$out, $keepEscapedNumber = false) { $s_escape = $this->count; if ($this->match('\\\\', $m)) { $out = '\\' . $m[0]; return true; } if ($this->matchEscapeCharacter($escapedout, true)) { if (strlen($escapedout) === 1) { if (!preg_match(",\w,", $escapedout)) { $out = '\\' . $escapedout; return true; } elseif (! $keepEscapedNumber || ! \is_numeric($escapedout)) { $out = $escapedout; return true; } } $escape_sequence = rtrim(substr($this->buffer, $s_escape, $this->count - $s_escape)); if (strlen($escape_sequence) < 6) { $escape_sequence .= ' '; } $out = '\\' . strtolower($escape_sequence); return true; } if ($this->match('\\S', $m)) { $out = '\\' . $m[0]; return true; } return false; } protected function selectorSingle(&$out, $subSelector = false) { $oldWhite = $this->eatWhiteDefault; $this->eatWhiteDefault = false; $parts = []; if ($this->matchChar('*', false)) { $parts[] = '*'; } for (;;) { if (! isset($this->buffer[$this->count])) { break; } $s = $this->count; $char = $this->buffer[$this->count]; if ($char === '{' || $char === ',' || $char === ';' || $char === '}' || $char === '@') { break; } if ($subSelector && $char === ')') { break; } switch ($char) { case '&': $parts[] = Compiler::$selfSelector; $this->count++; ! $this->cssOnly || $this->assertPlainCssValid(false, $s); continue 2; case '.': $parts[] = '.'; $this->count++; continue 2; case '|': $parts[] = '|'; $this->count++; continue 2; } if ($char === '\\') { $this->count++; if ($this->matchEscapeCharacterInSelector($escaped, true)) { $parts[] = $escaped; continue; } $this->count--; } if ($char === '%') { $this->count++; if ($this->placeholder($placeholder)) { $parts[] = '%'; $parts[] = $placeholder; ! $this->cssOnly || $this->assertPlainCssValid(false, $s); continue; } break; } if ($char === '#') { if ($this->interpolation($inter)) { $parts[] = $inter; ! $this->cssOnly || $this->assertPlainCssValid(false, $s); continue; } $parts[] = '#'; $this->count++; continue; } if ($char === ':') { if ($this->buffer[$this->count + 1] === ':') { $this->count += 2; $part = '::'; } else { $this->count++; $part = ':'; } if ($this->mixedKeyword($nameParts, true)) { $parts[] = $part; foreach ($nameParts as $sub) { $parts[] = $sub; } $ss = $this->count; if ( $nameParts === ['not'] || $nameParts === ['is'] || $nameParts === ['has'] || $nameParts === ['where'] || $nameParts === ['slotted'] || $nameParts === ['nth-child'] || $nameParts === ['nth-last-child'] || $nameParts === ['nth-of-type'] || $nameParts === ['nth-last-of-type'] ) { if ( $this->matchChar('(', true) && ($this->selectors($subs, reset($nameParts)) || true) && $this->matchChar(')') ) { $parts[] = '('; while ($sub = array_shift($subs)) { while ($ps = array_shift($sub)) { foreach ($ps as &$p) { $parts[] = $p; } if (\count($sub) && reset($sub)) { $parts[] = ' '; } } if (\count($subs) && reset($subs)) { $parts[] = ', '; } } $parts[] = ')'; } else { $this->seek($ss); } } elseif ( $this->matchChar('(', true) && ($this->openString(')', $str, '(') || true) && $this->matchChar(')') ) { $parts[] = '('; if (! empty($str)) { $parts[] = $str; } $parts[] = ')'; } else { $this->seek($ss); } continue; } } $this->seek($s); if ($subSelector && \is_string($subSelector) && strpos($subSelector, 'nth-') === 0) { if ($this->match("(\s*(\+\s*|\-\s*)?(\d+|n|\d+n))+", $counter)) { $parts[] = $counter[0]; continue; } } $this->seek($s); if ( $char === '[' && $this->matchChar('[') && ($this->openString(']', $str, '[') || true) && $this->matchChar(']') ) { $parts[] = '['; if (! empty($str)) { $parts[] = $str; } $parts[] = ']'; continue; } $this->seek($s); if ($this->unit($unit)) { $parts[] = $unit; continue; } if ($this->restrictedKeyword($name, false, true)) { $parts[] = $name; continue; } break; } $this->eatWhiteDefault = $oldWhite; if (! $parts) { return false; } $out = $parts; return true; } protected function variable(&$out) { $s = $this->count; if ( $this->matchChar('$', false) && $this->keyword($name) ) { if ($this->allowVars) { $out = [Type::T_VARIABLE, $name]; } else { $out = [Type::T_KEYWORD, '$' . $name]; } return true; } $this->seek($s); return false; } protected function keyword(&$word, $eatWhitespace = null, $inSelector = false) { $s = $this->count; $match = $this->match( $this->utf8 ? '(([\pL\w\x{00A0}-\x{10FFFF}_\-\*!"\']|\\\\[a-f0-9]{6} ?|\\\\[a-f0-9]{1,5}(?![a-f0-9]) ?|[\\\\].)([\pL\w\x{00A0}-\x{10FFFF}\-_"\']|\\\\[a-f0-9]{6} ?|\\\\[a-f0-9]{1,5}(?![a-f0-9]) ?|[\\\\].)*)' : '(([\w_\-\*!"\']|\\\\[a-f0-9]{6} ?|\\\\[a-f0-9]{1,5}(?![a-f0-9]) ?|[\\\\].)([\w\-_"\']|\\\\[a-f0-9]{6} ?|\\\\[a-f0-9]{1,5}(?![a-f0-9]) ?|[\\\\].)*)', $m, false ); if ($match) { $word = $m[1]; if (strpos($word, '\\') !== false) { $send = $this->count; $escapedWord = []; $this->seek($s); $previousEscape = false; while ($this->count < $send) { $char = $this->buffer[$this->count]; $this->count++; if ( $this->count < $send && $char === '\\' && !$previousEscape && ( $inSelector ? $this->matchEscapeCharacterInSelector($out) : $this->matchEscapeCharacter($out, true) ) ) { $escapedWord[] = $out; } else { if ($previousEscape) { $previousEscape = false; } elseif ($char === '\\') { $previousEscape = true; } $escapedWord[] = $char; } } $word = implode('', $escapedWord); } if (is_null($eatWhitespace) ? $this->eatWhiteDefault : $eatWhitespace) { $this->whitespace(); } return true; } return false; } protected function restrictedKeyword(&$word, $eatWhitespace = null, $inSelector = false) { $s = $this->count; if ($this->keyword($word, $eatWhitespace, $inSelector) && (\ord($word[0]) > 57 || \ord($word[0]) < 48)) { return true; } $this->seek($s); return false; } protected function placeholder(&$placeholder) { $match = $this->match( $this->utf8 ? '([\pL\w\-_]+)' : '([\w\-_]+)', $m ); if ($match) { $placeholder = $m[1]; return true; } if ($this->interpolation($placeholder)) { return true; } return false; } protected function url(&$out) { if ($this->literal('url(', 4)) { $s = $this->count; if ( ($this->string($out) || $this->spaceList($out)) && $this->matchChar(')') ) { $out = [Type::T_STRING, '', ['url(', $out, ')']]; return true; } $this->seek($s); if ( $this->openString(')', $out) && $this->matchChar(')') ) { $out = [Type::T_STRING, '', ['url(', $out, ')']]; return true; } } return false; } protected function end($eatWhitespace = null) { if ($this->matchChar(';', $eatWhitespace)) { return true; } if ($this->count === \strlen($this->buffer) || $this->buffer[$this->count] === '}') { return true; } return false; } protected function stripAssignmentFlags(&$value) { $flags = []; for ($token = &$value; $token[0] === Type::T_LIST && ($s = \count($token[2])); $token = &$lastNode) { $lastNode = &$token[2][$s - 1]; while ($lastNode[0] === Type::T_KEYWORD && \in_array($lastNode[1], ['!default', '!global'])) { array_pop($token[2]); $node = end($token[2]); $token = $this->flattenList($token); $flags[] = $lastNode[1]; $lastNode = $node; } } return $flags; } protected function stripOptionalFlag(&$selectors) { $optional = false; $selector = end($selectors); $part = end($selector); if ($part === ['!optional']) { array_pop($selectors[\count($selectors) - 1]); $optional = true; } return $optional; } protected function flattenList($value) { if ($value[0] === Type::T_LIST && \count($value[2]) === 1) { return $this->flattenList($value[2][0]); } return $value; } private function pregQuote($what) { return preg_quote($what, '/'); } private function extractLineNumbers($buffer) { $this->sourcePositions = [0 => 0]; $prev = 0; while (($pos = strpos($buffer, "\n", $prev)) !== false) { $this->sourcePositions[] = $pos; $prev = $pos + 1; } $this->sourcePositions[] = \strlen($buffer); if (substr($buffer, -1) !== "\n") { $this->sourcePositions[] = \strlen($buffer) + 1; } } private function getSourcePosition($pos) { $low = 0; $high = \count($this->sourcePositions); while ($low < $high) { $mid = (int) (($high + $low) / 2); if ($pos < $this->sourcePositions[$mid]) { $high = $mid - 1; continue; } if ($pos >= $this->sourcePositions[$mid + 1]) { $low = $mid + 1; continue; } return [$mid + 1, $pos - $this->sourcePositions[$mid]]; } return [$low + 1, $pos - $this->sourcePositions[$low]]; } private function saveEncoding() { if (\PHP_VERSION_ID < 80000 && \extension_loaded('mbstring') && (2 & (int) ini_get('mbstring.func_overload')) > 0) { $this->encoding = mb_internal_encoding(); mb_internal_encoding('iso-8859-1'); } } private function restoreEncoding() { if (\extension_loaded('mbstring') && $this->encoding) { mb_internal_encoding($this->encoding); } } } class Type { const T_ASSIGN = 'assign'; const T_AT_ROOT = 'at-root'; const T_BLOCK = 'block'; const T_BREAK = 'break'; const T_CHARSET = 'charset'; const T_COLOR = 'color'; const T_COMMENT = 'comment'; const T_CONTINUE = 'continue'; const T_CONTROL = 'control'; const T_CUSTOM_PROPERTY = 'custom'; const T_DEBUG = 'debug'; const T_DIRECTIVE = 'directive'; const T_EACH = 'each'; const T_ELSE = 'else'; const T_ELSEIF = 'elseif'; const T_ERROR = 'error'; const T_EXPRESSION = 'exp'; const T_EXTEND = 'extend'; const T_FOR = 'for'; const T_FUNCTION = 'function'; const T_FUNCTION_REFERENCE = 'function-reference'; const T_FUNCTION_CALL = 'fncall'; const T_HSL = 'hsl'; const T_HWB = 'hwb'; const T_IF = 'if'; const T_IMPORT = 'import'; const T_INCLUDE = 'include'; const T_INTERPOLATE = 'interpolate'; const T_INTERPOLATED = 'interpolated'; const T_KEYWORD = 'keyword'; const T_LIST = 'list'; const T_MAP = 'map'; const T_MEDIA = 'media'; const T_MEDIA_EXPRESSION = 'mediaExp'; const T_MEDIA_TYPE = 'mediaType'; const T_MEDIA_VALUE = 'mediaValue'; const T_MIXIN = 'mixin'; const T_MIXIN_CONTENT = 'mixin_content'; const T_NESTED_PROPERTY = 'nestedprop'; const T_NOT = 'not'; const T_NULL = 'null'; const T_NUMBER = 'number'; const T_RETURN = 'return'; const T_ROOT = 'root'; const T_SCSSPHP_IMPORT_ONCE = 'scssphp-import-once'; const T_SELF = 'self'; const T_STRING = 'string'; const T_UNARY = 'unary'; const T_VARIABLE = 'var'; const T_WARN = 'warn'; const T_WHILE = 'while'; } class Util { public static function checkRange($name, Range $range, $value, $unit = '') { $val = $value[1]; $grace = new Range(-0.00001, 0.00001); if (! \is_numeric($val)) { throw new RangeException("$name {$val} is not a number."); } if ($range->includes($val)) { return $val; } if ($grace->includes($val - $range->first)) { return $range->first; } if ($grace->includes($val - $range->last)) { return $range->last; } throw new RangeException("$name {$val} must be between {$range->first} and {$range->last}$unit"); } public static function encodeURIComponent($string) { $revert = ['%21' => '!', '%2A' => '*', '%27' => "'", '%28' => '(', '%29' => ')']; return strtr(rawurlencode($string), $revert); } public static function mbChr($code) { if (\PHP_VERSION_ID > 70300 && \function_exists('mb_chr')) { return mb_chr($code, 'UTF-8'); } if (0x80 > $code %= 0x200000) { $s = \chr($code); } elseif (0x800 > $code) { $s = \chr(0xC0 | $code >> 6) . \chr(0x80 | $code & 0x3F); } elseif (0x10000 > $code) { $s = \chr(0xE0 | $code >> 12) . \chr(0x80 | $code >> 6 & 0x3F) . \chr(0x80 | $code & 0x3F); } else { $s = \chr(0xF0 | $code >> 18) . \chr(0x80 | $code >> 12 & 0x3F) . \chr(0x80 | $code >> 6 & 0x3F) . \chr(0x80 | $code & 0x3F); } return $s; } public static function mbStrlen($string) { if (\function_exists('mb_strlen')) { return mb_strlen($string, 'UTF-8'); } if (\function_exists('iconv_strlen')) { return (int) @iconv_strlen($string, 'UTF-8'); } throw new \LogicException('Either mbstring (recommended) or iconv is necessary to use Scssphp.'); } public static function mbSubstr($string, $start, $length = null) { if (\function_exists('mb_substr')) { return mb_substr($string, $start, $length, 'UTF-8'); } if (\function_exists('iconv_substr')) { if ($start < 0) { $start = static::mbStrlen($string) + $start; if ($start < 0) { $start = 0; } } if (null === $length) { $length = 2147483647; } elseif ($length < 0) { $length = static::mbStrlen($string) + $length - $start; if ($length < 0) { return ''; } } return (string)iconv_substr($string, $start, $length, 'UTF-8'); } throw new \LogicException('Either mbstring (recommended) or iconv is necessary to use Scssphp.'); } public static function mbStrpos($haystack, $needle, $offset = 0) { if (\function_exists('mb_strpos')) { return mb_strpos($haystack, $needle, $offset, 'UTF-8'); } if (\function_exists('iconv_strpos')) { return iconv_strpos($haystack, $needle, $offset, 'UTF-8'); } throw new \LogicException('Either mbstring (recommended) or iconv is necessary to use Scssphp.'); } } final class ValueConverter { private function __construct() { } public static function parseValue($source) { $parser = new Parser(__CLASS__); if (!$parser->parseValue($source, $value)) { throw new \InvalidArgumentException(sprintf('Invalid value source "%s".', $source)); } return $value; } public static function fromPhp($value) { if ($value instanceof Number) { return $value; } if (is_array($value) && isset($value[0]) && \in_array($value[0], [Type::T_NULL, Type::T_COLOR, Type::T_KEYWORD, Type::T_LIST, Type::T_MAP, Type::T_STRING])) { return $value; } if ($value === null) { return Compiler::$null; } if ($value === true) { return Compiler::$true; } if ($value === false) { return Compiler::$false; } if ($value === '') { return Compiler::$emptyString; } if (\is_int($value) || \is_float($value)) { return new Number($value, ''); } if (\is_string($value)) { return [Type::T_STRING, '"', [$value]]; } throw new \InvalidArgumentException(sprintf('Cannot convert the value of type "%s" to a Sass value.', gettype($value))); } } class Version { const VERSION = '1.10.5'; } final class Warn { private static $callback; public static function warning($message) { self::reportWarning($message, false); } public static function deprecation($message) { self::reportWarning($message, true); } public static function setCallback(callable $callback = null) { $previousCallback = self::$callback; self::$callback = $callback; return $previousCallback; } private static function reportWarning($message, $deprecation) { if (self::$callback === null) { throw new \BadMethodCallException('The warning Reporter may only be called within a custom function or importer callback.'); } \call_user_func(self::$callback, $message, $deprecation); } } } namespace ScssPhp\ScssPhp\Base{ class Range { public $first; public $last; public function __construct($first, $last) { $this->first = $first; $this->last = $last; } public function includes($value) { return $value >= $this->first && $value <= $this->last; } } } namespace ScssPhp\ScssPhp\Block{ use ScssPhp\ScssPhp\Block; use ScssPhp\ScssPhp\Type; use ScssPhp\ScssPhp\Compiler\Environment; class AtRootBlock extends Block { public $selector; public $with; public function __construct() { $this->type = Type::T_AT_ROOT; } } class CallableBlock extends Block { public $name; public $args; public $parentEnv; public function __construct($type) { $this->type = $type; } } class ContentBlock extends Block { public $child; public $scope; public function __construct() { $this->type = Type::T_INCLUDE; } } class DirectiveBlock extends Block { public $name; public $value; public function __construct() { $this->type = Type::T_DIRECTIVE; } } class EachBlock extends Block { public $vars = []; public $list; public function __construct() { $this->type = Type::T_EACH; } } class ElseBlock extends Block { public function __construct() { $this->type = Type::T_ELSE; } } class ElseifBlock extends Block { public $cond; public function __construct() { $this->type = Type::T_ELSEIF; } } class ForBlock extends Block { public $var; public $start; public $end; public $until; public function __construct() { $this->type = Type::T_FOR; } } class IfBlock extends Block { public $cond; public $cases = []; public function __construct() { $this->type = Type::T_IF; } } class MediaBlock extends Block { public $value; public $queryList; public function __construct() { $this->type = Type::T_MEDIA; } } class NestedPropertyBlock extends Block { public $hasValue; public $prefix; public function __construct() { $this->type = Type::T_NESTED_PROPERTY; } } class WhileBlock extends Block { public $cond; public function __construct() { $this->type = Type::T_WHILE; } } } namespace ScssPhp\ScssPhp\Compiler{ use ScssPhp\ScssPhp\CompilationResult; class CachedResult { private $result; private $parsedFiles; private $resolvedImports; public function __construct(CompilationResult $result, array $parsedFiles, array $resolvedImports) { $this->result = $result; $this->parsedFiles = $parsedFiles; $this->resolvedImports = $resolvedImports; } public function getResult() { return $this->result; } public function getParsedFiles() { return $this->parsedFiles; } public function getResolvedImports() { return $this->resolvedImports; } } class Environment { public $block; public $parent; public $declarationScopeParent; public $parentStore; public $selectors; public $marker; public $store; public $storeUnreduced; public $depth; } } namespace ScssPhp\ScssPhp\Exception{ class CompilerException extends \Exception implements SassException { } class ParserException extends \Exception implements SassException { private $sourcePosition; public function getSourcePosition() { return $this->sourcePosition; } public function setSourcePosition($sourcePosition) { $this->sourcePosition = $sourcePosition; } } class RangeException extends \Exception implements SassException { } interface SassException { } class SassScriptException extends \Exception { public static function forArgument($message, $name = null) { $varDisplay = !\is_null($name) ? "\${$name}: " : ''; return new self($varDisplay . $message); } } @trigger_error(sprintf('The "%s" class is deprecated.', ServerException::class), E_USER_DEPRECATED); class ServerException extends \Exception implements SassException { } } namespace ScssPhp\ScssPhp\Formatter{ use ScssPhp\ScssPhp\Formatter; use ScssPhp\ScssPhp\Type; class Compact extends Formatter { public function __construct() { @trigger_error('The Compact formatter is deprecated since 1.4.0. Use the Compressed formatter instead.', E_USER_DEPRECATED); $this->indentLevel = 0; $this->indentChar = ''; $this->break = ''; $this->open = ' {'; $this->close = "}\n\n"; $this->tagSeparator = ','; $this->assignSeparator = ':'; $this->keepSemicolons = true; } public function indentStr() { return ' '; } } class Compressed extends Formatter { public function __construct() { $this->indentLevel = 0; $this->indentChar = '  '; $this->break = ''; $this->open = '{'; $this->close = '}'; $this->tagSeparator = ','; $this->assignSeparator = ':'; $this->keepSemicolons = false; } public function blockLines(OutputBlock $block) { $inner = $this->indentStr(); $glue = $this->break . $inner; foreach ($block->lines as $index => $line) { if (substr($line, 0, 2) === '/*' && substr($line, 2, 1) !== '!') { unset($block->lines[$index]); } } $this->write($inner . implode($glue, $block->lines)); if (! empty($block->children)) { $this->write($this->break); } } protected function blockSelectors(OutputBlock $block) { assert(! empty($block->selectors)); $inner = $this->indentStr(); $this->write( $inner . implode( $this->tagSeparator, str_replace([' > ', ' + ', ' ~ '], ['>', '+', '~'], $block->selectors) ) . $this->open . $this->break ); } } class Crunched extends Formatter { public function __construct() { @trigger_error('The Crunched formatter is deprecated since 1.4.0. Use the Compressed formatter instead.', E_USER_DEPRECATED); $this->indentLevel = 0; $this->indentChar = '  '; $this->break = ''; $this->open = '{'; $this->close = '}'; $this->tagSeparator = ','; $this->assignSeparator = ':'; $this->keepSemicolons = false; } public function blockLines(OutputBlock $block) { $inner = $this->indentStr(); $glue = $this->break . $inner; foreach ($block->lines as $index => $line) { if (substr($line, 0, 2) === '/*') { unset($block->lines[$index]); } } $this->write($inner . implode($glue, $block->lines)); if (! empty($block->children)) { $this->write($this->break); } } protected function blockSelectors(OutputBlock $block) { assert(! empty($block->selectors)); $inner = $this->indentStr(); $this->write( $inner . implode( $this->tagSeparator, str_replace([' > ', ' + ', ' ~ '], ['>', '+', '~'], $block->selectors) ) . $this->open . $this->break ); } } class Debug extends Formatter { public function __construct() { @trigger_error('The Debug formatter is deprecated since 1.4.0.', E_USER_DEPRECATED); $this->indentLevel = 0; $this->indentChar = ''; $this->break = "\n"; $this->open = ' {'; $this->close = ' }'; $this->tagSeparator = ', '; $this->assignSeparator = ': '; $this->keepSemicolons = true; } protected function indentStr() { return str_repeat('  ', $this->indentLevel); } protected function blockLines(OutputBlock $block) { $indent = $this->indentStr(); if (empty($block->lines)) { $this->write("{$indent}block->lines: []\n"); return; } foreach ($block->lines as $index => $line) { $this->write("{$indent}block->lines[{$index}]: $line\n"); } } protected function blockSelectors(OutputBlock $block) { $indent = $this->indentStr(); if (empty($block->selectors)) { $this->write("{$indent}block->selectors: []\n"); return; } foreach ($block->selectors as $index => $selector) { $this->write("{$indent}block->selectors[{$index}]: $selector\n"); } } protected function blockChildren(OutputBlock $block) { $indent = $this->indentStr(); if (empty($block->children)) { $this->write("{$indent}block->children: []\n"); return; } $this->indentLevel++; foreach ($block->children as $i => $child) { $this->block($child); } $this->indentLevel--; } protected function block(OutputBlock $block) { $indent = $this->indentStr(); $this->write("{$indent}block->type: {$block->type}\n" . "{$indent}block->depth: {$block->depth}\n"); $this->currentBlock = $block; $this->blockSelectors($block); $this->blockLines($block); $this->blockChildren($block); } } class Expanded extends Formatter { public function __construct() { $this->indentLevel = 0; $this->indentChar = '  '; $this->break = "\n"; $this->open = ' {'; $this->close = '}'; $this->tagSeparator = ', '; $this->assignSeparator = ': '; $this->keepSemicolons = true; } protected function indentStr() { return str_repeat($this->indentChar, $this->indentLevel); } protected function blockLines(OutputBlock $block) { $inner = $this->indentStr(); $glue = $this->break . $inner; foreach ($block->lines as $index => $line) { if (substr($line, 0, 2) === '/*') { $replacedLine = preg_replace('/\r\n?|\n|\f/', $this->break, $line); assert($replacedLine !== null); $block->lines[$index] = $replacedLine; } } $this->write($inner . implode($glue, $block->lines)); if (empty($block->selectors) || ! empty($block->children)) { $this->write($this->break); } } } class Nested extends Formatter { private $depth; public function __construct() { @trigger_error('The Nested formatter is deprecated since 1.4.0. Use the Expanded formatter instead.', E_USER_DEPRECATED); $this->indentLevel = 0; $this->indentChar = '  '; $this->break = "\n"; $this->open = ' {'; $this->close = ' }'; $this->tagSeparator = ', '; $this->assignSeparator = ': '; $this->keepSemicolons = true; } protected function indentStr() { $n = $this->depth - 1; return str_repeat($this->indentChar, max($this->indentLevel + $n, 0)); } protected function blockLines(OutputBlock $block) { $inner = $this->indentStr(); $glue = $this->break . $inner; foreach ($block->lines as $index => $line) { if (substr($line, 0, 2) === '/*') { $replacedLine = preg_replace('/\r\n?|\n|\f/', $this->break, $line); assert($replacedLine !== null); $block->lines[$index] = $replacedLine; } } $this->write($inner . implode($glue, $block->lines)); } protected function block(OutputBlock $block) { static $depths; static $downLevel; static $closeBlock; static $previousEmpty; static $previousHasSelector; if ($block->type === 'root') { $depths = [ 0 ]; $downLevel = ''; $closeBlock = ''; $this->depth = 0; $previousEmpty = false; $previousHasSelector = false; } $isMediaOrDirective = \in_array($block->type, [Type::T_DIRECTIVE, Type::T_MEDIA]); $isSupport = ($block->type === Type::T_DIRECTIVE && $block->selectors && strpos(implode('', $block->selectors), '@supports') !== false); while ($block->depth < end($depths) || ($block->depth == 1 && end($depths) == 1)) { array_pop($depths); $this->depth--; if ( ! $this->depth && ($block->depth <= 1 || (! $this->indentLevel && $block->type === Type::T_COMMENT)) && (($block->selectors && ! $isMediaOrDirective) || $previousHasSelector) ) { $downLevel = $this->break; } if (empty($block->lines) && empty($block->children)) { $previousEmpty = true; } } if (empty($block->lines) && empty($block->children)) { return; } $this->currentBlock = $block; if (! empty($block->lines) || (! empty($block->children) && ($this->depth < 1 || $isSupport))) { if ($block->depth > end($depths)) { if (! $previousEmpty || $this->depth < 1) { $this->depth++; $depths[] = $block->depth; } else { array_pop($depths); $depths[] = $block->depth; } } } $previousEmpty = ($block->type === Type::T_COMMENT); $previousHasSelector = false; if (! empty($block->selectors)) { if ($closeBlock) { $this->write($closeBlock); $closeBlock = ''; } if ($downLevel) { $this->write($downLevel); $downLevel = ''; } $this->blockSelectors($block); $this->indentLevel++; } if (! empty($block->lines)) { if ($closeBlock) { $this->write($closeBlock); $closeBlock = ''; } if ($downLevel) { $this->write($downLevel); $downLevel = ''; } $this->blockLines($block); $closeBlock = $this->break; } if (! empty($block->children)) { if ($this->depth > 0 && ($isMediaOrDirective || ! $this->hasFlatChild($block))) { array_pop($depths); $this->depth--; $this->blockChildren($block); $this->depth++; $depths[] = $block->depth; } else { $this->blockChildren($block); } } if ($block->type === Type::T_DIRECTIVE) { $previousHasSelector = false; } if (! empty($block->selectors)) { $this->indentLevel--; if (! $this->keepSemicolons) { $this->strippedSemicolon = ''; } $this->write($this->close); $closeBlock = $this->break; if ($this->depth > 1 && ! empty($block->children)) { array_pop($depths); $this->depth--; } if (! $isMediaOrDirective) { $previousHasSelector = true; } } if ($block->type === 'root') { $this->write($this->break); } } private function hasFlatChild($block) { foreach ($block->children as $child) { if (empty($child->selectors)) { return true; } } return false; } } class OutputBlock { public $type; public $depth; public $selectors; public $lines; public $children; public $parent; public $sourceName; public $sourceLine; public $sourceColumn; } } namespace ScssPhp\ScssPhp\Logger{ interface LoggerInterface { public function warn($message, $deprecation = false); public function debug($message); } class QuietLogger implements LoggerInterface { public function warn($message, $deprecation = false) { } public function debug($message) { } } class StreamLogger implements LoggerInterface { private $stream; private $closeOnDestruct; public function __construct($stream, $closeOnDestruct = false) { $this->stream = $stream; $this->closeOnDestruct = $closeOnDestruct; } public function __destruct() { if ($this->closeOnDestruct) { fclose($this->stream); } } public function warn($message, $deprecation = false) { $prefix = ($deprecation ? 'DEPRECATION ' : '') . 'WARNING: '; fwrite($this->stream, $prefix . $message . "\n\n"); } public function debug($message) { fwrite($this->stream, $message . "\n"); } } } namespace ScssPhp\ScssPhp\Node{ use ScssPhp\ScssPhp\Base\Range; use ScssPhp\ScssPhp\Compiler; use ScssPhp\ScssPhp\Exception\RangeException; use ScssPhp\ScssPhp\Exception\SassScriptException; use ScssPhp\ScssPhp\Node; use ScssPhp\ScssPhp\Type; use ScssPhp\ScssPhp\Util; class Number extends Node implements \ArrayAccess { const PRECISION = 10; public static $precision = self::PRECISION; protected static $unitTable = [ 'in' => [ 'in' => 1, 'pc' => 6, 'pt' => 72, 'px' => 96, 'cm' => 2.54, 'mm' => 25.4, 'q' => 101.6, ], 'turn' => [ 'deg' => 360, 'grad' => 400, 'rad' => 6.28318530717958647692528676, 'turn' => 1, ], 's' => [ 's' => 1, 'ms' => 1000, ], 'Hz' => [ 'Hz' => 1, 'kHz' => 0.001, ], 'dpi' => [ 'dpi' => 1, 'dpcm' => 1 / 2.54, 'dppx' => 1 / 96, ], ]; private $dimension; private $numeratorUnits; private $denominatorUnits; public function __construct($dimension, $numeratorUnits, array $denominatorUnits = []) { if (is_string($numeratorUnits)) { $numeratorUnits = $numeratorUnits ? [$numeratorUnits] : []; } elseif (isset($numeratorUnits['numerator_units'], $numeratorUnits['denominator_units'])) { $denominatorUnits = $numeratorUnits['denominator_units']; $numeratorUnits = $numeratorUnits['numerator_units']; } $this->dimension = $dimension; $this->numeratorUnits = $numeratorUnits; $this->denominatorUnits = $denominatorUnits; } public function getDimension() { return $this->dimension; } public function getNumeratorUnits() { return $this->numeratorUnits; } public function getDenominatorUnits() { return $this->denominatorUnits; } #[\ReturnTypeWillChange] public function offsetExists($offset) { if ($offset === -3) { return ! \is_null($this->sourceColumn); } if ($offset === -2) { return ! \is_null($this->sourceLine); } if ( $offset === -1 || $offset === 0 || $offset === 1 || $offset === 2 ) { return true; } return false; } #[\ReturnTypeWillChange] public function offsetGet($offset) { switch ($offset) { case -3: return $this->sourceColumn; case -2: return $this->sourceLine; case -1: return $this->sourceIndex; case 0: return Type::T_NUMBER; case 1: return $this->dimension; case 2: return array('numerator_units' => $this->numeratorUnits, 'denominator_units' => $this->denominatorUnits); } } #[\ReturnTypeWillChange] public function offsetSet($offset, $value) { throw new \BadMethodCallException('Number is immutable'); } #[\ReturnTypeWillChange] public function offsetUnset($offset) { throw new \BadMethodCallException('Number is immutable'); } public function unitless() { return \count($this->numeratorUnits) === 0 && \count($this->denominatorUnits) === 0; } public function hasUnit($unit) { return \count($this->numeratorUnits) === 1 && \count($this->denominatorUnits) === 0 && $this->numeratorUnits[0] === $unit; } public function unitStr() { if ($this->unitless()) { return ''; } return self::getUnitString($this->numeratorUnits, $this->denominatorUnits); } public function valueInRange($min, $max, $name = null) { try { return Util::checkRange('', new Range($min, $max), $this); } catch (RangeException $e) { throw SassScriptException::forArgument(sprintf('Expected %s to be within %s%s and %s%3$s', $this, $min, $this->unitStr(), $max), $name); } } public function assertNoUnits($varName = null) { if ($this->unitless()) { return; } throw SassScriptException::forArgument(sprintf('Expected %s to have no units.', $this), $varName); } public function assertUnit($unit, $varName = null) { if ($this->hasUnit($unit)) { return; } throw SassScriptException::forArgument(sprintf('Expected %s to have unit "%s".', $this, $unit), $varName); } public function assertSameUnitOrUnitless(Number $other) { if ($other->unitless()) { return; } if ($this->numeratorUnits === $other->numeratorUnits && $this->denominatorUnits === $other->denominatorUnits) { return; } throw new SassScriptException(sprintf( 'Incompatible units %s and %s.', self::getUnitString($this->numeratorUnits, $this->denominatorUnits), self::getUnitString($other->numeratorUnits, $other->denominatorUnits) )); } public function coerce(array $newNumeratorUnits, array $newDenominatorUnits) { return new Number($this->valueInUnits($newNumeratorUnits, $newDenominatorUnits), $newNumeratorUnits, $newDenominatorUnits); } public function isComparableTo(Number $other) { if ($this->unitless() || $other->unitless()) { return true; } try { $this->greaterThan($other); return true; } catch (SassScriptException $e) { return false; } } public function lessThan(Number $other) { return $this->coerceUnits($other, function ($num1, $num2) { return $num1 < $num2; }); } public function lessThanOrEqual(Number $other) { return $this->coerceUnits($other, function ($num1, $num2) { return $num1 <= $num2; }); } public function greaterThan(Number $other) { return $this->coerceUnits($other, function ($num1, $num2) { return $num1 > $num2; }); } public function greaterThanOrEqual(Number $other) { return $this->coerceUnits($other, function ($num1, $num2) { return $num1 >= $num2; }); } public function plus(Number $other) { return $this->coerceNumber($other, function ($num1, $num2) { return $num1 + $num2; }); } public function minus(Number $other) { return $this->coerceNumber($other, function ($num1, $num2) { return $num1 - $num2; }); } public function unaryMinus() { return new Number(-$this->dimension, $this->numeratorUnits, $this->denominatorUnits); } public function modulo(Number $other) { return $this->coerceNumber($other, function ($num1, $num2) { if ($num2 == 0) { return NAN; } $result = fmod($num1, $num2); if ($result == 0) { return 0; } if ($num2 < 0 xor $num1 < 0) { $result += $num2; } return $result; }); } public function times(Number $other) { return $this->multiplyUnits($this->dimension * $other->dimension, $this->numeratorUnits, $this->denominatorUnits, $other->numeratorUnits, $other->denominatorUnits); } public function dividedBy(Number $other) { if ($other->dimension == 0) { if ($this->dimension == 0) { $value = NAN; } elseif ($this->dimension > 0) { $value = INF; } else { $value = -INF; } } else { $value = $this->dimension / $other->dimension; } return $this->multiplyUnits($value, $this->numeratorUnits, $this->denominatorUnits, $other->denominatorUnits, $other->numeratorUnits); } public function equals(Number $other) { if ($this->unitless() !== $other->unitless()) { return false; } if (is_nan($this->dimension) || is_nan($other->dimension) || !is_finite($this->dimension) || !is_finite($other->dimension)) { return false; } if ($this->unitless()) { return round($this->dimension, self::PRECISION) == round($other->dimension, self::PRECISION); } try { return $this->coerceUnits($other, function ($num1, $num2) { return round($num1,self::PRECISION) == round($num2, self::PRECISION); }); } catch (SassScriptException $e) { return false; } } public function output(Compiler $compiler = null) { $dimension = round($this->dimension, self::PRECISION); if (is_nan($dimension)) { return 'NaN'; } if ($dimension === INF) { return 'Infinity'; } if ($dimension === -INF) { return '-Infinity'; } if ($compiler) { $unit = $this->unitStr(); } elseif (isset($this->numeratorUnits[0])) { $unit = $this->numeratorUnits[0]; } else { $unit = ''; } $dimension = number_format($dimension, self::PRECISION, '.', ''); return rtrim(rtrim($dimension, '0'), '.') . $unit; } public function __toString() { return $this->output(); } private function coerceNumber(Number $other, $operation) { $result = $this->coerceUnits($other, $operation); if (!$this->unitless()) { return new Number($result, $this->numeratorUnits, $this->denominatorUnits); } return new Number($result, $other->numeratorUnits, $other->denominatorUnits); } private function coerceUnits(Number $other, $operation) { if (!$this->unitless()) { $num1 = $this->dimension; $num2 = $other->valueInUnits($this->numeratorUnits, $this->denominatorUnits); } else { $num1 = $this->valueInUnits($other->numeratorUnits, $other->denominatorUnits); $num2 = $other->dimension; } return \call_user_func($operation, $num1, $num2); } private function valueInUnits(array $numeratorUnits, array $denominatorUnits) { if ( $this->unitless() || (\count($numeratorUnits) === 0 && \count($denominatorUnits) === 0) || ($this->numeratorUnits === $numeratorUnits && $this->denominatorUnits === $denominatorUnits) ) { return $this->dimension; } $value = $this->dimension; $oldNumerators = $this->numeratorUnits; foreach ($numeratorUnits as $newNumerator) { foreach ($oldNumerators as $key => $oldNumerator) { $conversionFactor = self::getConversionFactor($newNumerator, $oldNumerator); if (\is_null($conversionFactor)) { continue; } $value *= $conversionFactor; unset($oldNumerators[$key]); continue 2; } throw new SassScriptException(sprintf( 'Incompatible units %s and %s.', self::getUnitString($this->numeratorUnits, $this->denominatorUnits), self::getUnitString($numeratorUnits, $denominatorUnits) )); } $oldDenominators = $this->denominatorUnits; foreach ($denominatorUnits as $newDenominator) { foreach ($oldDenominators as $key => $oldDenominator) { $conversionFactor = self::getConversionFactor($newDenominator, $oldDenominator); if (\is_null($conversionFactor)) { continue; } $value /= $conversionFactor; unset($oldDenominators[$key]); continue 2; } throw new SassScriptException(sprintf( 'Incompatible units %s and %s.', self::getUnitString($this->numeratorUnits, $this->denominatorUnits), self::getUnitString($numeratorUnits, $denominatorUnits) )); } if (\count($oldNumerators) || \count($oldDenominators)) { throw new SassScriptException(sprintf( 'Incompatible units %s and %s.', self::getUnitString($this->numeratorUnits, $this->denominatorUnits), self::getUnitString($numeratorUnits, $denominatorUnits) )); } return $value; } private function multiplyUnits($value, array $numerators1, array $denominators1, array $numerators2, array $denominators2) { $newNumerators = array(); foreach ($numerators1 as $numerator) { foreach ($denominators2 as $key => $denominator) { $conversionFactor = self::getConversionFactor($numerator, $denominator); if (\is_null($conversionFactor)) { continue; } $value /= $conversionFactor; unset($denominators2[$key]); continue 2; } $newNumerators[] = $numerator; } foreach ($numerators2 as $numerator) { foreach ($denominators1 as $key => $denominator) { $conversionFactor = self::getConversionFactor($numerator, $denominator); if (\is_null($conversionFactor)) { continue; } $value /= $conversionFactor; unset($denominators1[$key]); continue 2; } $newNumerators[] = $numerator; } $newDenominators = array_values(array_merge($denominators1, $denominators2)); return new Number($value, $newNumerators, $newDenominators); } private static function getConversionFactor($unit1, $unit2) { if ($unit1 === $unit2) { return 1; } foreach (static::$unitTable as $unitVariants) { if (isset($unitVariants[$unit1]) && isset($unitVariants[$unit2])) { return $unitVariants[$unit1] / $unitVariants[$unit2]; } } return null; } private static function getUnitString(array $numerators, array $denominators) { if (!\count($numerators)) { if (\count($denominators) === 0) { return 'no units'; } if (\count($denominators) === 1) { return $denominators[0] . '^-1'; } return '(' . implode('*', $denominators) . ')^-1'; } return implode('*', $numerators) . (\count($denominators) ? '/' . implode('*', $denominators) : ''); } } } namespace ScssPhp\ScssPhp\SourceMap{ use ScssPhp\ScssPhp\Exception\CompilerException; class Base64 { private static $encodingMap = [ 0 => 'A', 1 => 'B', 2 => 'C', 3 => 'D', 4 => 'E', 5 => 'F', 6 => 'G', 7 => 'H', 8 => 'I', 9 => 'J', 10 => 'K', 11 => 'L', 12 => 'M', 13 => 'N', 14 => 'O', 15 => 'P', 16 => 'Q', 17 => 'R', 18 => 'S', 19 => 'T', 20 => 'U', 21 => 'V', 22 => 'W', 23 => 'X', 24 => 'Y', 25 => 'Z', 26 => 'a', 27 => 'b', 28 => 'c', 29 => 'd', 30 => 'e', 31 => 'f', 32 => 'g', 33 => 'h', 34 => 'i', 35 => 'j', 36 => 'k', 37 => 'l', 38 => 'm', 39 => 'n', 40 => 'o', 41 => 'p', 42 => 'q', 43 => 'r', 44 => 's', 45 => 't', 46 => 'u', 47 => 'v', 48 => 'w', 49 => 'x', 50 => 'y', 51 => 'z', 52 => '0', 53 => '1', 54 => '2', 55 => '3', 56 => '4', 57 => '5', 58 => '6', 59 => '7', 60 => '8', 61 => '9', 62 => '+', 63 => '/', ]; private static $decodingMap = [ 'A' => 0, 'B' => 1, 'C' => 2, 'D' => 3, 'E' => 4, 'F' => 5, 'G' => 6, 'H' => 7, 'I' => 8, 'J' => 9, 'K' => 10, 'L' => 11, 'M' => 12, 'N' => 13, 'O' => 14, 'P' => 15, 'Q' => 16, 'R' => 17, 'S' => 18, 'T' => 19, 'U' => 20, 'V' => 21, 'W' => 22, 'X' => 23, 'Y' => 24, 'Z' => 25, 'a' => 26, 'b' => 27, 'c' => 28, 'd' => 29, 'e' => 30, 'f' => 31, 'g' => 32, 'h' => 33, 'i' => 34, 'j' => 35, 'k' => 36, 'l' => 37, 'm' => 38, 'n' => 39, 'o' => 40, 'p' => 41, 'q' => 42, 'r' => 43, 's' => 44, 't' => 45, 'u' => 46, 'v' => 47, 'w' => 48, 'x' => 49, 'y' => 50, 'z' => 51, 0 => 52, 1 => 53, 2 => 54, 3 => 55, 4 => 56, 5 => 57, 6 => 58, 7 => 59, 8 => 60, 9 => 61, '+' => 62, '/' => 63, ]; public static function encode($value) { return self::$encodingMap[$value]; } public static function decode($value) { return self::$decodingMap[$value]; } } class Base64VLQ { const VLQ_BASE_SHIFT = 5; const VLQ_BASE_MASK = 31; const VLQ_CONTINUATION_BIT = 32; public static function encode($value) { $encoded = ''; $vlq = self::toVLQSigned($value); do { $digit = $vlq & self::VLQ_BASE_MASK; $vlq = (($vlq >> 1) & PHP_INT_MAX) >> (self::VLQ_BASE_SHIFT - 1); if ($vlq > 0) { $digit |= self::VLQ_CONTINUATION_BIT; } $encoded .= Base64::encode($digit); } while ($vlq > 0); return $encoded; } public static function decode($str, &$index) { $result = 0; $shift = 0; do { $c = $str[$index++]; $digit = Base64::decode($c); $continuation = ($digit & self::VLQ_CONTINUATION_BIT) != 0; $digit &= self::VLQ_BASE_MASK; $result = $result + ($digit << $shift); $shift = $shift + self::VLQ_BASE_SHIFT; } while ($continuation); return self::fromVLQSigned($result); } private static function toVLQSigned($value) { if ($value < 0) { return ((-$value) << 1) + 1; } return ($value << 1) + 0; } private static function fromVLQSigned($value) { $negate = ($value & 1) === 1; $value = ($value >> 1) & PHP_INT_MAX; if (! $negate) { return $value; } return -$value | 0x80000000; } } class SourceMapGenerator { const VERSION = 3; protected $defaultOptions = [ 'sourceRoot' => '', 'sourceMapFilename' => null, 'sourceMapURL' => null, 'sourceMapWriteTo' => null, 'outputSourceFiles' => false, 'sourceMapRootpath' => '', 'sourceMapBasepath' => '' ]; protected $encoder; protected $mappings = []; protected $contentsMap = []; protected $sources = []; protected $sourceKeys = []; private $options; public function __construct(array $options = []) { $this->options = array_replace($this->defaultOptions, $options); $this->encoder = new Base64VLQ(); } public function addMapping($generatedLine, $generatedColumn, $originalLine, $originalColumn, $sourceFile) { $this->mappings[] = [ 'generated_line' => $generatedLine, 'generated_column' => $generatedColumn, 'original_line' => $originalLine, 'original_column' => $originalColumn, 'source_file' => $sourceFile ]; $this->sources[$sourceFile] = $sourceFile; } public function saveMap($content) { $file = $this->options['sourceMapWriteTo']; assert($file !== null); $dir = \dirname($file); if (! is_dir($dir)) { throw new CompilerException( sprintf('The directory "%s" does not exist. Cannot save the source map.', $dir) ); } if (file_put_contents($file, $content) === false) { throw new CompilerException(sprintf('Cannot save the source map to "%s"', $file)); } return $this->options['sourceMapURL']; } public function generateJson($prefix = '') { $sourceMap = []; $mappings = $this->generateMappings($prefix); $sourceMap['version'] = self::VERSION; $file = $this->options['sourceMapFilename']; if ($file) { $sourceMap['file'] = $file; } $root = $this->options['sourceRoot']; if ($root) { $sourceMap['sourceRoot'] = $root; } $sourceMap['sources'] = []; foreach ($this->sources as $sourceFilename) { $sourceMap['sources'][] = $this->normalizeFilename($sourceFilename); } $sourceMap['names'] = []; $sourceMap['mappings'] = $mappings; if ($this->options['outputSourceFiles']) { $sourceMap['sourcesContent'] = $this->getSourcesContent(); } if (\count($sourceMap['sources']) && empty($sourceMap['sourceRoot'])) { unset($sourceMap['sourceRoot']); } $jsonSourceMap = json_encode($sourceMap, JSON_UNESCAPED_SLASHES); if (json_last_error() !== JSON_ERROR_NONE) { throw new \RuntimeException(json_last_error_msg()); } assert($jsonSourceMap !== false); return $jsonSourceMap; } protected function getSourcesContent() { if (empty($this->sources)) { return null; } $content = []; foreach ($this->sources as $sourceFile) { $content[] = file_get_contents($sourceFile); } return $content; } public function generateMappings($prefix = '') { if (! \count($this->mappings)) { return ''; } $prefixLines = substr_count($prefix, "\n"); $lastPrefixNewLine = strrpos($prefix, "\n"); $lastPrefixLineStart = false === $lastPrefixNewLine ? 0 : $lastPrefixNewLine + 1; $prefixColumn = strlen($prefix) - $lastPrefixLineStart; $this->sourceKeys = array_flip(array_keys($this->sources)); $groupedMap = $groupedMapEncoded = []; foreach ($this->mappings as $m) { $groupedMap[$m['generated_line']][] = $m; } ksort($groupedMap); $lastGeneratedLine = $lastOriginalIndex = $lastOriginalLine = $lastOriginalColumn = 0; foreach ($groupedMap as $lineNumber => $lineMap) { if ($lineNumber > 1) { $prefixColumn = 0; } $lineNumber += $prefixLines; while (++$lastGeneratedLine < $lineNumber) { $groupedMapEncoded[] = ';'; } $lineMapEncoded = []; $lastGeneratedColumn = 0; foreach ($lineMap as $m) { $generatedColumn = $m['generated_column'] + $prefixColumn; $mapEncoded = $this->encoder->encode($generatedColumn - $lastGeneratedColumn); $lastGeneratedColumn = $generatedColumn; if ($m['source_file']) { $index = $this->findFileIndex($m['source_file']); if ($index !== false) { $mapEncoded .= $this->encoder->encode($index - $lastOriginalIndex); $lastOriginalIndex = $index; $mapEncoded .= $this->encoder->encode($m['original_line'] - 1 - $lastOriginalLine); $lastOriginalLine = $m['original_line'] - 1; $mapEncoded .= $this->encoder->encode($m['original_column'] - $lastOriginalColumn); $lastOriginalColumn = $m['original_column']; } } $lineMapEncoded[] = $mapEncoded; } $groupedMapEncoded[] = implode(',', $lineMapEncoded) . ';'; } return rtrim(implode($groupedMapEncoded), ';'); } protected function findFileIndex($filename) { return $this->sourceKeys[$filename]; } protected function normalizeFilename($filename) { $filename = $this->fixWindowsPath($filename); $rootpath = $this->options['sourceMapRootpath']; $basePath = $this->options['sourceMapBasepath']; if (\strlen($basePath) && strpos($filename, $basePath) === 0) { $filename = substr($filename, \strlen($basePath)); } if (strpos($filename, '\\') === 0 || strpos($filename, '/') === 0) { $filename = substr($filename, 1); } return $rootpath . $filename; } public function fixWindowsPath($path, $addEndSlash = false) { $slash = ($addEndSlash) ? '/' : ''; if (! empty($path)) { $path = str_replace('\\', '/', $path); $path = rtrim($path, '/') . $slash; } return $path; } } } namespace ScssPhp\ScssPhp\Util{ class Path { public static function isAbsolute($path) { if ($path === '') { return false; } if ($path[0] === '/') { return true; } if (\DIRECTORY_SEPARATOR !== '\\') { return false; } if ($path[0] === '\\') { return true; } if (\strlen($path) < 3) { return false; } if ($path[1] !== ':') { return false; } if ($path[2] !== '/' && $path[2] !== '\\') { return false; } if (!preg_match('/^[A-Za-z]$/', $path[0])) { return false; } return true; } public static function join($part1, $part2) { if ($part1 === '' || self::isAbsolute($part2)) { return $part2; } if ($part2 === '') { return $part1; } $last = $part1[\strlen($part1) - 1]; $separator = \DIRECTORY_SEPARATOR; if ($last === '/' || $last === \DIRECTORY_SEPARATOR) { $separator = ''; } return $part1 . $separator . $part2; } } } 